<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Angular 入门</title>
    <url>/zh/2021/01/01/JS-Angular/</url>
    <content><![CDATA[<p>Angular 是一个【应用设计框架与开发平台】，用于创建高效、复杂、精致的【单页面应用】。</p>
<p>Angular 的学习曲线是非常陡峭的，门槛较高，需要熟悉 HTML、CSS、JavaScript、ES2015 如 Class 类、Module 模块等，必须用 TypeScript 来开发，用 <a href="https://www.tslang.cn/docs/handbook/classes.html" target="_blank" rel="noopener">类型</a> 实现依赖注入，还会用 <a href="https://www.tslang.cn/docs/handbook/decorators.html" target="_blank" rel="noopener">注解/装饰器</a> 来提供元数据。</p>
<a id="more"></a>

<p><a href="https://angular.cn/guide/glossary#dependency-injection-di" target="_blank" rel="noopener">依赖注入</a></p>
<p><a href="https://angular.cn/guide/dependency-injection" target="_blank" rel="noopener">Angular 中的依赖注入</a></p>
<p><a href="https://angular.cn/guide/glossary" target="_blank" rel="noopener">Angular 词汇表</a></p>
<p><a href="https://angular.cn/guide/file-structure" target="_blank" rel="noopener">Angular 项目文件结构</a></p>
<hr>
<p>架构概览</p>
<p>Angular 的基本构造块是 NgModule，它为组件提供了编译的上下文环境。 NgModule 会把相关的代码收集到一些功能集中。Angular 应用就是由一组 NgModule 定义出的。 应用至少会有一个用于引导应用的根模块，通常还会有很多特性模块。</p>
<pre><code>* 组件定义视图。视图是一组可见的屏幕元素，Angular 可以根据你的程序逻辑和数据来选择和修改它们。 每个应用都至少有一个根组件。

* 组件使用服务。服务会提供那些与视图不直接相关的功能。服务提供者可以作为依赖被注入到组件中， 这能让你的代码更加模块化、更加可复用、更加高效。</code></pre><p>模块、组件和服务都是使用装饰器的类，这装饰器会标出它们的类型并提供元数据，以告知 Angular 该如何使用它们。</p>
<pre><code>* 组件类的元数据将组件类和一个用来定义视图的模板关联起来。 模板把普通的 HTML 和 Angular 指令与绑定标记（markup）组合起来，这样 Angular 就可以在渲染 HTML 之前先修改这些 HTML。

* 服务类的元数据提供了一些信息，Angular 要用这些信息来让组件可以通过依赖注入（DI）使用该服务。</code></pre><p>应用的组件通常会定义很多视图，并进行分级组织。Angular 提供了 Router 服务来帮助你定义视图之间的导航路径。 路由器提供了先进的浏览器内导航功能。</p>
<p><a href="https://angular.cn/guide/architecture-modules" target="_blank" rel="noopener">模块</a></p>
<p>Angular 定义了 NgModule，它和 JavaScript（ES2015） 的模块不同而且有一定的互补性。 NgModule 为一个组件集声明了编译的上下文环境，它专注于某个应用领域、某个工作流或一组紧密相关的能力。 NgModule 可以将其组件和一组相关代码（如服务）关联起来，形成功能单元。</p>
<p>每个 Angular 应用都有一个根模块，通常命名为 AppModule。根模块提供了用来启动应用的引导机制。 一个应用通常会包含很多特性模块。</p>
<p>像 JavaScript 模块一样，NgModule 也可以从其它 NgModule 中导入功能，并允许导出它们自己的功能供其它 NgModule 使用。 比如，要在你的应用中使用路由器（Router）服务，就要导入 Router 这个 NgModule。</p>
<p>把你的代码组织成一些清晰的特性模块，可以帮助管理复杂应用的开发工作并实现可复用性设计。 另外，这项技术还能让你获得惰性加载（也就是按需加载模块）的优点，以尽可能减小启动时需要加载的代码体积。</p>
<p><a href="https://angular.cn/api/core/Component" target="_blank" rel="noopener">组件</a></p>
<p>每个 Angular 应用都至少有一个组件，也就是根组件，它会把组件树和页面中的 DOM 连接起来。 每个组件都会定义一个类，其中包含应用的数据和逻辑，并与一个 HTML 模板相关联，该模板定义了一个供目标环境下显示的视图。</p>
<p>@Component() 装饰器表明紧随它的那个类是一个组件，并提供模板和该组件专属的元数据。</p>
<p>装饰器是一些用于修饰 JavaScript 类的函数。Angular 定义了许多装饰器，这些装饰器会把一些特定种类的元数据附加到类上，以便 Angular 了解这些这些类的含义以及该如何使用它们。</p>
<p><a href="https://es6.ruanyifeng.com/#docs/decorator" target="_blank" rel="noopener">@Decorator</a></p>
<p><a href="https://medium.com/google-developers/exploring-es7-decorators-76ecb65fb841#.x5c2ndtx0" target="_blank" rel="noopener">@Decorator</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.module.ts</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// imports</span></span><br><span class="line"><span class="keyword">import</span> &#123; BrowserModule &#125; <span class="keyword">from</span> <span class="string">'@angular/platform-browser'</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; NgModule &#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; AppComponent &#125; <span class="keyword">from</span> <span class="string">'./app.component'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @NgModule decorator with its metadata; [es6, decorator 装饰器]</span></span><br><span class="line">@NgModule(&#123;</span><br><span class="line">  declarations: [AppComponent],</span><br><span class="line">  imports: [BrowserModule],</span><br><span class="line">  providers: [],</span><br><span class="line">  bootstrap: [AppComponent]</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppModule</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.component.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">	Component, <span class="comment">// interface 接口，继承自 Directive 装饰器</span></span><br><span class="line">	OnInit, <span class="comment">// interface 接口</span></span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'@angular/core'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">	UserService,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">'./core/user.service'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// @Component decorator [es6, decorator 装饰器]</span></span><br><span class="line">@Component(&#123;</span><br><span class="line">  selector: <span class="string">'app'</span>,</span><br><span class="line">  template: <span class="string">'&lt;router-outlet&gt;&lt;/router-outlet&gt;'</span>,</span><br><span class="line">  styles: [</span><br><span class="line">  	<span class="string">`</span></span><br><span class="line"><span class="string">  		.xxx &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  		&#125;</span></span><br><span class="line"><span class="string">  	`</span>,</span><br><span class="line">  ],</span><br><span class="line">  <span class="comment">// templateUrl: './feature/home/home.component.html',</span></span><br><span class="line">  <span class="comment">// styleUrls: [</span></span><br><span class="line">  <span class="comment">// 	'./feature/home/home.component.scss',</span></span><br><span class="line">  <span class="comment">// ],</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// implements [ts，interface 接口的实现]</span></span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">AppComponent</span> <span class="title">implements</span> <span class="title">OnInit</span> </span>&#123;</span><br><span class="line">  userId: string;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">constructor</span> (</span><br><span class="line">    private userService: UserService,</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">this</span>.userId = <span class="keyword">this</span>.userService.getUserId();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// OnInit 接口的钩子方法叫做 ngOnInit()</span></span><br><span class="line">  ngOnInit () &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>Angular</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript字符编码</title>
    <url>/zh/2018/05/04/JavaScript%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<p>最近在做 <a href="https://zhouyu1993.github.io/zh/2018/05/02/%E5%9F%BA%E4%BA%8Evue%E7%9A%84%E9%9F%B3%E4%B9%90music%E6%90%9C%E7%B4%A2(vue-music)/">vue-music</a>，接口返回的日韩文字是实体编号的形式，所以需要将其解析成可阅读的日韩文字。</p>
<a id="more"></a>

<h1 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h1><p>字符编码(Character encoding)也称字集码，是把字符集中的字符编码为指定集合中某一对象(例如：比特模式、自然数序列、8位组或者电脉冲)，以便文本在计算机中存储和通过通信网络的传递。</p>
<p>因为计算机只能处理数字，所以如果要处理文本，就必须先把文本转换为数字。</p>
<p>最早的计算机在设计时采用 8 个比特(bit)作为一个字节(byte)。所以，一个字节能表示的最大的整数就是 255(二进制 11111111 = 十进制 255)，如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是 65535，4 个字节可以表示的最大整数是 4294967295。</p>
<h1 id="比特"><a href="#比特" class="headerlink" title="比特"></a>比特</h1><p>比特(BIT，binary system)，计算机专业术语，是信息量单位。同时也是二进制数字中的位，信息量的度量单位，为信息量的最小单位。</p>
<p>8 bit (位) = 1 B (字节)</p>
<p>计算机中的 CPU 位数指的是 CPU 一次能处理的最大位数。例如 32 位计算机的 CPU 一次最多能处理 32 位数据。</p>
<p>二进制数系统中，每个 0 或 1 就是一个位(bit)。</p>
<p>二进制：00000000 (0) ~ 11111111 (255)</p>
<p><code>parseInt(string, radix)</code> 返回一个十进制的整数。string 指需被解析的字符串，其实字符串会先被转化为数字(<code>Number(string)</code>)；radix 指需解析的数字的基数(进制)，值介于 2 ~ 36 之间，非必填。</p>
<p>如果 radix 不填，默认为十进制。</p>
<p>如果 radix 不填，但是 string 是以 ‘0’ 开头，则有可能是八进制有可能是十进制；string 是以 ‘0x’ 开头，则是十六进制。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">parseInt</span>(<span class="string">'00000000'</span>, <span class="number">2</span>) <span class="comment">// -&gt; parseInt(0, 2)</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">0</span>, <span class="number">2</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'00000011'</span>, <span class="number">2</span>) <span class="comment">// -&gt; parseInt(11, 2)</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">11</span>, <span class="number">2</span>) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'11111111'</span>, <span class="number">2</span>) <span class="comment">// -&gt; parseInt(11111111, 2)</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">11111111</span>, <span class="number">2</span>) <span class="comment">// 255</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'00000011'</span>, <span class="number">8</span>) <span class="comment">// -&gt; parseInt(11, 8)</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">11</span>, <span class="number">8</span>) <span class="comment">// 9</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'00000011'</span>, <span class="number">16</span>) <span class="comment">// -&gt; parseInt(11, 16)</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">11</span>, <span class="number">16</span>) <span class="comment">// 17</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 十进制</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'00000011'</span>) <span class="comment">// -&gt; parseInt(11)</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">11</span>) <span class="comment">// 11</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 八进制</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">00000000</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">00000007</span>) <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">00000010</span>) <span class="comment">// 8</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">00000011</span>) <span class="comment">// 9</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">00000017</span>) <span class="comment">// 15</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">00000020</span>) <span class="comment">// 16</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 十六进制</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'0x000011'</span>) <span class="comment">// -&gt; parseInt(0x000011)</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">0x000011</span>) <span class="comment">// 17</span></span><br></pre></td></tr></table></figure>

<h1 id="字节"><a href="#字节" class="headerlink" title="字节"></a>字节</h1><p>字节(Byte)，指一小组相邻的二进制数码。</p>
<p>ASCII 码：一个英文字母(不分大小写)占一个字节的空间，一个中文占两个字节的空间。一个二进制数字序列，在计算机中作为一个数字单元，一般为 8 位二进制数，换算为十进制。最小值 0，最大值 255。如一个 ASCII 码就是一个字节。</p>
<p>utf-8：一个英文字符(含英文标点)等于一个字节，一个中文(含繁体和中文标点)等于三个字节。</p>
<p>Unicode：一个英文(含英文标点)等于两个字节，一个中文(含繁体和中文标点)等于两个字节。</p>
<p>字通常分为若干个字节，每个字所包含的位数称为字长。</p>
<h1 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h1><p>如需正确地显示 HTML 页面，浏览器必须知道使用何种字符集。</p>
<h2 id="ASCII-码"><a href="#ASCII-码" class="headerlink" title="ASCII 码"></a>ASCII 码</h2><p>万维网早期使用的字符集是 ASCII 码。ASCII 码支持 0-9 的数字，大写和小写英文字母表，以及一些特殊字符。</p>
<p>HTML 和 XHTML 用标准的 7 比特 ASCII 码在网络上传输数据。</p>
<p>7 比特 ASCII 码可提供 128 个不同的字符值。<code>&amp;#00; ~ &amp;#127;</code></p>
<p>通常会额外使用一个扩充的比特，以便于以 1 个字节的方式存储，1 个字节等于 8 比特。</p>
<p><code>&amp;#32; ~ &amp;#126;</code> 是可显示的 ASCII 码。</p>
<p><code>&amp;#00; ~ &amp;#31;</code> 和 <code>&amp;#127;</code> 是设备控制 ASCII 码，不可在 HTML 文档中显示。</p>
<h2 id="ISO-字符集"><a href="#ISO-字符集" class="headerlink" title="ISO 字符集"></a>ISO 字符集</h2><p><a href="http://www.w3school.com.cn/tags/html_ref_charactersets.asp" target="_blank" rel="noopener">ISO 字符集</a>是国际标准组织 (ISO) 针对不同的字母表 / 语言定义的标准字符集。</p>
<table>
<thead>
<tr>
<th>ISO 字符集</th>
<th>描述</th>
<th>使用范围</th>
</tr>
</thead>
<tbody><tr>
<td>ISO-8859-1</td>
<td>Latin alphabet part 1</td>
<td>北美、西欧、拉丁美洲、加勒比海、加拿大、非洲</td>
</tr>
<tr>
<td>ISO-8859-2</td>
<td>Latin alphabet part 2</td>
<td>东欧</td>
</tr>
<tr>
<td>…</td>
<td>…</td>
<td>…</td>
</tr>
<tr>
<td>ISO-2022-JP</td>
<td>Latin/Japanese part 1</td>
<td>日本语</td>
</tr>
<tr>
<td>ISO-2022-KR</td>
<td>Latin/Korean part 1</td>
<td>韩语</td>
</tr>
</tbody></table>
<h2 id="ISO-8859-1"><a href="#ISO-8859-1" class="headerlink" title="ISO 8859-1"></a>ISO 8859-1</h2><p>HTML 4.01 支持 <a href="http://www.w3school.com.cn/tags/html_ref_entities.html" target="_blank" rel="noopener">ISO 8859-1 字符集</a>。</p>
<p>ISO-8859-1 的较低部分(从 1 到 127 之间的代码)是最初的 7 比特 ASCII 码。</p>
<p>ISO-8859-1 的较高部分(从 160 到 255 之间的代码)全都有实体名称。</p>
<p>这些符号中的大多数都可以在不进行实体引用的情况下使用，但是实体名称或实体编号为那些不容易通过键盘键入的符号提供了表达的方法。</p>
<p>注释：实体名称对大小写敏感。</p>
<h2 id="Unicode-标准"><a href="#Unicode-标准" class="headerlink" title="Unicode 标准"></a>Unicode 标准</h2><p>由于上面列出的字符集都有容量限制，而且不兼容多语言环境，Unicode 联盟开发了 Unicode 标准。</p>
<p>Unicode 标准涵盖了世界上的所有字符、标点和符号。</p>
<p>不论是何种平台、程序或语言，Unicode 都能够进行文本数据的处理、存储和交换。</p>
<p>Unicode 可以被不同的字符集兼容。最常用的编码方式是 utf-8 和 utf-16。</p>
<p>utf-8：</p>
<p>utf-8 中的字符可以是 1-4 个字节长。utf-8 可以表示 Unicode 标准中的任意字符。utf-8 向后兼容 ASCII 码。utf-8 是网页和电子邮件的首选编码。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>utf-16：</p>
<p>16 比特的 Unicode 转换格式是一种 Unicode 可变字符编码，能够对全部 Unicode 指令表进行编码。utf-16 主要被用于操作系统和环境中，比如微软的 Windows 2000/XP/2003/Vista/CE 以及 Java 和 .NET 字节代码环境。</p>
<p>提示：最前面的 256 个 Unicode 字符集字符对应于 256 个 ISO-8859-1 字符。</p>
<p>提示：所有 HTML 4 处理器均已支持 utf-8，而所有 XHTML 和 XML 处理器支持 utf-8 和 utf-16。</p>
<h2 id="HTML-4-01-符号实体"><a href="#HTML-4-01-符号实体" class="headerlink" title="HTML 4.01 符号实体"></a>HTML 4.01 符号实体</h2><p><a href="http://www.w3school.com.cn/tags/html_ref_symbols.html" target="_blank" rel="noopener">本字符实体参考手册</a>包括了数学符号、希腊字符、各种箭头记号、科技符号以及形状。</p>
<p>注释：实体名称对大小写敏感。</p>
<h1 id="实体名称与实体编号"><a href="#实体名称与实体编号" class="headerlink" title="实体名称与实体编号"></a>实体名称与实体编号</h1><p>实体名称不一定有，但实体编码一定有!</p>
<table>
<thead>
<tr>
<th>结果</th>
<th>实体名称</th>
<th>实体编号</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;</code></td>
<td><code>&amp;amp;</code></td>
<td><code>&amp;#38;</code></td>
</tr>
<tr>
<td><code>♥</code></td>
<td><code>&amp;hearts;</code></td>
<td><code>&amp;#9829;</code></td>
</tr>
<tr>
<td><code>지</code></td>
<td>-</td>
<td><code>&amp;#51648;</code></td>
</tr>
<tr>
<td><code>𠮷</code></td>
<td>-</td>
<td><code>&amp;#134071;</code></td>
</tr>
</tbody></table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span>&gt;</span>♥<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span>&gt;</span>&amp;hearts;<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span>&gt;</span>&amp;#9829;<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span>&gt;</span>지<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span>&gt;</span>&amp;#51648;<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span>&gt;</span>𠮷<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">i</span>&gt;</span>&amp;#134071;<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>显示结果</p>
<p><img src="https://cmspic-10004025.image.myqcloud.com/ea5b4a70-4f66-11e8-b657-f98083298d38_size_232x234" alt="结果"></p>
<h2 id="实体编码的显示"><a href="#实体编码的显示" class="headerlink" title="实体编码的显示"></a>实体编码的显示</h2><p>一般在 HTML 代码里写实体编码，会被直接识别成结果显示在网页上。</p>
<p>如果需要在网页上显示出实体编码，只需要将 <code>&amp;</code> 写成 <code>&amp;#38;</code>。例如想显示 <code>&amp;#134071;</code> 即写成 <code>&amp;#38;#134071;</code>。另外还有一种形式，利用伪元素 <code>:before</code> 或 <code>:after</code> 的 css <code>content</code> 属性。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>&amp;#38;#134071;<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span> <span class="attr">class</span>=<span class="string">"showCode"</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.showCode</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">'&amp;#134071;'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="显示结果与实体编码的互相转化"><a href="#显示结果与实体编码的互相转化" class="headerlink" title="显示结果与实体编码的互相转化"></a>显示结果与实体编码的互相转化</h2><p><code>&amp;#00; ~ &amp;#31;</code> 和 <code>&amp;#127;</code> 无效，因为它们不会在 HTML 文档中显示。</p>
<h3 id="显示结果转实体编码"><a href="#显示结果转实体编码" class="headerlink" title="显示结果转实体编码"></a>显示结果转实体编码</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encodeChar</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">  div.innerText = input</span><br><span class="line">  <span class="keyword">const</span> output = div.innerHTML</span><br><span class="line">  <span class="keyword">return</span> output</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">encodeChar(<span class="string">'&amp;'</span>) <span class="comment">// '&amp;amp;'</span></span><br><span class="line">encodeChar(<span class="string">'♥'</span>) <span class="comment">// '♥'，失效</span></span><br><span class="line">encodeChar(<span class="string">'지'</span>) <span class="comment">// '지'，失效</span></span><br><span class="line">encodeChar(<span class="string">'𠮷'</span>) <span class="comment">// '𠮷'，失效</span></span><br><span class="line">encodeChar(<span class="string">'&amp;♥지𠮷'</span>) <span class="comment">// '&amp;amp;♥지𠮷'，失效</span></span><br><span class="line">encodeChar(<span class="string">'지나;정일훈'</span>) <span class="comment">// '지나;정일훈'，失效</span></span><br></pre></td></tr></table></figure>

<p>我们发现，这种只对 ASCII 码有效(<code>&amp;#32; ~ &amp;#126;</code>)，但返回的是 ASCII 码的实体名称形式，而且只能在客户端使用(依赖 window.document)。</p>
<p>推荐采取下面方式，借助 <code>for...of</code> 和 <code>codePointAt</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">encodeChar</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> output = <span class="string">''</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> input) &#123;</span><br><span class="line">    output += <span class="string">`&amp;#<span class="subst">$&#123;key.codePointAt(<span class="number">0</span>)&#125;</span>;`</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> output</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">encodeChar(<span class="string">'&amp;'</span>) <span class="comment">// '&amp;#38;'</span></span><br><span class="line">encodeChar(<span class="string">'♥'</span>) <span class="comment">// '&amp;#9829;'</span></span><br><span class="line">encodeChar(<span class="string">'지'</span>) <span class="comment">// '&amp;#51648;'</span></span><br><span class="line">encodeChar(<span class="string">'𠮷'</span>) <span class="comment">// '&amp;#134071;'</span></span><br><span class="line">encodeChar(<span class="string">'&amp;♥지𠮷'</span>) <span class="comment">// '&amp;#38;&amp;#9829;&amp;#51648;&amp;#134071;'</span></span><br><span class="line">encodeChar(<span class="string">'지나;정일훈'</span>) <span class="comment">// '&amp;#51648;&amp;#45208;&amp;#59;&amp;#51221;&amp;#51068;&amp;#54984;'</span></span><br></pre></td></tr></table></figure>

<h3 id="实体编码转显示结果"><a href="#实体编码转显示结果" class="headerlink" title="实体编码转显示结果"></a>实体编码转显示结果</h3><p>遇到特殊字符如日韩文字的时候，后端返回给前端的数据通常会是实体编码的形式，因为是异步获取并非是直接写在 HTML 代码中，所以无法被浏览器解析，从而需要前端进行转义。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decodeChar</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> div = <span class="built_in">document</span>.createElement(<span class="string">'div'</span>)</span><br><span class="line">  div.innerHTML = input</span><br><span class="line">  <span class="keyword">const</span> output = div.innerText</span><br><span class="line">  <span class="keyword">return</span> output</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">decodeChar(<span class="string">'&amp;#38;'</span>) <span class="comment">// '&amp;'</span></span><br><span class="line">decodeChar(<span class="string">'&amp;#9829;'</span>) <span class="comment">// '♥'</span></span><br><span class="line">decodeChar(<span class="string">'&amp;#51648;'</span>) <span class="comment">// '지'</span></span><br><span class="line">decodeChar(<span class="string">'&amp;#134071;'</span>) <span class="comment">// '𠮷'</span></span><br><span class="line">decodeChar(<span class="string">'&amp;#38;&amp;#9829;&amp;#51648;&amp;#134071;'</span>) <span class="comment">// '&amp;♥지𠮷'</span></span><br><span class="line">decodeChar(<span class="string">'&amp;#51648;&amp;#45208;&amp;#59;&amp;#51221;&amp;#51068;&amp;#54984;'</span>) <span class="comment">// '지나;정일훈'</span></span><br><span class="line">decodeChar(<span class="string">'&amp;#51648;&amp;#45208;;&amp;#51221;&amp;#51068;&amp;#54984;'</span>) <span class="comment">// '지나;정일훈'</span></span><br></pre></td></tr></table></figure>

<p>这种方式只能在客户端使用(依赖 window.document)。</p>
<p>推荐采取下面方式，借助 <code>正则表达式</code> 和 <code>String.fromCodePoint</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decodeChar</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> output = input.replace(<span class="regexp">/&amp;#&#123;1&#125;[0-9]&#123;1,&#125;;&#123;1&#125;/ig</span>, (v) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> code = v.replace(<span class="regexp">/&amp;#(.*);/</span>, <span class="string">'$1'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>.fromCodePoint(code)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> output</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">decodeChar(<span class="string">'&amp;#38;'</span>) <span class="comment">// '&amp;'</span></span><br><span class="line">decodeChar(<span class="string">'&amp;#9829;'</span>) <span class="comment">// '♥'</span></span><br><span class="line">decodeChar(<span class="string">'&amp;#51648;'</span>) <span class="comment">// '지'</span></span><br><span class="line">decodeChar(<span class="string">'&amp;#134071;'</span>) <span class="comment">// '𠮷'</span></span><br><span class="line">decodeChar(<span class="string">'&amp;#38;&amp;#9829;&amp;#51648;&amp;#134071;'</span>) <span class="comment">// '&amp;♥지𠮷'</span></span><br><span class="line">decodeChar(<span class="string">'&amp;#51648;&amp;#45208;&amp;#59;&amp;#51221;&amp;#51068;&amp;#54984;'</span>) <span class="comment">// '지나;정일훈'</span></span><br><span class="line">decodeChar(<span class="string">'&amp;#51648;&amp;#45208;;&amp;#51221;&amp;#51068;&amp;#54984;'</span>) <span class="comment">// '지나;정일훈'</span></span><br></pre></td></tr></table></figure>

<h3 id="ES6-中字符串的扩展"><a href="#ES6-中字符串的扩展" class="headerlink" title="ES6+ 中字符串的扩展"></a>ES6+ 中字符串的扩展</h3><p>JavaScript 内部，字符以 utf-16 的格式储存，每个字符固定为 2 个字节。对于那些需要 4 个字节储存的字符(Unicode 码点大于 0xffff，即 65535 的字符)，JavaScript 不能正确处理，JavaScript 会认为它们是两个字符，字符串长度会误判为 2，charCodeAt 方法只能分别返回前两个字节和后两个字节的值。</p>
<p><code>지</code> 这个字的码点是 51648(十进制)，ES6 之前的字符串方法处理是没有问题。</p>
<p><code>𠮷</code> 这个字的码点是 134071(十进制)，ES6 之前的字符串方法处理就会有问题。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'지'</span>.length <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="string">'지'</span>.charAt(<span class="number">0</span>) <span class="comment">// '지'</span></span><br><span class="line"><span class="string">'지'</span>.charCodeAt(<span class="number">0</span>) <span class="comment">// 51648，码点，十进制</span></span><br><span class="line"><span class="string">'지'</span>.charCodeAt(<span class="number">0</span>).toString(<span class="number">16</span>) <span class="comment">// 'c9c0'</span></span><br><span class="line">+(<span class="string">'0x'</span> + <span class="string">'지'</span>.charCodeAt(<span class="number">0</span>).toString(<span class="number">16</span>)) <span class="comment">// '0xc9c0' -&gt; 0xc9c0 码点，十六进制 -&gt; 51648</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES 6</span></span><br><span class="line"><span class="string">'지'</span>.codePointAt(<span class="number">0</span>) <span class="comment">// 51648，码点，十进制</span></span><br><span class="line"><span class="string">'지'</span>.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>) <span class="comment">// 'c9c0'</span></span><br><span class="line">+(<span class="string">'0x'</span> + <span class="string">'지'</span>.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>)) <span class="comment">// '0xc9c0' -&gt; 0xc9c0 码点，十六进制 -&gt; 51648</span></span><br><span class="line"></span><br><span class="line"><span class="number">51648</span> === <span class="number">0xc9c0</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">0xc9c0</span>) <span class="comment">// 51648</span></span><br><span class="line"></span><br><span class="line"><span class="string">'지'</span> === <span class="string">'\uc9c0'</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES 6</span></span><br><span class="line"><span class="string">'지'</span> === <span class="string">'\u&#123;c9c0&#125;'</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">51648</span>) <span class="comment">// '지'</span></span><br><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">0xc9c0</span>) <span class="comment">// '지'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES 6</span></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">51648</span>) <span class="comment">// '지'</span></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0xc9c0</span>) <span class="comment">// '지'</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'𠮷'</span>.length <span class="comment">// 2。字符串长度误被判为 2</span></span><br><span class="line"></span><br><span class="line"><span class="string">'𠮷'</span>.charAt(<span class="number">0</span>) <span class="comment">// '�'，失效</span></span><br><span class="line"><span class="string">'𠮷'</span>.charAt(<span class="number">1</span>) <span class="comment">// '�'，失效</span></span><br><span class="line"></span><br><span class="line"><span class="string">'𠮷'</span>.charCodeAt(<span class="number">0</span>) <span class="comment">// 55362，码点，十进制，失效</span></span><br><span class="line"><span class="string">'𠮷'</span>.charCodeAt(<span class="number">0</span>).toString(<span class="number">16</span>) <span class="comment">// 'd842'，失效</span></span><br><span class="line">+(<span class="string">'0x'</span> + <span class="string">'𠮷'</span>.charCodeAt(<span class="number">0</span>).toString(<span class="number">16</span>)) <span class="comment">// '0xd842' -&gt; 0xd842 码点，十六进制 -&gt; 55362，失效</span></span><br><span class="line"><span class="string">'𠮷'</span>.charCodeAt(<span class="number">1</span>) <span class="comment">// 57271，码点，十进制，失效</span></span><br><span class="line"><span class="string">'𠮷'</span>.charCodeAt(<span class="number">1</span>).toString(<span class="number">16</span>) <span class="comment">// 'dfb7'，失效</span></span><br><span class="line">+(<span class="string">'0x'</span> + <span class="string">'𠮷'</span>.charCodeAt(<span class="number">1</span>).toString(<span class="number">16</span>)) <span class="comment">// '0xdfb7' -&gt; 0xdfb7 码点，十六进制 -&gt; 57271，失效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES 6</span></span><br><span class="line"><span class="string">'𠮷'</span>.codePointAt(<span class="number">0</span>) <span class="comment">// 134071，码点，十进制</span></span><br><span class="line"><span class="string">'𠮷'</span>.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>) <span class="comment">// '20bb7'</span></span><br><span class="line">+(<span class="string">'0x'</span> + <span class="string">'𠮷'</span>.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>)) <span class="comment">// '0x20bb7' -&gt; 0x20bb7 码点，十六进制 -&gt; 134071</span></span><br><span class="line"><span class="string">'𠮷'</span>.codePointAt(<span class="number">1</span>) <span class="comment">// 57271，码点，十进制</span></span><br><span class="line"><span class="string">'𠮷'</span>.codePointAt(<span class="number">1</span>).toString(<span class="number">16</span>) <span class="comment">// 'dfb7'</span></span><br><span class="line">+(<span class="string">'0x'</span> + <span class="string">'𠮷'</span>.codePointAt(<span class="number">1</span>).toString(<span class="number">16</span>)) <span class="comment">// '0xdfb7' -&gt; 0xdfb7 码点，十六进制 -&gt;57271</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// codePointAt 方法在第一个字符(即 “𠮷” 的前两个字节)上，正确地识别了 “𠮷”，返回了它的十进制码点 134071(即十六进制的 0x20bb7)。在第二个字符(即 “𠮷” 的后两个字节)上，codePointAt 方法的结果与 charCodeAt 方法相同。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于类似字符串 '𠮷a'，字符 'a' 在字符串 '𠮷a' 的正确位置序号应该是 1，但是必须向 codePointAt 方法传入 2。解决这个问题的一个办法是使用 `for...of` 循环，因为它会正确识别 32 位的 utf-16 字符。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="string">'𠮷a'</span>) &#123;</span><br><span class="line">  i ++</span><br><span class="line">  <span class="built_in">console</span>.log(key, i)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// '𠮷', 0</span></span><br><span class="line"><span class="comment">// 'a', 1</span></span><br><span class="line"></span><br><span class="line"><span class="number">134071</span> === <span class="number">0x20bb7</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">0x20bb7</span>) <span class="comment">// 134071</span></span><br><span class="line"></span><br><span class="line"><span class="string">'𠮷'</span> === <span class="string">'\u20bb7'</span> <span class="comment">// false，失效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES 6</span></span><br><span class="line"><span class="string">'𠮷'</span> === <span class="string">'\u&#123;20bb7&#125;'</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">134071</span>) <span class="comment">// 'ஷ'，失效</span></span><br><span class="line"><span class="built_in">String</span>.fromCharCode(<span class="number">0x20bb7</span>) <span class="comment">// 'ஷ'，失效</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES 6</span></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">134071</span>) <span class="comment">// '𠮷'</span></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x20bb7</span>) <span class="comment">// '𠮷'</span></span><br></pre></td></tr></table></figure>

<h1 id="字体图标的使用"><a href="#字体图标的使用" class="headerlink" title="字体图标的使用"></a>字体图标的使用</h1><p><a href="http://www.iconfont.cn/" target="_blank" rel="noopener">iconfont</a></p>
<p>IE9+，Chrome，Safari，Firefox 和 Opera</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">@<span class="keyword">font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">'iconfont'</span>;</span><br><span class="line">  src: url('../font/iconfont.eot'); // IE9+</span><br><span class="line">  src: url('../font/iconfont.eot?t=1491903330819#iefix') format('embedded-opentype'), // IE6 - IE8</span><br><span class="line">  url('../font/iconfont.woff?t=1491903330819') format('woff'), // Modern Browsers</span><br><span class="line">  url('../font/iconfont.ttf?t=1491903330819') format('truetype'), // Safari, IOS, Android</span><br><span class="line">  url('../font/iconfont.svg?t=1491903330819#iconfont') format('svg'); // IOS</span><br><span class="line">  <span class="selector-tag">font-stretch</span>: <span class="selector-tag">normal</span>;</span><br><span class="line">  <span class="selector-tag">font-style</span>: <span class="selector-tag">normal</span>;</span><br><span class="line">  <span class="selector-tag">font-weight</span>: <span class="selector-tag">normal</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.iconfont</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">'iconfont'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.icon-pause</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">'\e66a'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>unicode-range</code> 定义字体支持的 Unicode 字符范围。默认是 “U+0-10FFFF”。</p>
<h1 id="Emoji-表情符号的使用"><a href="#Emoji-表情符号的使用" class="headerlink" title="Emoji 表情符号的使用"></a>Emoji 表情符号的使用</h1><p><a href="http://www.ruanyifeng.com/blog/2017/04/emoji.html" target="_blank" rel="noopener">Emoji 简介</a></p>
<p>2010年，Unicode 开始为 Emoji 分配码点。也就是说，现在的 Emoji 符号就是一个文字，它会被渲染为图形。</p>
<p><a href="http://www.unicode.org/emoji/charts/full-emoji-list.html" target="_blank" rel="noopener">Full Emoji List</a></p>
<p><a href="https://www.npmjs.com/package/node-emoji" target="_blank" rel="noopener">node-emoji</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 码点 U+1F600 (十六进制)</span></span><br><span class="line"><span class="comment">// 对应 0x1F600</span></span><br><span class="line"><span class="built_in">String</span>.fromCodePoint(<span class="number">0x1F600</span>) <span class="comment">// 😀</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="number">0x1F600</span>) <span class="comment">// 码点 128512 (十进制)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// HTML 实体编码 &amp;#128512;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">decodeChar</span> (<span class="params">input</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> output = input.replace(<span class="regexp">/&amp;#&#123;1&#125;[0-9]&#123;1,&#125;;&#123;1&#125;/ig</span>, (v) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> code = v.replace(<span class="regexp">/&amp;#(.*);/</span>, <span class="string">'$1'</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">String</span>.fromCodePoint(code)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="keyword">return</span> output</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">decodeChar(<span class="string">'&amp;#128512;'</span>) <span class="comment">// 😀</span></span><br></pre></td></tr></table></figure>

<h2 id="微信翻译：JS-之汉字与-Unicode-码的相互转化"><a href="#微信翻译：JS-之汉字与-Unicode-码的相互转化" class="headerlink" title="微信翻译：JS 之汉字与 Unicode 码的相互转化"></a>微信翻译：JS 之汉字与 Unicode 码的相互转化</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'好'</span>.charCodeAt(<span class="number">0</span>).toString(<span class="number">16</span>) <span class="comment">// '597d'</span></span><br><span class="line"></span><br><span class="line"><span class="string">'好'</span> === <span class="string">'\u597d'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有问题，无法兼容非汉字，如数字字母字符</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toUnicode</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (str == <span class="string">''</span> || <span class="keyword">typeof</span> str == <span class="string">'undefined'</span>) <span class="keyword">return</span> <span class="string">'请输入汉字'</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> str =<span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i ++) &#123;</span><br><span class="line">    str += <span class="string">'\\u'</span> + str.charCodeAt(i).toString(<span class="number">16</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有问题，无法兼容非汉字，如数字字母字符</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">toGB2312</span> (<span class="params">str</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (str == <span class="string">''</span> || <span class="keyword">typeof</span> str == <span class="string">'undefined'</span>) <span class="keyword">return</span> <span class="string">'请输入十六进制unicode'</span></span><br><span class="line"></span><br><span class="line">  str = str.split(<span class="string">'\\u'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> str = <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; str.length; i ++) &#123;</span><br><span class="line">    str += <span class="built_in">String</span>.fromCharCode(<span class="built_in">parseInt</span>(str[i], <span class="number">16</span>).toString(<span class="number">10</span>))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 考虑怎么确定汉子的范围</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 兼容</span></span><br><span class="line"><span class="comment">// escape 与 unescape</span></span><br><span class="line"><span class="keyword">const</span> GB2312UnicodeConverter = &#123;</span><br><span class="line">  ToUnicode: <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">escape</span>(str).toLocaleLowerCase().replace(<span class="regexp">/%u/gi</span>, <span class="string">'\\u'</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  ToGB2312: <span class="function"><span class="keyword">function</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unescape</span>(str.replace(<span class="regexp">/\\u/gi</span>, <span class="string">'%u'</span>))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript安全整数</title>
    <url>/zh/2018/08/24/JavaScript%E5%AE%89%E5%85%A8%E6%95%B4%E6%95%B0/</url>
    <content><![CDATA[<p>最近在做收银台业务，成功下单后，后端需要返回给前端订单号，前端根据订单号去跳转收银台，然后付款。但是碰到个奇怪的问题，一致订单异常。</p>
<a id="more"></a>

<p>一开始，我觉得订单异常，肯定是后端某个环节有问题，我前端就负责拿订单号去跳转收银台，能出什么问题？</p>
<p>我指着下单接口，“你看，你接口给我的订单号是 <code>201808221019001800</code>”，又指着收银台接口，“你看，我传给收银台的订单号是 <code>201808221019001800</code>”，这订单异常，肯定是后端有问题啊！</p>
<p>后端调试了半天，找不到原因，“我这都查过了，我写的代码都是对的啊！不过为什么你的订单号是 201808221019001800，我后台查不到这个订单啊！而且你的 uid 是 10007777，订单尾号应该是 1777 才对，我订单号取的逻辑是 ‘年月日时分秒’ 再加 uid 的第一位和后三位！是不是你那边请求问题啊”。</p>
<p>我心里呵呵一笑，我就请求个接口，还能请求出问题？我前端就负责调接口，你接口返回给我什么，我就展示什么，我还能改你返回的数据？我又没拦截！</p>
<p>我去后台查了一下订单，我特么发现后台记录的那条订单，真是 <code>201808221019001777</code>。但到底为啥给我的就是 <code>201808221019001800</code> 呢？虽然不知道什么原因，但我不管，一定是后端处理错了！</p>
<p>后端说，那好，我在返回之前打个日志，我看看我给你的到底是什么，你调调看。</p>
<p>试了一下，他打出的是 <code>201808221019001777</code>，我拿到的是 <code>201808221019001800</code>。呐呢？</p>
<p>后端说那肯定是你调用的问题吧，我用 <code>postman</code> 试了试，我调出来的也是 <code>201808221019001777</code>。这越发让我疑惑。</p>
<p>于是我也用 <code>postman</code> 调用，特么真的是 <code>201808221019001777</code>，我又在 <code>chrome</code> 控制台调用，特么竟然又是 <code>201808221019001800</code>，什么鬼哦？还有这种操作？</p>
<p>突然鬼使神差地，我在 <code>chrome</code> 控制台输入了 <code>201808221019001777</code>，按下 <code>return</code> 键，特么返回了 <code>201808221019001800</code>。</p>
<p>尼玛！原来是浏览器处理了！</p>
<p>接口给的 <code>201808221019001777</code> 是个 <code>Number</code> 类型，超过了浏览器(js)能处理的最大安全整数！</p>
<p>解决方案就是接口转化为 <code>String</code> 类型返回。</p>
<h3 id="最大安全整数、最小安全整数"><a href="#最大安全整数、最小安全整数" class="headerlink" title="最大安全整数、最小安全整数"></a>最大安全整数、最小安全整数</h3><p>js 最大安全整数是 <code>Number.MAX_SAFE_INTEGER</code>，最小安全整数是 <code>Number.MIN_SAFE_INTEGER</code>，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER <span class="comment">// 9007199254740991</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER <span class="comment">// -9007199254740991</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER === <span class="number">1</span> - <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="2-的-53-次方"><a href="#2-的-53-次方" class="headerlink" title="2 的 53 次方"></a>2 的 53 次方</h3><p>js 安全整数的范围是 (Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER) 即 -2^53~2^53 (不包含边界) 。</p>
<p>安全整数，意思是说能够 one-by-one 表示的整数，也就是说在(-2^53, 2^53)范围内，双精度数表示和整数是一对一的，反过来说，在这个范围以内，所有的整数都有唯一的浮点数表示，这叫做安全整数。超过这个范围，会有两个或更多整数的双精度表示是相同的；反过来说，超过这个范围，有的整数是无法精确表示的，只能round到与它相近的浮点数（说到底就是科学计数法）表示，这种情况下叫做不安全整数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) <span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span> <span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">2</span> <span class="comment">// 9007199254740994</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">3</span> <span class="comment">// 9007199254740996</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">4</span> <span class="comment">// 9007199254740996</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow（<span class="number">2</span>,<span class="number">53</span>）+ <span class="number">5</span> <span class="comment">// 9007199254740996</span></span><br></pre></td></tr></table></figure>

<p>当运算数与运算结果都处于安全整数的范围内时，才能保证 js 运算结果正确。</p>
<p>请求接口中返回一个整数，例如订单号，是个不安全整数，就会导致前端处理异常！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">201808221019001777</span> <span class="comment">// 被处理成 201808221019001800</span></span><br></pre></td></tr></table></figure>

<p>js 安全整数的范围为啥是 (Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER) 即 -2^53~2^53 (不包含边界) ？</p>
<p>js 里数字类型只有一种，Number 类型，是双精度浮点型，都是 64-bit (1bit 的符号位，11bits 的指数部分，以及 52bits 的小数部分) 的双精度浮点数(double)！</p>
<p>js 里的整型 int 是 双精度浮点型 double 的一个子集，而不是一个独立的数据类型。</p>
<p>由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心！</p>
<p>引申问题：</p>
<ul>
<li><a href="https://u3xyz.com/detail/28" target="_blank" rel="noopener">0.1 + 0.2 为什么不等于 0.3</a></li>
<li><a href="https://yuchengkai.cn/docs/zh/frontend/#%E4%B8%BA%E4%BB%80%E4%B9%88-0-1-0-2-0-3" target="_blank" rel="noopener">0.1 + 0.2 为什么不等于 0.3</a></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="number">1</span> <span class="comment">// number</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">1.0</span> <span class="comment">// number</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> === <span class="number">1.0</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p><a href="https://en.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">IEEE 754 双精度浮点数</a>。</p>
<p><a href="https://www.zhihu.com/question/29010688" target="_blank" rel="noopener">参考1</a></p>
<p><a href="http://2ality.com/2013/10/safe-integers.html" target="_blank" rel="noopener">参考3</a></p>
<p><a href="http://steve.hollasch.net/cgindex/coding/ieeefloat.html" target="_blank" rel="noopener">参考2</a></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js 实现 xls 转 pdf</title>
    <url>/zh/2021/01/01/JS-xls2pdf/</url>
    <content><![CDATA[<h1 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h1><p>先说结论，<a href="http://www.alltoall.net/" target="_blank" rel="noopener">alltoall</a></p>
<h1 id="js-探索"><a href="#js-探索" class="headerlink" title="js 探索"></a>js 探索</h1><p>xls2json</p>
<p>json2html</p>
<p>html2pdf</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript模块的演变</title>
    <url>/zh/2018/01/08/JavaScript%E6%A8%A1%E5%9D%97%E7%9A%84%E6%BC%94%E5%8F%98/</url>
    <content><![CDATA[<p>ES6 带来的原生 JavaScript 模块体系，相信你已经用起来了，如果还没有，那你还有时间看文章？看什么看，你还不赶紧去用用。</p>
<a id="more"></a>

<p>转载：<a href="https://zhuanlan.zhihu.com/p/32554482" target="_blank" rel="noopener">原生 JavaScript 模块的现在与未来</a></p>
<p>JavaScript 一开始并没有内建模块化支持，也几乎没有模块化这种概念。当时没那么大的需求，搞个模块化显得大材小用啊。随着互联网的发展，尤其是 2006 年 ajax 技术的出现和之后 Web 2.0 的兴起，越来越多的业务逻辑向前端转移，前端开发的复杂程度和代码量逐渐提升。这时，由于缺乏模块化概念，JavaScript 的一些问题便凸显出来：代码难以复用、容易出现全局变量污染和命名冲突、依赖管理难以维护等等。一开始，开发者们使用诸如暴露全局对象、自执行函数等方法来规避这些问题，但仍无法从根本上解决问题。</p>
<h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>2009 年，基于将 JavaScript 应用于服务端的尝试，ServerJS 诞生了。之后 ServerJS 更名为 CommonJS，并逐步发展为一个完整的模块规范。简称 CMD(Common Module Definition)</p>
<p><a href="http://www.commonjs.org/" target="_blank" rel="noopener">CommonJS官网</a><br><a href="http://javascript.ruanyifeng.com/nodejs/module.html" target="_blank" rel="noopener">CommonJS阮一峰</a></p>
<p>CommonJS 为模块的使用定义了一套 API。比如，它定义了全局函数 require，通过传入模块标识来引入其他模块，如果被引入的模块又依赖了其他模块，那么会依次加载这些模块；通过 module.exports 向外部暴露 API，以便其他的模块引入。</p>
<p>由于 CommonJS 是使用<code>同步方式</code>加载模块的，即只有加载完成才能进行接下来的操作，因此当应用于浏览器端时会受到网速的限制。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> $ = <span class="built_in">require</span>(<span class="string">'jquery'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义私有方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span> (<span class="params">...arg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(...arg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义公有方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> el = $(<span class="string">'body'</span>)</span><br><span class="line">  log(<span class="string">'zhouyu, hello'</span>, el)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 暴露公有方法</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  sayHello</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="AMD"><a href="#AMD" class="headerlink" title="AMD"></a>AMD</h2><p>之后，在 CommonJS 组织的讨论中，AMD(Asynchronous Module Definition)应运而生。和 CommonJS 不同的是，它使用<code>异步方式</code>加载模块，因此更适合被浏览器端采用。AMD 用全局函数 define 来定义模块，它需要三个参数：模块名称、模块的依赖数组、所有依赖都可用之后执行的回调函数(该函数按照依赖声明的顺序，接收依赖作为参数)。</p>
<p><a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="noopener">AMD</a><br><a href="https://github.com/amdjs/amdjs-api/wiki/AMD-(%E4%B8%AD%E6%96%87%E7%89%88" target="_blank" rel="noopener">AMD中文</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">define([<span class="string">'jquery'</span>], <span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义私有方法</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">log</span> (<span class="params">...arg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(...arg)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义公有方法</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sayHello</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> el = $(<span class="string">'body'</span>)</span><br><span class="line">    log(<span class="string">'zhouyu, hello'</span>, el)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 暴露公有方法</span></span><br><span class="line">  <span class="keyword">return</span> sayHello</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h2 id="UMD"><a href="#UMD" class="headerlink" title="UMD"></a>UMD</h2><p>如果需要同时支持 CommonJS 和 AMD 两种格式，那么可以使用 UMD(Universal Module Definition)。事实上，UMD 通过一系列 if/else 判断来确定当前环境支持的模块体系，因此多数情况下 UMD 格式的模块会占用更大的体积。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params">root, factory</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> define === <span class="string">'function'</span> &amp;&amp; define.amd) &#123;</span><br><span class="line">    <span class="comment">// AMD</span></span><br><span class="line">    define([<span class="string">'jquery'</span>], factory)</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> exports === <span class="string">'object'</span>) &#123;</span><br><span class="line">    <span class="comment">// Nodejs 或 CommonJS</span></span><br><span class="line">    <span class="built_in">module</span>.exports = factory(<span class="built_in">require</span>(<span class="string">'jquery'</span>))</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 浏览器全局变量(root 即 window)</span></span><br><span class="line">    root.returnExports = factory(root.jQuery)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span> (<span class="params">$</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 定义私有方法</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">log</span> (<span class="params">...arg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(...arg)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义公有方法</span></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sayHello</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> el = $(<span class="string">'body'</span>)</span><br><span class="line">    log(<span class="string">'zhouyu, hello'</span>, el)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 暴露公有方法</span></span><br><span class="line">  <span class="keyword">return</span> sayHello</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<h2 id="ES6-Modules"><a href="#ES6-Modules" class="headerlink" title="ES6 Modules"></a>ES6 Modules</h2><p>无论是 CommonJS，AMD 还是 UMD，它们都不是标准的 JavaScript 模块解决方案。换句话说，它们都没有被写进 ECMA 的规范中。直到 2015 年 6 月，TC39 委员会终于将 Modules 写进 ECMAScript 2015 中，标志着原生模块新时代的到来。至此，JavaScript 文件有了两种形式：脚本(自 JavaScript 诞生起我们就在使用的)和模块(即 ECMAScript 2015 Modules)。下面就让我们来一起探索 ECMAScript 2015 Modules(以下简称 ES6 Modules)</p>
<p><a href="http://www.ecma-international.org/ecma-262/6.0/#sec-modules" target="_blank" rel="noopener">ES6 Modules</a><br><a href="http://es6.ruanyifeng.com/#docs/module" target="_blank" rel="noopener">ES6阮一峰</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span>(<span class="string">'jquery'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义私有方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span> (<span class="params">...arg</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(...arg)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 定义公有方法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> el = $(<span class="string">'body'</span>)</span><br><span class="line">  log(<span class="string">'zhouyu, hello'</span>, el)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> sayHello</span><br></pre></td></tr></table></figure>

<h2 id="ES6-Modules-现状"><a href="#ES6-Modules-现状" class="headerlink" title="ES6 Modules 现状"></a>ES6 Modules 现状</h2><p>时至今日，几大主流浏览器都在积极推进支持原生 ES6 Modules 的工作，部分浏览器的技术预览版也已经初步完成了这一使命。可以通过 <a href="https://caniuse.com/#search=module" target="_blank" rel="noopener">caniuse</a> 查看目前浏览器的支持情况。</p>
<h2 id="使用-Babel-和-webpack"><a href="#使用-Babel-和-webpack" class="headerlink" title="使用 Babel 和 webpack"></a>使用 Babel 和 webpack</h2><p>由于绝大多数浏览器都不支持 ES6 Modules，所以目前如果想使用它的语法，需要借助 Babel 和 webpack，即通过 Babel 将代码编译为 ES5 的语法，然后使用 webpack 打包成目标格式。</p>
<h2 id="直接使用-ES6-Modules"><a href="#直接使用-ES6-Modules" class="headerlink" title="直接使用 ES6 Modules"></a>直接使用 ES6 Modules</h2><p>有些游览器已经支持 ES6 Modules，我们利用 <code>&lt;script type=&quot;module&quot;&gt;</code>(默认是 defer)来使用。</p>
<h2 id="其他探索"><a href="#其他探索" class="headerlink" title="其他探索"></a>其他探索</h2><ul>
<li>动态加载方案 <code>import()</code></li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> load = <span class="keyword">async</span> (url) =&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">module</span> = <span class="keyword">await</span> <span class="keyword">import</span>(url)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">module</span>, <span class="built_in">window</span>[tempGlobal])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">load</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>)</span><br><span class="line">    <span class="keyword">const</span> tempGlobal = <span class="string">'__tempModuleLoadingVariable'</span> + <span class="built_in">Math</span>.random().toString(<span class="number">32</span>).substring(<span class="number">2</span>)</span><br><span class="line">    script.type = <span class="string">'module'</span></span><br><span class="line">    script.textContent = <span class="string">`import * as m from "<span class="subst">$&#123;url&#125;</span>"; window.<span class="subst">$&#123;tempGlobal&#125;</span> = m;`</span></span><br><span class="line"></span><br><span class="line">    script.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="built_in">window</span>[tempGlobal])</span><br><span class="line">      <span class="keyword">delete</span> <span class="built_in">window</span>[tempGlobal]</span><br><span class="line">      script.remove()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    script.onerror = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Failed to load module script with URL '</span> + url))</span><br><span class="line">      <span class="keyword">delete</span> <span class="built_in">window</span>[tempGlobal]</span><br><span class="line">      script.remove()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">document</span>.documentElement.appendChild(script)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>基于 ES6 Modules 的 <code>module-pusher</code> 尝试</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/32554482" target="_blank" rel="noopener">查看原文</a></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript深浅复制(拷贝)</title>
    <url>/zh/2018/08/14/JavaScript%E6%B7%B1%E6%B5%85%E5%A4%8D%E5%88%B6(%E6%8B%B7%E8%B4%9D)/</url>
    <content><![CDATA[<p>拷贝，copy，复制，抄本、副本、别本。</p>
<p>拷贝就是拷贝指向对象的指针，意思就是说，拷贝出来的目标对象的指针和源对象的指针指向的内存空间是同一块空间！</p>
<p>拷贝分浅拷贝和深拷贝。</p>
<a id="more"></a>

<h1 id="深浅拷贝"><a href="#深浅拷贝" class="headerlink" title="深浅拷贝"></a>深浅拷贝</h1><p>要了解深浅拷贝，需要先去回顾 JavaScript 数据类型。</p>
<p>JavaScript 的数据类型分为基本数据类型和引用数据类型。</p>
<p>基本数据类型是按值传递，其拷贝没有深浅拷贝的区别。b 是 a 的拷贝，在修改 b 时并不会改到 a。</p>
<p>引用数据类型是按引用传递，其拷贝才有深浅拷贝的区别。</p>
<p>深浅拷贝是针对对象而言的。</p>
<h1 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h1><p>shallow copy</p>
<p>按位拷贝对象，它会创建一个新对象，这个对象有着源对象属性值的一份精确拷贝。</p>
<p>如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址(引用类型)，拷贝的就是内存地址。</p>
<p>因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源，只复制引用而不复制真正的值。</p>
<p>浅拷贝的意思就是只复制引用，而未复制真正的值。</p>
<h2 id="赋值操作符-就是浅拷贝"><a href="#赋值操作符-就是浅拷贝" class="headerlink" title="赋值操作符 = 就是浅拷贝"></a>赋值操作符 = 就是浅拷贝</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="string">'hello'</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    a: <span class="string">'world'</span>,</span><br><span class="line">    b: <span class="number">21</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  c: [<span class="string">'Bob'</span>, <span class="string">'Tom'</span>, <span class="string">'Jenny'</span>],</span><br><span class="line">  d: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   alert(<span class="string">'hello world'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cloneObj = obj</span><br><span class="line"></span><br><span class="line">cloneObj.a = <span class="string">'world'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cloneObj.a, obj.a) <span class="comment">// world, world</span></span><br></pre></td></tr></table></figure>

<h2 id="简单的复制函数"><a href="#简单的复制函数" class="headerlink" title="简单的复制函数"></a>简单的复制函数</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="string">'hello'</span>,</span><br><span class="line">  b: &#123;</span><br><span class="line">    a: <span class="string">'world'</span>,</span><br><span class="line">    b: <span class="number">21</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  c: [<span class="string">'Bob'</span>, <span class="string">'Tom'</span>, <span class="string">'Jenny'</span>],</span><br><span class="line">  d: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">   alert(<span class="string">'hello world'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">simpleClone</span> (<span class="params">initalObj</span>) </span>&#123;    </span><br><span class="line">  <span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> ( <span class="keyword">var</span> i <span class="keyword">in</span> initalObj) &#123;</span><br><span class="line">    obj[i] = initalObj[i]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cloneObj = simpleClone(obj)</span><br><span class="line"></span><br><span class="line">cloneObj.a = <span class="string">'world'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cloneObj.a, obj.a) <span class="comment">// world, hello</span></span><br><span class="line"></span><br><span class="line">cloneObj.b.a = <span class="string">'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cloneObj.b.a, obj.b.a) <span class="comment">// hello, hello</span></span><br><span class="line"></span><br><span class="line">cloneObj.b = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cloneObj.b.a, obj.b.a) <span class="comment">// undefined, hello</span></span><br><span class="line"></span><br><span class="line">cloneObj.c[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cloneObj.c[<span class="number">0</span>], obj.c[<span class="number">0</span>]) <span class="comment">// 0, 0</span></span><br><span class="line"></span><br><span class="line">cloneObj.c = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cloneObj.c[<span class="number">0</span>], obj.c[<span class="number">0</span>]) <span class="comment">// 1. 0</span></span><br></pre></td></tr></table></figure>

<p><code>obj[i] = initalObj[i]</code> 这里对对象的第一层进行了深拷贝，而第二层开始的目标我们是直接利用 = 赋值操作符进行拷贝的，只是复制了一个引用，也就是浅拷贝。</p>
<p>直接修改克隆对象第一层属性的值，不会对原对象产生影响。但如果修改第二层属性，即第一层属性的值是个对象，并改变其值(该对象上某个属性)，就会对原对象产生影响。</p>
<p>对目标对象的第一层进行深拷贝，然后后面的是浅拷贝，可以称作“首层浅拷贝”。</p>
<p>赋值运算符 = 实现的是浅拷贝，只拷贝对象的引用值。</p>
<p>js 中数组和对象自带的拷贝方法都是“首层浅拷贝”。</p>
<h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cloneArray = array.concat() <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">cloneArray[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cloneArray, array) <span class="comment">// [0, 2, 3], [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<p>看上去好像不是浅拷贝，其实 <code>concat</code> 也是对数组的第一层进行了深拷贝。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [&#123; <span class="attr">x</span>: <span class="number">1</span> &#125;, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cloneArray = array.concat() <span class="comment">// [&#123; x: 1&#125;, 2, 3]</span></span><br><span class="line"></span><br><span class="line">cloneArray[<span class="number">0</span>].x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cloneArray[<span class="number">0</span>].x, array[<span class="number">0</span>].x) <span class="comment">// 0, 0</span></span><br></pre></td></tr></table></figure>

<h2 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h2><p><code>slice</code> 也是对数组的第一层进行了深拷贝。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [&#123; <span class="attr">x</span>: <span class="number">1</span> &#125;, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cloneArray = array.slice() <span class="comment">// [&#123; x: 1&#125;, 2, 3]</span></span><br><span class="line"></span><br><span class="line">cloneArray[<span class="number">0</span>].x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cloneArray[<span class="number">0</span>].x, array[<span class="number">0</span>].x) <span class="comment">// 0, 0</span></span><br></pre></td></tr></table></figure>

<h2 id="forEach"><a href="#forEach" class="headerlink" title="forEach"></a>forEach</h2><p><code>forEach</code> 也是对数组的第一层进行了深拷贝。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [&#123; <span class="attr">x</span>: <span class="number">1</span> &#125;, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cloneArray = []</span><br><span class="line"></span><br><span class="line">array.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">  cloneArray[index] = item</span><br><span class="line">&#125;) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">cloneArray[<span class="number">0</span>].x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cloneArray[<span class="number">0</span>].x, array[<span class="number">0</span>].x) <span class="comment">// 0, 0</span></span><br></pre></td></tr></table></figure>

<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><p><code>map</code> 也是对数组的第一层进行了深拷贝。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [&#123; <span class="attr">x</span>: <span class="number">1</span> &#125;, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cloneArray = array.map(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> item</span><br><span class="line">&#125;) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">cloneArray[<span class="number">0</span>].x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cloneArray[<span class="number">0</span>].x, array[<span class="number">0</span>].x) <span class="comment">// 0, 0</span></span><br></pre></td></tr></table></figure>

<h2 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h2><p><code>扩展运算符 ...</code> 也是对数组/对象的第一层进行了深拷贝。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [&#123; <span class="attr">x</span>: <span class="number">1</span> &#125;, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cloneArray = [...array] <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">cloneArray[<span class="number">0</span>].x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cloneArray[<span class="number">0</span>].x, array[<span class="number">0</span>].x) <span class="comment">// 0, 0</span></span><br></pre></td></tr></table></figure>

<h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><p><code>Object.assign()</code> 也是对数组/对象的第一层进行了深拷贝。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [&#123; <span class="attr">x</span>: <span class="number">1</span> &#125;, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cloneArray = <span class="built_in">Object</span>.assign([], array) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">cloneArray[<span class="number">0</span>].x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cloneArray[<span class="number">0</span>].x, array[<span class="number">0</span>].x) <span class="comment">// 0, 0</span></span><br></pre></td></tr></table></figure>

<h1 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h1><p>deep copy</p>
<p>一个引用对象一般来说由两个部分组成：一个具名的 Handle，也就是我们所说的声明（如变量）和一个内部（不具名）的对象，也就是具名 Handle 的内部对象。它在 Manged Heap（托管堆）中分配，一般由新增引用对象的 new 方法是进行创建。深拷贝是指源对象与拷贝对象互相独立，其中任何一个对象的改动都不会对另外一个对象造成影响。</p>
<p>源对象与拷贝对象互相独立。</p>
<p>深拷贝就是对目标的完全拷贝，不像浅拷贝那样只是复制了一层引用，就连值也都复制了。</p>
<p>只要进行了深拷贝，它们老死不相往来，谁也不会影响谁。</p>
<p>一般情况下，只需使用系统提供的浅拷贝构造函数即可，但是，如果对象的数据成员包括指向堆空间的指针，就不能使用这种拷贝方式，因为两个对象都拥有同一个资源，对象析构时，该资源将经历两次资源返还，此时必须自定义深拷贝构造函数，为创建的对象分配堆空间，否则会出现动态分配的指针变量悬空的情况。</p>
<p>深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。</p>
<p>实现深拷贝的方法：</p>
<h2 id="利用-JSON-parse-和-JSON-stringify"><a href="#利用-JSON-parse-和-JSON-stringify" class="headerlink" title="利用 JSON.parse 和 JSON.stringify"></a>利用 JSON.parse 和 JSON.stringify</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">regExp</span>: <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'1'</span>), <span class="attr">func</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;, &#125;, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cloneArray = <span class="built_in">JSON</span>.parse(<span class="built_in">JSON</span>.stringify(array))</span><br><span class="line"></span><br><span class="line">cloneArray[<span class="number">0</span>].x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cloneArray[<span class="number">0</span>].x, array[<span class="number">0</span>].x) <span class="comment">// 0, 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cloneArray[<span class="number">0</span>].regExp, cloneArray[<span class="number">0</span>].func) <span class="comment">// undefined, undefined</span></span><br></pre></td></tr></table></figure>

<p>缺点：只能适用于一些简单的情况，能正确处理的对象只有 Number, String, Boolean, Array, 扁平对象，即那些能够被 json 直接表示的数据结构。RegExp 对象、Function 对象等没办法转成 JSON，所以不能被处理，会被忽略，导致丢失。</p>
<h2 id="利用递归来实现每一层都重新创建对象并赋值"><a href="#利用递归来实现每一层都重新创建对象并赋值" class="headerlink" title="利用递归来实现每一层都重新创建对象并赋值"></a>利用递归来实现每一层都重新创建对象并赋值</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [&#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">regExp</span>: <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'1'</span>), <span class="attr">func</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;, &#125;, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">deepClone</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="regexp">/(Array|Object)]/gi</span>.test(<span class="built_in">Object</span>.prototype.toString.call(obj))) &#123;</span><br><span class="line">    <span class="keyword">var</span> cloneObj = obj <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">      <span class="keyword">if</span> (obj.hasOwnProperty(key)) &#123;</span><br><span class="line">        <span class="keyword">var</span> prop = obj[key]</span><br><span class="line">        <span class="keyword">if</span> (<span class="regexp">/(Array|Object)]/gi</span>.test(<span class="built_in">Object</span>.prototype.toString.call(prop))) &#123;</span><br><span class="line">          cloneObj[key] = prop <span class="keyword">instanceof</span> <span class="built_in">Array</span> ? [] : &#123;&#125;  </span><br><span class="line">          cloneObj[key] = deepClone(prop)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          cloneObj[key] = prop</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cloneObj</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> obj</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cloneArray = deepClone(array)</span><br><span class="line"></span><br><span class="line">cloneArray[<span class="number">0</span>].x = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cloneArray[<span class="number">0</span>].x, array[<span class="number">0</span>].x) <span class="comment">// 0, 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(cloneArray[<span class="number">0</span>].regExp, cloneArray[<span class="number">0</span>].func) <span class="comment">// /1/, ƒ () &#123;&#125;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript的new运算符</title>
    <url>/zh/2018/09/05/JavaScript%E7%9A%84new%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    <content><![CDATA[<p>new 运算符，用来创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。也就是说，是根据一个对象，去创建它的实例。</p>
<a id="more"></a>

<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">new</span> Constructor[([<span class="built_in">arguments</span>])]</span><br></pre></td></tr></table></figure>

<h1 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h1><p><code>Constructor</code> 一个指定对象实例的类型的类或函数。</p>
<p><code>arguments</code> 一个用来被 Constructor 调用的参数列表。</p>
<h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><ul>
<li>新生成了一个对象</li>
<li>链接到原型</li>
<li>绑定 this</li>
<li>返回新对象</li>
</ul>
<p>在调用 <code>new</code> 的过程中会发生以上四件事情，我们也可以试着来自己实现一个 <code>new</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span> (<span class="params">make, model, year</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.make = make</span><br><span class="line">  <span class="keyword">this</span>.model = model</span><br><span class="line">  <span class="keyword">this</span>.year = year</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car1 = <span class="keyword">new</span> Car()</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car2 = <span class="keyword">new</span> Car(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span> (<span class="params">make, model, year</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.make = make</span><br><span class="line">  <span class="keyword">this</span>.model = model</span><br><span class="line">  <span class="keyword">this</span>.year = year</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car1 = &#123;&#125;</span><br><span class="line">car1.__proto__ = Car.prototype</span><br><span class="line">Car.call(car1)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car2 = &#123;&#125;</span><br><span class="line">car2.__proto__ = Car.prototype</span><br><span class="line">Car.call(car2, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span> (<span class="params">make, model, year</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.make = make</span><br><span class="line">  <span class="keyword">this</span>.model = model</span><br><span class="line">  <span class="keyword">this</span>.year = year</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个空的对象</span></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获得构造函数</span></span><br><span class="line">  <span class="keyword">const</span> Con = [].shift.call(<span class="built_in">arguments</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Con: '</span>, Con)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 链接到原型</span></span><br><span class="line">  obj.__proto__ = Con.prototype</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定 this，执行构造函数</span></span><br><span class="line">  <span class="keyword">const</span> result = Con.apply(obj, <span class="built_in">arguments</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'result: '</span>, result)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确保 new 出来的是个对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">'object'</span> ? result : obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car1 = create(Car)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car2 = create(Car, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p>现在，我们在 <code>Car</code> 中返回 <code>{}</code> 或者 <code>null</code>：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span> (<span class="params">make, model, year</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.make = make</span><br><span class="line">  <span class="keyword">this</span>.model = model</span><br><span class="line">  <span class="keyword">this</span>.year = year</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123;&#125;</span><br><span class="line">  <span class="comment">// return null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 创建一个空的对象</span></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获得构造函数</span></span><br><span class="line">  <span class="keyword">const</span> Con = [].shift.call(<span class="built_in">arguments</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(Con)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 链接到原型</span></span><br><span class="line">  obj.__proto__ = Con.prototype</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 绑定 this，执行构造函数</span></span><br><span class="line">  <span class="keyword">const</span> result = Con.apply(obj, <span class="built_in">arguments</span>)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(result)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 确保 new 出来的是个对象</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> result === <span class="string">'object'</span> ? result : obj</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car1 = create(Car)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> car2 = create(Car, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>

<p><code>确保 new 出来的是个对象</code> 也就是说，在 <code>new</code> 的构造函数的返回值是对象时就返回该返回值，不是对象则返回创建的对象</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript继承机制</title>
    <url>/zh/2018/08/14/JavaScript%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>待补充</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac软件推荐</title>
    <url>/zh/2018/08/08/Mac%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90/</url>
    <content><![CDATA[<p>推荐一些常用的 Mac 软件</p>
<a id="more"></a>

<h1 id="破解版"><a href="#破解版" class="headerlink" title="破解版"></a>破解版</h1><p><a href="https://www.waitsun.com/?s={query}" target="_blank" rel="noopener">https://www.waitsun.com/?s={query}</a></p>
<h2 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a>Alfred</h2><h2 id="Axure"><a href="#Axure" class="headerlink" title="Axure"></a>Axure</h2><p>百度网盘已存</p>
<h2 id="Charles"><a href="#Charles" class="headerlink" title="Charles"></a>Charles</h2><h2 id="Dr-Cleaner"><a href="#Dr-Cleaner" class="headerlink" title="Dr.Cleaner"></a>Dr.Cleaner</h2><h3 id="手动清理"><a href="#手动清理" class="headerlink" title="手动清理"></a>手动清理</h3><p>打开 Finder 界面，”shift + command + G”</p>
<p>/Library/Caches<br>~/Library/Caches<br>~/Library/Application Support/MobileSync/Backup/</p>
<h2 id="OmniGraffle"><a href="#OmniGraffle" class="headerlink" title="OmniGraffle"></a>OmniGraffle</h2><p>百度网盘已存</p>
<h2 id="PDFExp"><a href="#PDFExp" class="headerlink" title="PDFExp"></a>PDFExp</h2><p>百度网盘已存</p>
<h2 id="Photoshop"><a href="#Photoshop" class="headerlink" title="Photoshop"></a>Photoshop</h2><p>百度网盘已存</p>
<h2 id="Sketch"><a href="#Sketch" class="headerlink" title="Sketch"></a>Sketch</h2><p>百度网盘已存</p>
]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 3.0 PK React 17</title>
    <url>/zh/2021/03/11/Virtual%20DOM/</url>
    <content><![CDATA[<p>Virtual Dom</p>
<a id="more"></a>

<p><a href="https://yuchengkai.cn/docs/frontend/framework.html#virtual-dom" target="_blank" rel="noopener">virtual-dom</a></p>
<p><a href="https://www.zhihu.com/question/31809713/answer/53544875" target="_blank" rel="noopener">网上都说操作真实 DOM 慢，但测试结果却比 React 更快，为什么？ - 尤雨溪的回答 - 知乎</a></p>
<ol>
<li>原生 DOM 操作 vs. 通过框架封装操作。</li>
</ol>
<p>这是一个性能 vs. 可维护性的取舍。框架的意义在于为你掩盖底层的 DOM 操作，让你用更声明式的方式来描述你的目的，从而让你的代码更容易维护。没有任何框架可以比纯手动的优化 DOM 操作更快，因为框架的 DOM 操作层需要应对任何上层 API 可能产生的操作，它的实现必须是普适的。针对任何一个 benchmark（基准测试/单元测试），我都可以写出比任何框架更快的手动优化，但是那有什么意义呢？在构建一个实际应用的时候，你难道为每一个地方都去做手动优化吗？出于可维护性的考虑，这显然不可能。框架给你的保证是，你在不需要手动优化的情况下，我依然可以给你提供过得去的性能。</p>
<ol start="2">
<li>对 React 的 Virtual DOM 的误解。</li>
</ol>
<p>React 从来没有说过 “React 比原生操作 DOM 快”。。React 的基本思维模式是每次有变动就整个重新渲染整个应用。如果没有 Virtual DOM，简单来想就是直接重置 innerHTML。很多人都没有意识到，在一个大型列表所有数据都变了的情况下，重置 innerHTML 其实是一个还算合理的操作… 真正的问题是在 “全部重新渲染” 的思维模式下，即使只有一行数据变了，它也需要重置整个 innerHTML，这时候显然就有大量的浪费。</p>
<p>我们可以比较一下 innerHTML vs. Virtual DOM 的重绘性能消耗：</p>
<ul>
<li>innerHTML: render html string O(template size) + 重新创建所有 DOM 元素 O(DOM size)</li>
<li>Virtual DOM: render Virtual DOM + diff O(template size) + 必要的 DOM 更新 O(DOM change)</li>
</ul>
<p>Virtual DOM render + diff 显然比渲染 html 字符串要慢。但是！它依然是纯 js 层面的计算，比起后面的 DOM 操作来说，依然便宜了太多。可以看到，innerHTML 的总计算量不管是 js 计算还是 DOM 操作都是和整个界面的大小相关，但 Virtual DOM 的计算量里面，只有 js 计算和界面大小相关，DOM 操作是和数据的变动量相关的。面说了，和 DOM 操作比起来，js 计算是极其便宜的。这才是为什么要有 Virtual DOM：它保证了 1）不管你的数据变化多少，每次重绘的性能都可以接受；2) 你依然可以用类似 innerHTML 的思路去写你的应用。</p>
<p>所以 Virtual DOM 到底是「数据多时」有优势还是「数据少时」有优势？</p>
<p>所以 Virtual DOM 到底是「数据变化多时」有优势还是「数据变化少时」有优势？</p>
<p>初次渲染：数据多时， Virtual DOM 牛逼</p>
<p>数据更新：数据变化少时， Virtual DOM 牛逼</p>
<ol start="3">
<li>MVVM vs. Virtual DOM</li>
</ol>
<p>相比起 React，其他 MVVM 系框架比如 Angular, Knockout 以及 Vue、Avalon 采用的都是数据绑定：通过 Directive/Binding 对象，观察数据变化并保留对实际 DOM 元素的引用，当有数据变化时进行对应的操作。MVVM 的变化检查是数据层面的，而 React 的检查是 DOM 结构层面的。MVVM 的性能也根据变动检测的实现原理有所不同：Angular 的脏检查使得任何变动都有固定的 O(watcher count) 的代价；Knockout/Vue/Avalon 都采用了依赖收集，在 js 和 DOM 层面都是 O(change)：</p>
<ul>
<li>脏检查：scope digest O(watcher count) + 必要 DOM 更新 O(DOM change)</li>
<li>依赖收集：重新收集依赖 O(data change) + 必要 DOM 更新 O(DOM change)</li>
</ul>
<p>可以看到，Angular 最不效率的地方在于任何小变动都有的和 watcher 数量相关的性能代价。但是！当所有数据都变了的时候，Angular 其实并不吃亏。依赖收集在初始化和数据变化的时候都需要重新收集依赖，这个代价在小量更新的时候几乎可以忽略，但在数据量庞大的时候也会产生一定的消耗。</p>
<p>… 见原答案</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue 3.0 PK React 17</title>
    <url>/zh/2021/03/10/Vue%203.0%20PK%20React%2017/</url>
    <content><![CDATA[<p>Vue 3.0 PK React 17</p>
<a id="more"></a>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue vs. React</title>
    <url>/zh/2021/03/10/Vue%20vs.%20React/</url>
    <content><![CDATA[<p>Vue vs. React</p>
<a id="more"></a>

<p><a href="https://cn.vuejs.org/v2/guide/comparison.html" target="_blank" rel="noopener">comparison</a></p>
<h1 id="Vue-vs-React"><a href="#Vue-vs-React" class="headerlink" title="Vue vs. React"></a>Vue vs. React</h1><p>相同：</p>
<ul>
<li>使用 Virtual DOM。</li>
<li>提供了响应式 (Reactive) 和组件化 (Composable) 的视图组件。</li>
<li>将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库。</li>
</ul>
<p>React 比 Vue 有更丰富的生态系统。</p>
<h2 id="运行时性能"><a href="#运行时性能" class="headerlink" title="运行时性能"></a>运行时性能</h2><p><a href="https://www.zhihu.com/question/301860721/answer/545031906" target="_blank" rel="noopener">Vue 和 React 的优点分别是什么？ - 尤雨溪的回答 - 知乎</a></p>
<p>论历史地位，React 肯定是高于 Vue 的。</p>
<p>React 从开发模式层面上提出突破性的新方向。</p>
<p>React 从一开始的定位就是提出 UI 开发的新思路。</p>
<p>Vue 里面也有很多地方是直接受到了 React 的启发。</p>
<p>Vue 从一开始的定位就是尽可能的降低前端开发的门槛，让更多的人能够更快地上手开发。</p>
<p>Vue 帮到那些中小型企业和个人开发者。多快好省。</p>
<p>做 React 这样的不迎合用户，而是试图改变用户的设计需要有足够的本钱：你得有足够的资源和背景去强行越过初始推广的那个陡坡。</p>
<p>大家都是图灵完备，然而此之蜜糖，彼之砒霜。</p>
<p><a href="https://baike.baidu.com/item/图灵完备" target="_blank" rel="noopener">图灵完备</a></p>
<p><a href="https://2020.stateofjs.com/zh-Hans/technologies/front-end-frameworks/" target="_blank" rel="noopener">stateofjs</a></p>
<p>…</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>WeGeek 微信小程序敏捷开发实战</title>
    <url>/zh/2019/11/04/WeGeek%20%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%95%8F%E6%8D%B7%E5%BC%80%E5%8F%91%E5%AE%9E%E6%88%98/</url>
    <content><![CDATA[<p>WeGeek 微信小程序敏捷开发实战</p>
<a id="more"></a>

<h1 id="腾讯云小程序解决方案-朱展"><a href="#腾讯云小程序解决方案-朱展" class="headerlink" title="腾讯云小程序解决方案 - 朱展"></a>腾讯云小程序解决方案 - 朱展</h1><h2 id="小程序架构分析"><a href="#小程序架构分析" class="headerlink" title="小程序架构分析"></a>小程序架构分析</h2><p>移动应用开发的三种模式</p>
<ul>
<li>Web App(H5)</li>
<li>原生应用</li>
<li>小程序/快应用（Hybrid）</li>
</ul>
<p>小程序原理</p>
<ul>
<li>WebView 视图层（线程1）(WXML + WXSS + WXS + Component)</li>
<li>AppService 逻辑层（线程2）</li>
<li>WeixinJSBridge</li>
<li>Native 组件、Native 能力</li>
</ul>
<p>双线程模型、WebView预加载</p>
<h2 id="小程序解决方案进化历程"><a href="#小程序解决方案进化历程" class="headerlink" title="小程序解决方案进化历程"></a>小程序解决方案进化历程</h2><h2 id="腾讯云小程序解决方案介绍"><a href="#腾讯云小程序解决方案介绍" class="headerlink" title="腾讯云小程序解决方案介绍"></a>腾讯云小程序解决方案介绍</h2><h1 id="小程序在直播产品中的技术应用-杨春文"><a href="#小程序在直播产品中的技术应用-杨春文" class="headerlink" title="小程序在直播产品中的技术应用 - 杨春文"></a>小程序在直播产品中的技术应用 - 杨春文</h1><p>NOW直播</p>
<h2 id="构建直播小程序（基于腾讯云）"><a href="#构建直播小程序（基于腾讯云）" class="headerlink" title="构建直播小程序（基于腾讯云）"></a>构建直播小程序（基于腾讯云）</h2><p><live-pusher> 主播端</live-pusher></p>
<p><live-player> 观众端</live-player></p>
<video>

<image>

<ul>
<li>申请腾讯云直播服务</li>
<li>获取加密私钥</li>
<li>部署自己的业务后台（提供现成代码）</li>
<li>生成主播端地址（上行）</li>
<li>生成观众端地址（下行）</li>
<li>开启小程序</li>
</ul>
<h2 id="布局之痛"><a href="#布局之痛" class="headerlink" title="布局之痛"></a>布局之痛</h2><p>弹幕</p>
<ul>
<li>video 等 native 组件无法和 WebView 元素重叠</li>
<li>视频与直播间元素的混排实现，但是无法把弹幕滚动且防止视频上</li>
<li>cover-view 组件与普通组件差异太大</li>
<li>canvas 实现：视频上的点赞动画</li>
</ul>
<h2 id="谈谈setData优化"><a href="#谈谈setData优化" class="headerlink" title="谈谈setData优化"></a>谈谈setData优化</h2><ul>
<li>避免频繁 setData，一次返回多条消息，滚动展示，避免一条条 setData</li>
<li>onHide 时停止数据更新</li>
</ul>
<h2 id="大图片之殇"><a href="#大图片之殇" class="headerlink" title="大图片之殇"></a>大图片之殇</h2><p>大图片造成页面切换延迟、卡顿，内存占用过多被销毁</p>
<p>按需加载、懒加载</p>
<h2 id="预加载"><a href="#预加载" class="headerlink" title="预加载"></a>预加载</h2><p>页面切换</p>
<p>A -&gt; B -&gt; fetch -&gt; data -&gt; render</p>
<p>A 到 B 之前的切换是很耗时的，可不可以在这段时间做些事情？</p>
<p>A -&gt; B 时 fetch -&gt; data -&gt; local data</p>
<p>B -&gt; get data -&gt; render</p>
<p>把串行改成并行</p>
<h1 id="如何开发一款小游戏-邹伟"><a href="#如何开发一款小游戏-邹伟" class="headerlink" title="如何开发一款小游戏 - 邹伟"></a>如何开发一款小游戏 - 邹伟</h1><h1 id="有赞商城小程序-施德来"><a href="#有赞商城小程序-施德来" class="headerlink" title="有赞商城小程序 - 施德来"></a>有赞商城小程序 - 施德来</h1><p>H5 与 native 的痛点</p>
<p>PWA - Google，让 Web 可以离线缓存、消息推送</p>
<p>Hybrid App - PhoneGap、Ionic (WebView - JS Bridge -&gt; Native Runtime)</p>
<p>JS Native App - React Native、Weex (JS Runtime -&gt; JS Bridge -&gt; Native Runtime)</p>
<p>JS Native App - 小程序（微信操作系统）</p>
<p>很多 H5 需要高阶能力才能解决的问题，被小程序降维解决了</p>
<h2 id="如何同时产出海量独立的微商城小程序"><a href="#如何同时产出海量独立的微商城小程序" class="headerlink" title="如何同时产出海量独立的微商城小程序"></a>如何同时产出海量独立的微商城小程序</h2><p>模版ID + ext.json</p>
<h2 id="一套代码两个马甲"><a href="#一套代码两个马甲" class="headerlink" title="一套代码两个马甲"></a>一套代码两个马甲</h2><p>webpack + 2个 app.json (公共、专享) -&gt; merge -&gt; 1个app.json</p>
<h2 id="富文本"><a href="#富文本" class="headerlink" title="富文本"></a>富文本</h2><p>wxParse</p>
<p>rich-text</p>
<h2 id="体积越来越大"><a href="#体积越来越大" class="headerlink" title="体积越来越大"></a>体积越来越大</h2><p>wxapp-webpack-plugin （代码精简）</p>
<p>分包加载</p>
<h2 id="如何提高开发效率"><a href="#如何提高开发效率" class="headerlink" title="如何提高开发效率"></a>如何提高开发效率</h2><p>zan-ui</p>
<p>zan-proxy</p>
<p>体验版、稳定版机制</p>
<p>体验版内测商家群</p>
<h1 id="从小程序到小程序云开发-Heyli"><a href="#从小程序到小程序云开发-Heyli" class="headerlink" title="从小程序到小程序云开发 - Heyli"></a>从小程序到小程序云开发 - Heyli</h1><p>云开发：云函数、云数据库、云存储</p>
<p>云开发模式</p>
<h2 id="腾讯相册小程序分享二维码优化"><a href="#腾讯相册小程序分享二维码优化" class="headerlink" title="腾讯相册小程序分享二维码优化"></a>腾讯相册小程序分享二维码优化</h2><ul>
<li>小程序码不能存太多信息</li>
<li>二维码中包含了 name, ownerid, page 等大量信息，在某些机型上无法有效识别</li>
</ul>
<p>iPhone 6, iPhone 6P 等机型由于内存限制，识别能力比其他机型略差，有些比较模糊的图，可能会有识别问题，正在努力优化中</p>
<p>云开发解决方案：</p>
<p>小程序码只需记下一个ID，具体信息存储在小程序云的数据库中，大大提升识别度</p>
<h2 id="在云函数中使用-request-调用接口，不用配置域名"><a href="#在云函数中使用-request-调用接口，不用配置域名" class="headerlink" title="在云函数中使用 request 调用接口，不用配置域名"></a>在云函数中使用 request 调用接口，不用配置域名</h2><h1 id="从0到1快速开发电商小程序-钟鑫-京东高级前端工程师"><a href="#从0到1快速开发电商小程序-钟鑫-京东高级前端工程师" class="headerlink" title="从0到1快速开发电商小程序 - 钟鑫 - 京东高级前端工程师"></a>从0到1快速开发电商小程序 - 钟鑫 - 京东高级前端工程师</h1><p>Taro 框架多端组件及 API 相关，还有京东购物小程序首页和搜索</p>
<ul>
<li>index</li>
<li>user</li>
<li>shop</li>
<li>cart</li>
<li>order</li>
</ul>
<h1 id="结合AI实现智能美颜相册-王伟嘉-腾讯云研发工程师"><a href="#结合AI实现智能美颜相册-王伟嘉-腾讯云研发工程师" class="headerlink" title="结合AI实现智能美颜相册 - 王伟嘉 - 腾讯云研发工程师"></a>结合AI实现智能美颜相册 - 王伟嘉 - 腾讯云研发工程师</h1><p>腾讯云开启「AI识别人脸」</p>
</image></video>]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>职业</tag>
      </tags>
  </entry>
  <entry>
    <title>BFC</title>
    <url>/zh/2018/12/28/css%5BBFC%5D/</url>
    <content><![CDATA[<p>啥叫 BFC 啊？</p>
<a id="more"></a>

<h2 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h2><p>我们先来了解一下文档流，或者定位方案。</p>
<p>文档流其实分为普通流、浮动流和定位流三种。</p>
<h3 id="普通流-normal-flow"><a href="#普通流-normal-flow" class="headerlink" title="普通流 (normal flow)"></a>普通流 (normal flow)</h3><p>在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。</p>
<h3 id="浮动流-float-flow"><a href="#浮动流-float-flow" class="headerlink" title="浮动流 (float flow)"></a>浮动流 (float flow)</h3><p>在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。</p>
<h3 id="绝对定位流-absolute-positioning-flow"><a href="#绝对定位流-absolute-positioning-flow" class="headerlink" title="绝对定位流 (absolute positioning flow)"></a>绝对定位流 (absolute positioning flow)</h3><p>绝对定位是 position: absolute; 或 position: fixed;</p>
<p>position: absolute; 是相对向上查找的 position: relative; 父辈元素。</p>
<p>position: fixed; 是相对 viewpoint。</p>
<p>在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。</p>
<h2 id="BFC-概念"><a href="#BFC-概念" class="headerlink" title="BFC 概念"></a>BFC 概念</h2><p>BFC，块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。</p>
<p>属于上述文档流中的普通流！</p>
<p>具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。</p>
<p>通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。</p>
<h2 id="触发或创建-BFC"><a href="#触发或创建-BFC" class="headerlink" title="触发或创建 BFC"></a>触发或创建 BFC</h2><ul>
<li>根元素或包含根元素的元素</li>
<li>浮动元素（元素的 float 不是 none）</li>
<li>绝对定位元素（元素的 position 为 absolute 或 fixed）</li>
<li>overflow 值不为 visible 的块元素</li>
<li>行内块元素（元素的 display 为 inline-block）</li>
<li>表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值）</li>
<li>表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值）</li>
<li>匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table）</li>
<li>display 值为 flow-root 的元素</li>
<li>contain 值为 layout、content或 strict 的元素</li>
<li>弹性元素（display为 flex 或 inline-flex元素的直接子元素）</li>
<li>网格元素（display为 grid 或 inline-grid 元素的直接子元素）</li>
<li>多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1）</li>
<li>column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。</li>
</ul>
<h2 id="BFC-特性或规则及应用"><a href="#BFC-特性或规则及应用" class="headerlink" title="BFC 特性或规则及应用"></a>BFC 特性或规则及应用</h2><ul>
<li><p>内部的Box会在垂直方向，一个接一个地放置；</p>
<ul>
<li>我们平常说的盒子是由margin、border、padding、content组成的，实际上每种类型的四条边定义了一个盒子，分别是分别是margin box、border box、padding box、content box，这四种类型的盒子一直存在，即使他们的值为0。决定块盒在包含块中与相邻块盒的垂直间距的便是margin-box。</li>
<li>Box之间的距离虽然也可以使用padding来控制，但是此时实际上还是属于box内部里面，而且使用padding来控制的话就不能再使用border属性了。</li>
<li>其实就是我们平常所说的div一行一行块级放置的样式</li>
</ul>
</li>
<li><p>同一个BFC下相邻块级元素的垂直方向外边距会发生折叠，即之前提到的margin折叠只发生在同一个BFC中；</p>
</li>
<li><p>浮动定位和清除浮动时只会应用于同一个BFC内的元素；</p>
</li>
<li><p>浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动；</p>
</li>
<li><p>BFC可以包含浮动元素—清除内部浮动后；</p>
</li>
<li><p>BFC可以阻止元素被浮动元素覆盖，BFC的区域不会与float box重叠；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height: 100px;width: 100px;float: left;background: blue"</span>&gt;</span>我是一个左浮动的元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 200px; height: 200px;background: red"</span>&gt;</span>我是一个没有设置浮动，也没有触发 BFC 元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 overflow: hidden;</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height: 100px;width: 100px;float: left;background: blue"</span>&gt;</span>我是一个左浮动的元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 200px; height: 200px;background: red;overflow: hidden"</span>&gt;</span>我是一个没有设置浮动，也没有触发 BFC 元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>实现两列自适应布局；</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height: 100px;width: 100px;float: left;background: blue"</span>&gt;</span>我是一个左浮动的元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"height: 200px;background: red;overflow: hidden"</span>&gt;</span>我是一个没有设置浮动，也没有触发 BFC 元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度)</p>
</li>
</ul>
<h2 id="BFC-与-Layout"><a href="#BFC-与-Layout" class="headerlink" title="BFC 与 Layout"></a>BFC 与 Layout</h2><p>IE 作为浏览器中的奇葩，当然不可能按部就班的支持 BFC 标准，于是乎 IE 中有了 Layout 这个东西。Layout 和 BFC 基本是等价的，为了处理 IE 的兼容性，在需要触发 BFC 时，我们除了需要用触发条件中的 CSS 属性来触发 BFC，还需要针对 IE 浏览器使用 <code>zoom: 1</code> 来触发 IE 浏览器的 Layout。</p>
<hr>
<p>参考：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Block_formatting_context" target="_blank" rel="noopener">MDN-BFC</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/25321647" target="_blank" rel="noopener">10 分钟理解 BFC 原理</a></li>
</ul>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>WebKit渲染</title>
    <url>/zh/2018/09/07/WebKit%E6%B8%B2%E6%9F%93%E5%9F%BA%E7%A1%80%E4%B9%8BRender%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B/</url>
    <content><![CDATA[<p>WebKit 是一个渲染引擎，而不是一个浏览器，它专注于网页内容展示，其中渲染是其中核心的部分之一。</p>
<a id="more"></a>

<h1 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h1><p>DOM 是对 HTML 或者 XML 等文档的一种结构化表示方法，通过这种方式，用户可以通过提供标准的接口来访问 HTML 页面中的任何元素的相关属性，并可对 DOM 进行相应的添加、删除和更新操作等。更多相关信息可查阅 W3C 的文档。</p>
<p>W3C DOM 标准被分为 3 个不同的部分：</p>
<ul>
<li>核心 DOM - 针对任何结构化文档的标准模型</li>
<li>XML DOM - 针对 XML 文档的标准模型</li>
<li>HTML DOM - 针对 HTML 文档的标准模型</li>
</ul>
<p>HTML DOM 将 HTML 文档表达为树结构，即 DOM 树。</p>
<p><img src="https://cmspic-10004025.image.myqcloud.com/dc473240-b263-11e8-ad16-6fbf6c430894_size_486x266#gif" alt="DOM 树"></p>
<p>基于 DOM 树的一些可视(visual)的节点，WebKit 来根据需要来创建相应的 RenderObject 节点，这些节点也构成了一颗树，称之为 Render 树。基于 Render 树，WebKit 也会根据需要来为它们中的某些节点创建新的 RenderLayer 节点，从而形成一棵 RenderLayer 树。</p>
<p>Render 树和 RenderLayer 树是 WebKit 支持渲染所提供的基础但是却非常重要的设施。这是因为 WebKit 的布局计算依赖它们，浏览器的渲染和 GPU 硬件加速也都依赖于它们。幸运地是，得益于它们接口定义的灵活性，不同的浏览器可以很方便地来实现自己的渲染和加速机制。</p>
<p>为了直观了解这三种树，下图给出了这三种树及其它们之间的对应关系。</p>
<p><img src="https://cmspic-10004025.image.myqcloud.com/5b4def90-b267-11e8-ad16-6fbf6c430894_size_621x299#gif" alt="三种树"></p>
<h2 id="Render-树的建立"><a href="#Render-树的建立" class="headerlink" title="Render 树的建立"></a>Render 树的建立</h2><p>Render 树是基于 DOM 树建立起来的一颗新的树， 是布局和渲染等机制的基础设施。Render 树节点和 DOM 树节点不是一一对应关系，那么哪些情况下需要建立新的 Render 节点呢？</p>
<ul>
<li>DOM 树的 document 节点</li>
<li>DOM 树中的可视化节点，例如 HTML，BODY，DIV 等，非可视化节点不会建立 Render 树节点，例如 HEAD，META，SCRIPT 等</li>
<li>某些情况下需要建立匿名的 Render 节点，该节点不对应于 DOM 树中的任何节点</li>
</ul>
<p>RenderObject 对象在 DOM 树创建的同时也会被创建，当然，如果 DOM 中有动态加入元素时，也可能会相应地创建 RenderObject 对象。下图示例的是 RenderObject 对象被创建的函数调用过程。</p>
<p><img src="https://cmspic-10004025.image.myqcloud.com/fab9e5b0-b268-11e8-ad16-6fbf6c430894_size_333x319#gif" alt="RenderObject 对象被创建的函数调用过程"></p>
<p>Render 树建立之后，布局运算会计算出相关的属性，这其中有位置，大小，是否浮动等。有了这些信息之后，渲染引擎才只知道在何处以及如何画这些元素。</p>
<h2 id="RenderObject-类及其子类"><a href="#RenderObject-类及其子类" class="headerlink" title="RenderObject 类及其子类"></a>RenderObject 类及其子类</h2><p>RenderObject 是 Render 树的节点基础类，提供了一组公共的接口。它有很多的子类，这些子类可能对应一些 DOM 树中的节点，例如 RenderText，有些则是容器类，例如 RenderBlock。下图给出了一些常用的类的继承关系图，这其中 RenderBlock 是一个非常重要的类。</p>
<p><img src="https://cmspic-10004025.image.myqcloud.com/7a2119e0-b269-11e8-ad16-6fbf6c430894_size_557x404#gif" alt="常用的类的继承关系图"></p>
<h2 id="匿名-RenderBlock-对象"><a href="#匿名-RenderBlock-对象" class="headerlink" title="匿名 RenderBlock 对象"></a>匿名 RenderBlock 对象</h2><p>CSS 中有块级元素和内嵌(inline)元素之分。内嵌元素表现的是行布局形式，就是说这些元素以行进行显示。以 div 元素为例，如果设置属性 style 为 display:inline 时，则那是内嵌元素，那么它可能与前面的元素在同一行；如果该元素没有设置这个属性时，则是块级元素，那么在新的行里显示。</p>
<p>RenderBlock 是用来表示块级元素，为了处理上的方便，某些情况下需要建立匿名的 RenderBlock 对象，因为 RenderBlock 的子女必须都是内嵌的元素或者都是非内嵌的元素。所以，当它包含两种元素的时候，那么它会为相邻的内嵌元素创建一个块级 RenderBlock 节点，然后设置该节点为自己的子女并且设置这些内嵌元素为它的子女。</p>
<h1 id="浏览器如何构建-Render-树"><a href="#浏览器如何构建-Render-树" class="headerlink" title="浏览器如何构建 Render 树"></a>浏览器如何构建 Render 树</h1><p><a href="https://cmspic-10004025.image.myqcloud.com/bc350930-b26a-11e8-ad16-6fbf6c430894_size_630x292" target="_blank" rel="noopener">Render 树的构建</a></p>
<p>浏览器取回代码后，首先会构造 DOM 树，就是根据 HTML 标签构建 HTML DOM 树。</p>
<p>之后会解析 CSS 样式，解析的顺序是浏览器的样式(UA defaults) -&gt; 页面的 link 标签引入的链接样式 -&gt; <code>@import</code> 引入的导入样式 -&gt; 写在 style 标签里面的内嵌样式 -&gt; 写在 html 标签是 style 属性的行内样式</p>
<p>根据 DOM 树以及解析的 CSS 样式，构造 Render 树，在 Render 树中，会把 DOM 树中没有的元素给去除，比如 head 标签以及里面的内容，以及 display:none 的元素也会被去除。</p>
<p>一旦 Render 树构建完成，浏览器会把树里面的内容绘制在屏幕上。</p>
<p>html 代码如下：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>Beautiful page<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">p</span>&gt;</span></span><br><span class="line">    Once upon a time there was</span><br><span class="line">    a looong paragraph...</span><br><span class="line">  <span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"display: none"</span>&gt;</span></span><br><span class="line">    Secret message</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"..."</span> /&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>构造的 DOM 树如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">documentElement (html)</span><br><span class="line">  head</span><br><span class="line">    title</span><br><span class="line">  body</span><br><span class="line">    p</span><br><span class="line">      [text node]</span><br><span class="line"></span><br><span class="line">    div</span><br><span class="line">      [text node]</span><br><span class="line"></span><br><span class="line">    div</span><br><span class="line">      img</span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>Render 树如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">root (RenderView)</span><br><span class="line">  body</span><br><span class="line">    p</span><br><span class="line">        line 1</span><br><span class="line">    line 2</span><br><span class="line">    line 3</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">  div</span><br><span class="line">    img</span><br><span class="line"></span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>

<h1 id="CSS-的图层"><a href="#CSS-的图层" class="headerlink" title="CSS 的图层"></a>CSS 的图层</h1><p>在渲染 DOM 的时候，浏览器所做的工作实际上是：1. 获取 DOM 后分割为多个图层 2. 对每个图层的节点计算样式结果 (Recalculate style – 样式重计算) 3. 为每个节点生成图形和位置 (Layout – 回流和重布局) 4. 将每个节点绘制填充到图层位图中 (Paint Setup和Paint – 重绘)  5. 图层作为纹理上传至 GPU 6. 符合多个图层到页面上生成最终屏幕图像 (Composite Layers – 图层重组)</p>
<h1 id="重绘-repaint-redraw-和重排-回流-reflow"><a href="#重绘-repaint-redraw-和重排-回流-reflow" class="headerlink" title="重绘 (repaint/redraw) 和重排/回流 (reflow)"></a>重绘 (repaint/redraw) 和重排/回流 (reflow)</h1><h2 id="重绘"><a href="#重绘" class="headerlink" title="重绘"></a>重绘</h2><p>重绘 (repaint/redraw)。当盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。</p>
<p>触发重绘的条件：改变元素外观属性。如：color，background-color 等。</p>
<p>注意：table 及其内部元素可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用 table 布局页面的原因之一。</p>
<h2 id="重排"><a href="#重排" class="headerlink" title="重排"></a>重排</h2><p>重排 (重构/回流/reflow)。当元素的尺寸/几何属性(宽或高)发生变化，元素显示隐藏等，会导致浏览器需要重新计算元素的几何属性和位置，同样其他元素的几何属性和位置也会因此受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。这就称为重排。</p>
<p>完成重排后，浏览器会重新绘制受影响的部分到屏幕，该过程称为重绘。重排必然导致重绘，所以重排更加恶心。其实我们一直研究的应该是怎么避免触发多次重排。</p>
<p>每个页面至少需要一次重排，就是在页面第一次加载的时候。</p>
<p>触发重排的条件：任何页面布局和几何属性的改变都会触发重排。如：</p>
<ul>
<li>页面渲染初始化(无法避免)</li>
<li>添加或删除可见的 DOM 元素</li>
<li>元素位置的改变，或者使用动画</li>
<li>元素尺寸的改变，包括大小、外边距、边框等</li>
<li>浏览器窗口尺寸的变化(resize事件发生时)</li>
<li>填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变</li>
<li>读取元素尺寸或位置属性: offsetLeft/Top/Height/Width, clientTop/Left/Width/Height, scrollTop/Left/Width/Height,　width/height,　getComputedStyle(), currentStyle(IE)</li>
</ul>
<h2 id="建设重绘和重排来优化页面"><a href="#建设重绘和重排来优化页面" class="headerlink" title="建设重绘和重排来优化页面"></a>建设重绘和重排来优化页面</h2><p>重绘和重排的代价：耗时，导致浏览器卡慢。</p>
<p>优化：</p>
<ul>
<li><p>浏览器自身的优化：浏览器会维护 1 个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会 flush 队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ele = <span class="built_in">document</span>.getElementById(<span class="string">'myDiv'</span>);</span><br><span class="line">ele.style.borderLeft = <span class="string">'1px'</span>;</span><br><span class="line">ele.style.borderRight = <span class="string">'2px'</span>;</span><br><span class="line">ele.style.padding = <span class="string">'5px'</span>;</span><br><span class="line"><span class="comment">// 乍一想，元素的样式改变了三次，每次改变都会引起重排和重绘，所以总共有三次重排重绘过程，但是浏览器并不会这么笨，它会把三次修改“保存”起来(大多数浏览器通过队列化修改并批量执行来优化重排过程)，一次完成！但是，有些时候你可能会(经常是不知不觉)强制刷新队列并要求计划任务立即执行</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>开发者的优化：减少重绘和重排就是要减少对渲染树的操作，可以合并多次的 DOM 和样式的修改，并减少对 style 样式的请求。</p>
<ul>
<li><p>直接改变元素的 className</p>
</li>
<li><p>先设置元素为 display: none; 然后进行页面布局等操作；设置完成后将元素设置为 display: block; 这样的话就只引发两次重绘和重排</p>
</li>
<li><p>要经常访问浏览器的 flush 队列属性；如果一定要访问，可以利用缓存。将访问的值存储起来，接下来使用就不会再引发回流</p>
</li>
<li><p>使用 cloneNode (true or false) 和 replaceChild 技术，引发一次回流和重绘</p>
</li>
<li><p>将需要多次重排的元素，position 属性设为 absolute 或 fixed，元素脱离了文档流，它的变化不会影响到其他元素</p>
</li>
<li><p>如果需要创建多个 DOM 节点，可以使用 documentFragment 创建完后一次性的加入 document</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fragment = <span class="built_in">document</span>.createDocumentFragment()</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>)</span><br><span class="line">li.innerHTML = <span class="string">'apple'</span></span><br><span class="line">fragment.appendChild(li)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> li = <span class="built_in">document</span>.createElement(<span class="string">'li'</span>)</span><br><span class="line">li.innerHTML = <span class="string">'watermelon'</span></span><br><span class="line">fragment.appendChild(li)</span><br><span class="line"></span><br><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'fruit'</span>).appendChild(fragment)</span><br></pre></td></tr></table></figure>
</li>
<li><p>尽量不要使用 table 布局</p>
</li>
<li><p>量不要在修改样式或者布局信息时查询样式，因为查询的时候会强制重排，导致浏览器无法优化多次重排</p>
</li>
</ul>
</li>
</ul>
<h1 id="transform-是否可以避免重排重绘问题"><a href="#transform-是否可以避免重排重绘问题" class="headerlink" title="transform 是否可以避免重排重绘问题"></a>transform 是否可以避免重排重绘问题</h1><p>CSS 的最终表现分为以下四步：<code>Recalculate Style</code> -&gt; <code>Layout</code> -&gt; <code>Paint Setup and Paint</code> -&gt; <code>Composite Layers</code>，即查找并计算样式 -&gt; 排布 -&gt; 绘制 -&gt; 组合层</p>
<p>重排必定导致重绘，而查询样式会强制发生重排！</p>
<p>由于 <code>transform</code> 是位于 <code>Composite Layers</code> 层，而 <code>width</code>、<code>left</code>、<code>margin</code> 等则是位于 <code>Layout</code> 层。在 <code>Layout</code> 层发生的改变必定导致 <code>Paint Setup and Paint</code> -&gt; <code>Composite Layers</code>，所以相对而言使用 <code>transform</code> 实现的动画效果肯定比 <code>left</code> 这些更加流畅。</p>
<h1 id="动画性能优化"><a href="#动画性能优化" class="headerlink" title="动画性能优化"></a>动画性能优化</h1><p>用绝对定位(absolute)+ 改变位移(left、top等)+ 改变大小(whidth、height) + 改变边距 (margin) 来实现的动画，出现卡顿，其原因是当这些节点改变大小或位置时，浏览器重布局了整个页面！</p>
<p><a href="https://csstriggers.com/" target="_blank" rel="noopener">CSS Triggers</a></p>
<h2 id="强迫浏览器创建图层，开启-GPU-硬件加速"><a href="#强迫浏览器创建图层，开启-GPU-硬件加速" class="headerlink" title="强迫浏览器创建图层，开启 GPU 硬件加速"></a>强迫浏览器创建图层，开启 GPU 硬件加速</h2><p>如果能把动画单独创建一个图层，与页面独立开，就会让动画更顺畅。</p>
<p>满足以下条件就会创建一个图层：</p>
<ol>
<li>3D或透视变换 (perspective transform) CSS 属性</li>
<li>使用硬件加速视频解码的 <video> 节点</video></li>
<li>拥有3D (WebGL) 上下文或硬件加速的 2D 上下文的 <canvas> 节点</canvas></li>
<li>混合插件(如 Flash)</li>
<li>对自己的 opacity 做 CSS 动画或使用一个动画 WebKit 变换的元素</li>
<li>拥有硬件加速 CSS 过滤器的元素</li>
<li>元素有一个包含复合层的后代节点(一个元素拥有一个子元素，该子元素在自己的层里)</li>
<li>元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染)</li>
</ol>
<p>强迫浏览器对元素单独生成一个图层，把重绘的工作交给 GPU 去做，而不占用主线程。也就是利用 GPU 重绘来做动画。</p>
<p>使用 3d 效果来开启硬件加速：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.speed-up</span> &#123;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">rotate3d</span>(250px,250px,250px,-120deg) <span class="built_in">scale3d</span>(0.5, 0.5, 0.5) <span class="built_in">translate3d</span>(250px, 250px, 250px);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">rotate3d</span>(250px,250px,250px,-120deg) <span class="built_in">scale3d</span>(0.5, 0.5, 0.5) <span class="built_in">translate3d</span>(250px, 250px, 250px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果并不需要用到 transform 变换，仅仅是开启硬件加速，可以用下面的语句:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.speed-up</span>&#123;</span><br><span class="line">  <span class="attribute">-webkit-transform</span>: <span class="built_in">translateZ</span>(0);</span><br><span class="line">  <span class="attribute">transform</span>: <span class="built_in">translateZ</span>(0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>硬件加速最好只用在 animation 或者 transform 上。不要滥用硬件加速，因为这样会增加性能的消耗，如果滥用反而会使动画变得更加卡，这样就得不偿失了。</p>
<h2 id="尽量不触发重绘"><a href="#尽量不触发重绘" class="headerlink" title="尽量不触发重绘"></a>尽量不触发重绘</h2><p>想提高动画性能，需要做的就是减少浏览器在动画运行时所需要做的工作。最好的情况是，改变的属性仅仅影响图层的组合，变换 (transform) 和透明度(opacity)就属于这种情况。</p>
<h2 id="减小选择器的复杂性"><a href="#减小选择器的复杂性" class="headerlink" title="减小选择器的复杂性"></a>减小选择器的复杂性</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:nth-last-child(-n+1)</span> <span class="selector-class">.title</span> &#123;</span><br><span class="line">  <span class="comment">/* styles */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.final-box-title</span> &#123;</span><br><span class="line">  <span class="comment">/* styles */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码都是选择同一个元素，当元素很多时，第二个选择器的性能会明显优于第一个。BEM 规范有做类似事情，按照特性直接由一个选择器选择元素的性能往往会更优。</p>
<h2 id="减少样式的计算量"><a href="#减少样式的计算量" class="headerlink" title="减少样式的计算量"></a>减少样式的计算量</h2><p>减少无效元素、冗余标签。</p>
<h2 id="使用-Flexbox-布局"><a href="#使用-Flexbox-布局" class="headerlink" title="使用 Flexbox 布局"></a>使用 Flexbox 布局</h2><h2 id="css-动画与-js-动画"><a href="#css-动画与-js-动画" class="headerlink" title="css 动画与 js 动画"></a>css 动画与 js 动画</h2><p>css 动画优点：</p>
<p>(1) 浏览器可以对动画进行优化</p>
<ol>
<li>浏览器使用与 requestAnimationFrame 类似的机制，requestAnimationFrame 比起 setTimeout、setInterval 设置动画的优势主要是:<ul>
<li>requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频，一般来说，这个频率为每秒 60 帧。</li>
<li>在隐藏或不可见的元素中 requestAnimationFrame 不会进行重绘或回流，这当然就意味着更少的 CPU、GPU 和内存使用量。</li>
</ul>
</li>
<li>强制使用硬件加速，通过 GPU 来提高动画性能</li>
</ol>
<p>(2) 代码相对简单，性能调优方向固定</p>
<p>(3) 对于帧速表现不好的低版本浏览器，css 可以做到自然降级，而 js 则需要撰写额外代码</p>
<p>css 动画缺点：</p>
<p>(1) 运行过程控制较弱，无法附加事件绑定回调函数。css 动画只能暂停，不能在动画中寻找一个特定的时间点，不能在半路反转动画，不能变换时间尺度，不能在特定的位置添加回调函数或是绑定回放事件，无进度报告</p>
<p>(2) 代码冗长。想用 CSS 实现稍微复杂一点动画,最后 css 代码都会变得非常笨重。</p>
<p>js 动画优点：</p>
<p>(1) js 动画控制能力很强，可以在动画播放过程中对动画进行控制：开始、暂停、回放、终止、取消都是可以做到的。</p>
<p>(2) 动画效果比 css 动画丰富，有些动画效果，比如曲线运动、冲击闪烁、视差滚动效果，只有 js 动画才能完成</p>
<p>(3) css 动画有兼容性问题，而 js 动画大多时候没有兼容性问题</p>
<p>js 动画缺点：</p>
<p>(1) js 在浏览器的主线程中运行，而主线程中还有其它需要运行的 js 脚本、样式计算、布局、绘制任务等，对其干扰导致线程可能出现阻塞，从而造成丢帧的情况。</p>
<p>(2) js 动画代码的复杂度高于 css 动画</p>
<p>总结：如果动画只是简单的状态切换，不需要中间过程控制，在这种情况下，css 动画是优选方案。它可以让你将动画逻辑放在样式文件里面，而不会让你的页面充斥 js 库。然而如果你在设计很复杂的客户端界面或者在开发一个有着复杂 UI 状态的 APP。那么你应该使用 js 动画，这样你的动画可以保持高效，并且你的工作流也更可控。所以，在实现一些小的交互动效的时候，就多考虑考虑 css 动画。对于一些复杂控制的动画，使用 js 动画比较可靠。</p>
<h2 id="优化-js-动画"><a href="#优化-js-动画" class="headerlink" title="优化 js 动画"></a>优化 js 动画</h2><h3 id="使用-requestAnimationFrame"><a href="#使用-requestAnimationFrame" class="headerlink" title="使用 requestAnimationFrame"></a>使用 requestAnimationFrame</h3><p>将 setTimeout 换成 requestAnimationFrame，因为 setTimeout 时间控制可能造成在一帧的中间，目前各浏览器对 requestAnimationFrame 的支持已经比较好了。</p>
<h3 id="使用-Web-Workers"><a href="#使用-Web-Workers" class="headerlink" title="使用 Web Workers"></a>使用 Web Workers</h3><p>将复杂计算的 JS 采用 Web Workers 进行处理。</p>
<h3 id="减少垃圾回收"><a href="#减少垃圾回收" class="headerlink" title="减少垃圾回收"></a>减少垃圾回收</h3><p>垃圾回收是一个容易被忽略的问题，因为垃圾回收的时间是不受控制的，它可能在一个动画的中途，阻塞动画的执行，更理想的情况是在循环中复用对象。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>box-sizing</title>
    <url>/zh/2018/12/28/css%5Bbox-sizing%5D/</url>
    <content><![CDATA[<p>box-sizing，“盒子的大小”，顾名思义，这个属性影响的是盒模型。</p>
<a id="more"></a>

<p>适用于：所有接受 <code>width</code> 和 <code>height</code> 的元素。</p>
<p>继承性：无。</p>
<p>所以我们一般定义：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 元素的内边距和边框将在已设定的宽度和高度内进行绘制</span><br><span class="line"><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">* &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>取值：</p>
<ul>
<li>content-box<ul>
<li>padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和，即 ( Element width = width + border + padding )</li>
<li>此属性表现为标准模式下的盒模型。</li>
</ul>
</li>
<li>border-box<ul>
<li>padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值，即使定义有border和padding也不会改变对象的实际宽度，即 ( Element width = width )</li>
<li>此属性表现为怪异模式下的盒模型。</li>
</ul>
</li>
</ul>
<p>content-box 是默认值。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>margin</title>
    <url>/zh/2018/09/11/css%5Bmargin%5D/</url>
    <content><![CDATA[<p>margin</p>
<a id="more"></a>

<p>外补白 [ margin-top ] || [ margin-right ] || [ margin-bottom ] || [ margin-left ]</p>
<p>适用于所有元素，除非 table | inline-table | table-caption 的表格类元素之外。</p>
<p>取值：</p>
<ul>
<li>auto：水平（默认）书写模式下，margin-top/margin-bottom 计算值为0，margin-left/margin-right取决于可用空间</li>
<li><length>：用长度值来定义外补白。可以为负值</length></li>
<li><percentage>：用百分比来定义外补白。水平（默认）书写模式下，参照其包含块 <code>width</code> 进行计算，其它情况参照 height ，可以为负值</percentage></li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">检索或设置对象四边的外延边距。</span><br><span class="line">如果提供全部四个参数值，将按上、右、下、左的顺序作用于四边。</span><br><span class="line">如果只提供一个，将用于全部的四边。</span><br><span class="line">如果提供两个，第一个用于上、下，第二个用于左、右。</span><br><span class="line">如果提供三个，第一个用于上，第二个用于左、右，第三个用于下。</span><br><span class="line">外延边距始终透明。</span><br></pre></td></tr></table></figure>

<p><strong>非替代(non-Replaced)行内元素可以使用该属性设置左、右两边的外补丁；若要设置上、下两边的外补丁，必须先使该对象表现为块级或内联块级。</strong></p>
<h2 id="margin折叠"><a href="#margin折叠" class="headerlink" title="margin折叠"></a>margin折叠</h2><p>margin collapsing，某些相邻的margin会发生合并。</p>
<p>会发生外边距折叠的三种基本情况：</p>
<ul>
<li>相邻元素之间<ul>
<li>毗邻的两个元素之间的外边距会折叠（除非后一个元素需要清除之前的浮动）。</li>
</ul>
</li>
<li>父元素与其第一个或最后一个子元素之间<ul>
<li>如果在父元素与其第一个子元素之间不存在边框、内边距、行内内容，也没有创建块格式化上下文、或者清除浮动将两者的 margin-top 分开；或者在父元素与其最后一个子元素之间不存在边框、内边距、行内内容、height、min-height、max-height将两者的 margin-bottom 分开，那么这两对外边距之间会产生折叠。此时子元素的外边距会“溢出”到父元素的外面。</li>
</ul>
</li>
<li>空的块级元素<ul>
<li>如果一个块级元素中不包含任何内容，并且在其 margin-top 与 margin-bottom 之间没有边框、内边距、行内内容、height、min-height 将两者分开，则该元素的上下外边距会折叠。</li>
</ul>
</li>
</ul>
<p>一些需要注意的地方：</p>
<ul>
<li>上述情况的组合会产生更复杂的外边距折叠。</li>
<li>即使某一外边距为0，这些规则仍然适用。因此就算父元素的外边距是0，第一个或最后一个子元素的外边距仍然会“溢出”到父元素的外面。</li>
<li>如果参与折叠的外边距中包含负值，折叠后的外边距的值为最大的正边距与最小的负边距（即绝对值最大的负边距）的和。</li>
<li>如果所有参与折叠的外边距都为负，折叠后的外边距的值为最小的负边距的值。这一规则适用于相邻元素和嵌套元素。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"margin: 0;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-bottom: 10px;"</span>&gt;</span>这是一个标题<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-top: 30px;"</span>&gt;</span></span><br><span class="line">  	  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-top: 20px;"</span>&gt;</span>这是又一个标题<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>本例中，第一个div的margin-bottom（10px），第二个div的margin-top（30px），第二个div的子元素div的margin-top（10px）将被合并，因为它们三个相邻。它们之间的margin间隙最后是（30px），即取三者之间最大的那个值。</p>
<p>如果给上例中的div加上border的话：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"margin: 0;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-bottom: 10px;"</span>&gt;</span>这是一个标题<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-top: 30px;border:1px solid #000;"</span>&gt;</span></span><br><span class="line">  	  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"margin-top: 20px;"</span>&gt;</span>这是又一个标题<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>本例中，第一个div的margin-bottom（10px），第二个div的margin-top（30px）将被合并，因为它们两个相邻。第二个div的子元素div的margin-top不与它们合并，因为它被border分隔，不与它们相邻。</p>
<p>margin折叠常规认知：</p>
<ul>
<li>margin折叠只发生在块级元素上；</li>
<li>浮动元素的margin不与任何margin发生折叠；</li>
<li>绝对定位元素的margin不与任何margin发生折叠；</li>
<li>设置了属性overflow且值不为visible的块级元素，将不与它的子元素发生margin折叠；</li>
<li>根元素的margin不与其它任何margin发生折叠；</li>
</ul>
<p>意味着解决margin折叠的方法有：</p>
<ul>
<li>元素设为行内块元素；</li>
<li>元素设为浮动元素；</li>
<li>元素设为绝对定位元素；</li>
<li>元素设置属性overflow且值不为visible；</li>
</ul>
<h2 id="BFC"><a href="#BFC" class="headerlink" title="BFC"></a>BFC</h2><p><a href="/zh/2018/12/28/css[BFC]/">BFC</a></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>三角形</title>
    <url>/zh/2020/10/16/css%5B%E4%B8%89%E8%A7%92%E5%BD%A2%5D/</url>
    <content><![CDATA[<p>css 实现三角形</p>
<a id="more"></a>

<p>正三角</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#triangle-up</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>倒三角</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#triangle-down</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">100px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>左三角</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#triangle-left</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">100px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>右三角</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#triangle-right</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">100px</span> solid red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直角三角形</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-id">#triangle-topleft</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">100px</span> solid red;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#triangle-topright</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-top</span>: <span class="number">100px</span> solid red;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#triangle-bottomleft</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid red;</span><br><span class="line">  <span class="attribute">border-right</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-id">#triangle-bottomright</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">border-bottom</span>: <span class="number">100px</span> solid red;</span><br><span class="line">  <span class="attribute">border-left</span>: <span class="number">100px</span> solid transparent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以用 scss 写一个 mixin 函数</p>
<p>角度跟边长有关</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>权重</title>
    <url>/zh/2018/09/10/css%5B%E6%9D%83%E9%87%8D%5D/</url>
    <content><![CDATA[<p>css 权重问题并不简单。</p>
<a id="more"></a>

<h1 id="什么是-css-权重"><a href="#什么是-css-权重" class="headerlink" title="什么是 css 权重"></a>什么是 css 权重</h1><p>css 权重决定了你 css 规则怎样被浏览器解析直到生效。css 权重关系到你的 css 规则是怎样显示的。</p>
<p>当很多的规则被应用到某一个元素上时，权重是一个决定哪种规则生效，或者是优先级的过程。</p>
<ul>
<li>权重决定了哪一条规则会被浏览器应用在元素上</li>
<li>权重的不同，是你所期望的效果，没有通过 css 规则在元素上生效的主要原因</li>
<li>权重的级别划分时包含了所有的 css 选择器</li>
<li>如果两个选择器作用在同一元素上，则权重高者生效</li>
<li>如果两个选择器权重值相同，则最后定义的规则被计算到权重中(后面定度的 css 规则权重要更大，会取代前面的 css 规则)</li>
<li>如果两个选择器权重值不同，则权重大的规则被计算到权重中</li>
<li>如果一条规则包含了更高权重的选择器，那么这个规则权重更高</li>
<li>最后定义的规则会覆盖所有跟前面冲突的规则</li>
</ul>
<h1 id="四大等级"><a href="#四大等级" class="headerlink" title="四大等级"></a>四大等级</h1><p>行内样式 &gt; id &gt; class 类/伪类/属性 &gt; 标签/元素/伪元素 &gt; inherit 继承/* 通配符</p>
<ul>
<li>行内样式：1000</li>
<li>id：100</li>
<li>class 类/伪类/属性：10</li>
<li>标签/元素/伪元素：1</li>
<li>inherit 继承/* 通配符：0</li>
</ul>
<h1 id="important"><a href="#important" class="headerlink" title="!important"></a>!important</h1><ul>
<li>!important 会修改当前对应元素的当前 css 属性和值的权重，对子元素权重没影响</li>
<li>有 !important 指定的权重值大于所有未用 !important 指定的规则</li>
<li>非到万不得已不要用 !important</li>
</ul>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>取值与单位</title>
    <url>/zh/2018/09/11/css%5B%E5%8F%96%E5%80%BC%E4%B8%8E%E5%8D%95%E4%BD%8D%5D/</url>
    <content><![CDATA[<p>取值与单位</p>
<a id="more"></a>

<h1 id="长度值与单位"><a href="#长度值与单位" class="headerlink" title="长度值与单位"></a>长度值与单位</h1><h2 id="长度取值"><a href="#长度取值" class="headerlink" title="长度取值"></a>长度取值</h2><table>
<thead>
<tr>
<th align="left">长度取值</th>
<th align="left">版本</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>&lt;length&gt;</code></td>
<td align="left">CSS2</td>
<td align="left"><code>&lt;number&gt;</code>接长度单位</td>
</tr>
</tbody></table>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&lt;number&gt;接长度单位。</span><br><span class="line">特殊值0可以省略单位。例如：margin:0px可以写成margin:0</span><br><span class="line">一些属性可能允许有负长度值，或者有一定的范围限制。如果不支持负长度值，那应该变换到能够被支持的最近的一个长度值。</span><br><span class="line">长度单位包括包括：相对单位和绝对单位。</span><br><span class="line">相对长度单位包括有： em, ex, ch, rem, vw, vh, vmax, vmin</span><br><span class="line">绝对长度单位包括有： cm, mm, q, <span class="keyword">in</span>, pt, pc, px</span><br></pre></td></tr></table></figure>

<h2 id="长度单位"><a href="#长度单位" class="headerlink" title="长度单位"></a>长度单位</h2><p>文本相对长度单位</p>
<table>
<thead>
<tr>
<th align="left">长度单位</th>
<th align="left">版本</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">em</td>
<td align="left">CSS1</td>
<td align="left">相对于当前对象内文本的字体尺寸</td>
</tr>
<tr>
<td align="left">ex</td>
<td align="left">CSS1</td>
<td align="left">相对于字符“x”的高度。通常为字体高度的一半</td>
</tr>
<tr>
<td align="left">ch</td>
<td align="left">CSS3</td>
<td align="left">数字“0”的宽度</td>
</tr>
<tr>
<td align="left">rem</td>
<td align="left">CSS3</td>
<td align="left">相对于根元素(即html元素)font-size计算值的倍数</td>
</tr>
<tr>
<td align="left">%</td>
<td align="left">CSS1</td>
<td align="left">百分比</td>
</tr>
</tbody></table>
<p>视口相对长度单位</p>
<table>
<thead>
<tr>
<th align="left">长度单位</th>
<th align="left">版本</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">vw</td>
<td align="left">CSS3</td>
<td align="left">相对于视口的宽度。视口被均分为100单位的vw</td>
</tr>
<tr>
<td align="left">vh</td>
<td align="left">CSS3</td>
<td align="left">相对于视口的高度。视口被均分为100单位的vh</td>
</tr>
<tr>
<td align="left">vmax</td>
<td align="left">CSS3</td>
<td align="left">相对于视口的宽度或高度，总是相对于大的那个。视口的宽度或高度被均分为100单位的vmax</td>
</tr>
<tr>
<td align="left">vmin</td>
<td align="left">CSS3</td>
<td align="left">相对于视口的宽度或高度，总是相对于小的那个。视口的宽度或高度被均分为100单位的vmin</td>
</tr>
</tbody></table>
<p>绝对长度单位</p>
<table>
<thead>
<tr>
<th align="left">长度单位</th>
<th align="left">版本</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">cm</td>
<td align="left">CSS1</td>
<td align="left">厘米</td>
</tr>
<tr>
<td align="left">mm</td>
<td align="left">CSS1</td>
<td align="left">毫米</td>
</tr>
<tr>
<td align="left">q</td>
<td align="left">CSS1</td>
<td align="left">1/4毫米（quarter-millimeters）; 1q = 0.25mm</td>
</tr>
<tr>
<td align="left">in</td>
<td align="left">CSS1</td>
<td align="left">英寸（inches）; 1in = 2.54cm</td>
</tr>
<tr>
<td align="left">pt</td>
<td align="left">CSS1</td>
<td align="left">点（points）; 1pt = 1/72in</td>
</tr>
<tr>
<td align="left">pc</td>
<td align="left">CSS1</td>
<td align="left">派卡（picas）; 1pc = 12pt</td>
</tr>
<tr>
<td align="left">px</td>
<td align="left">CSS1</td>
<td align="left">像素（pixels）; 1px = 1/96in</td>
</tr>
</tbody></table>
<p>px 说是绝对长度单位，这是对于单个设备而言的。px 与设备显示屏的分辨率有关。对于屏幕显示，通常是一个设备像素（点）的显示。</p>
<h3 id="浏览器支持"><a href="#浏览器支持" class="headerlink" title="浏览器支持"></a>浏览器支持</h3><table>
<thead>
<tr>
<th>长度单位</th>
<th>Chrome</th>
<th>IE</th>
<th>Firefox</th>
<th>Safari</th>
<th>Opera</th>
</tr>
</thead>
<tbody><tr>
<td>em, ex, %, cm, mm, q, in, pt, pc, px</td>
<td>1.0</td>
<td>3.0</td>
<td>1.0</td>
<td>1.0</td>
<td>3.5</td>
</tr>
<tr>
<td>ch</td>
<td>27.0</td>
<td>9.0</td>
<td>1.0</td>
<td>7.0</td>
<td>20.0</td>
</tr>
<tr>
<td>rem</td>
<td>4.0</td>
<td>9.0</td>
<td>3.6</td>
<td>4.1</td>
<td>11.6</td>
</tr>
<tr>
<td>vh, vw</td>
<td>20.0</td>
<td>9.0</td>
<td>19.0</td>
<td>6.0</td>
<td>20.0</td>
</tr>
<tr>
<td>vmin</td>
<td>20.0</td>
<td>9.0*</td>
<td>19.0</td>
<td>6.0</td>
<td>20.0</td>
</tr>
<tr>
<td>vmax</td>
<td>26.0</td>
<td>不支持</td>
<td>19.0</td>
<td>不支持</td>
<td>20.0</td>
</tr>
</tbody></table>
<p>注意: IE 9.0 是通过不标准的名称 vm 来支持 vmin 的。</p>
<h3 id="常用相对长度"><a href="#常用相对长度" class="headerlink" title="常用相对长度"></a>常用相对长度</h3><p>相对长度单位指定了一个长度相对于另一个长度的属性。对于不同的设备，相对长度更适用。</p>
<table>
<thead>
<tr>
<th>单位</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>em</td>
<td>相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。比如如果当前行内文本的字体尺寸为 16px，2em === 32px</td>
</tr>
<tr>
<td>rem</td>
<td>相对于根元素(即html元素)font-size</td>
</tr>
<tr>
<td>vw</td>
<td>viewpoint width，视窗宽度，1vw = 视窗宽度的 1%</td>
</tr>
<tr>
<td>vh</td>
<td>viewpoint height，视窗高度，1vh = 视窗高度的1%</td>
</tr>
<tr>
<td>vmin</td>
<td>相对于 vw 和 vh 中较小的那个</td>
</tr>
<tr>
<td>vmax</td>
<td>相对于 vw 和 vh 中较大的那个</td>
</tr>
<tr>
<td>%</td>
<td>百分比。关键考虑到底相对什么的百分比</td>
</tr>
</tbody></table>
<h4 id="em-与-rem-的区别"><a href="#em-与-rem-的区别" class="headerlink" title="em 与 rem 的区别"></a>em 与 rem 的区别</h4><p>都是相对大小。em 相对的是从当前向上查询已定义的 px，；而 rem 相对的永远是相对于根元素(即html元素)font-size。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 根元素 (html root) 的 font-size 为 50px --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">style</span>=<span class="string">"font-size: 50px;"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"margin: 0;"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 高度 16px --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"font-size: 16px;line-height: 1;"</span>&gt;</span>px文字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 高度 2em === 100px，向上查询找到根元素 (html root) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"font-size: 2em;line-height: 1;"</span>&gt;</span>em文字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"font-size: 16px;"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 高度 2em === 32px，向上查询找到 div 元素 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"font-size: 2em;line-height: 1;"</span>&gt;</span>em文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 高度 2rem === 100px，相对根元素 (html root) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"font-size: 2rem;line-height: 1;"</span>&gt;</span>rem文字<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"font-size: 16px;"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 高度 2rem === 100px，相对根元素 (html root) --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">"font-size: 2rem;line-height: 1;"</span>&gt;</span>rem文字<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="vw、vh、vmin、vmax"><a href="#vw、vh、vmin、vmax" class="headerlink" title="vw、vh、vmin、vmax"></a>vw、vh、vmin、vmax</h4><p>这里的 viewpoint 指浏览器内部的可视区域</p>
<p>viewpoint width，视窗宽度，是指 <code>window.innerWidth</code></p>
<p>viewpoint height，视窗高度，是指 <code>window.innerHeight</code></p>
<p>10vw = window.innerWidth * 10 / 100</p>
<p>10vh = window.innerHeight * 10 / 100</p>
<p>浏览器内部宽度 window.innerWidth，不包括 scrollbars, toolbars 等</p>
<p>浏览器整体宽度 window.outerWidth，包括 scrollbars, toolbars 等</p>
<p>显示器宽度 window.screen.width，固定不变</p>
<p>window.screen.width &gt;= window.outerWidth &gt; window.innerWidth</p>
<p><strong>有个奇怪的地方，在 chrome 的 device toolbar 调试时，window.innerWidth 最小是 980</strong></p>
<h4 id="百分比"><a href="#百分比" class="headerlink" title="% 百分比"></a>% 百分比</h4><p>关键考虑到底相对什么的百分比</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"margin: 0;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 400px;height: 500px;background: red;"</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 宽高是父元素的 30%，即 120px 150px，padding 是父元素的 10%，即 40px，真实宽高为 200px 230px。margin 是父元素的 10%，即 40px，第一个子元素 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 30%;height: 30%;background: #fff;margin: 10%;padding: 10%;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 100%;height: 100%;background: #ff0;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 30%;height: 30%;background: #fff;margin: 10%;padding: 10%;box-sizing: border-box;"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 100%;height: 100%;background: #ff0;"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h5 id="width-height-的百分比"><a href="#width-height-的百分比" class="headerlink" title="width/height 的百分比"></a>width/height 的百分比</h5><p>子元素的 width/height 的百分比是相对于父元素的 width/height 的百分比。</p>
<h5 id="margin-的百分比"><a href="#margin-的百分比" class="headerlink" title="margin 的百分比"></a>margin 的百分比</h5><p>子元素的 margin 的百分比是相对于父元素的 width (只是 content 部分)的百分比</p>
<p><a href="/zh/2018/09/11/css[margin]/">margin</a></p>
<h5 id="padding-的百分比"><a href="#padding-的百分比" class="headerlink" title="padding 的百分比"></a>padding 的百分比</h5><p>子元素的 padding 的百分比是相对于父元素的 width (只是 content 部分)的百分比</p>
<p><a href="/zh/2018/12/28/css[box-sizing]/">box-sizing</a></p>
<h1 id="角度值与单位"><a href="#角度值与单位" class="headerlink" title="角度值与单位"></a>角度值与单位</h1><table>
<thead>
<tr>
<th align="left">角度取值</th>
<th align="left">版本</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>&lt;angel&gt;</code></td>
<td align="left">CSS3</td>
<td align="left"><code>&lt;number&gt;</code>接角度单位</td>
</tr>
</tbody></table>
<h2 id="角度单位"><a href="#角度单位" class="headerlink" title="角度单位"></a>角度单位</h2><p>文本相对长度单位</p>
<table>
<thead>
<tr>
<th align="left">角度单位</th>
<th align="left">版本</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">deg</td>
<td align="left">CSS3</td>
<td align="left">度（Degrees）</td>
</tr>
<tr>
<td align="left">grad</td>
<td align="left">CSS3</td>
<td align="left">梯度（Gradians）</td>
</tr>
<tr>
<td align="left">rad</td>
<td align="left">CSS3</td>
<td align="left">弧度（Radians）</td>
</tr>
<tr>
<td align="left">turn</td>
<td align="left">CSS3</td>
<td align="left">转、圈（Turns）</td>
</tr>
</tbody></table>
<h3 id="deg"><a href="#deg" class="headerlink" title="deg"></a>deg</h3><p>deg 度（Degress）。一个圆共360度</p>
<p>90deg = <code>(90/360)*400</code> grad ≈ <code>(90/360)*2π</code> rad = (90/360) turn</p>
<h3 id="grad"><a href="#grad" class="headerlink" title="grad"></a>grad</h3><p>梯度（Gradians）。一个圆共400梯度</p>
<h3 id="rad"><a href="#rad" class="headerlink" title="rad"></a>rad</h3><p>弧度（Radians）。一个圆共2π弧度</p>
<p>π 为 <code>Math.PI</code></p>
<h3 id="turn"><a href="#turn" class="headerlink" title="turn"></a>turn</h3><p>转、圈（Turns）。一个圆共1圈</p>
<h1 id="时间取值与单位"><a href="#时间取值与单位" class="headerlink" title="时间取值与单位"></a>时间取值与单位</h1><table>
<thead>
<tr>
<th align="left">时间取值</th>
<th align="left">版本</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>&lt;time&gt;</code></td>
<td align="left">CSS3</td>
<td align="left"><code>&lt;number&gt;</code>接时间单位</td>
</tr>
</tbody></table>
<p>时间值不允许有负值。</p>
<h2 id="时间单位"><a href="#时间单位" class="headerlink" title="时间单位"></a>时间单位</h2><table>
<thead>
<tr>
<th align="left">时间单位</th>
<th align="left">版本</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">s</td>
<td align="left">CSS3</td>
<td align="left">秒</td>
</tr>
<tr>
<td align="left">ms</td>
<td align="left">CSS3</td>
<td align="left">毫秒</td>
</tr>
</tbody></table>
<p>1s = 1000ms</p>
<h1 id="颜色取值"><a href="#颜色取值" class="headerlink" title="颜色取值"></a>颜色取值</h1><table>
<thead>
<tr>
<th align="left">颜色取值</th>
<th align="left">版本</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">ColorName</td>
<td align="left">CSS1</td>
<td align="left">用颜色名称来指定颜色。包括基本颜色关键字、系统颜色、SVG颜色关键字等</td>
</tr>
<tr>
<td align="left">HEX</td>
<td align="left">CSS1</td>
<td align="left">十六进制记法。语法如：#rrggbb或#rgb</td>
</tr>
<tr>
<td align="left">RGB</td>
<td align="left">CSS2</td>
<td align="left">rgb记法</td>
</tr>
<tr>
<td align="left">RGBA</td>
<td align="left">CSS3</td>
<td align="left">rgba记法</td>
</tr>
<tr>
<td align="left">HSL</td>
<td align="left">CSS3</td>
<td align="left">hsl记法</td>
</tr>
<tr>
<td align="left">HSLA</td>
<td align="left">CSS3</td>
<td align="left">hsla记法</td>
</tr>
<tr>
<td align="left">transparent</td>
<td align="left">CSS1/CSS3</td>
<td align="left">全透明</td>
</tr>
<tr>
<td align="left">currentColor</td>
<td align="left">CSS3</td>
<td align="left">当前颜色</td>
</tr>
</tbody></table>
<ol>
<li>color 的部分关键字可能不被某些浏览器支持；</li>
<li>hex。#RRGGBB。<ul>
<li>RR：红色值，十六进制正整数</li>
<li>GG：绿色值，十六进制正整数</li>
<li>BB：蓝色值，十六进制正整数</li>
<li>取值范围：00 - FF。必须是两位数。对于只有一位的，应在前面补零</li>
</ul>
</li>
<li>RGB(R,G,B)。<ul>
<li>R：红色值，正整数 | 百分数</li>
<li>G：绿色值，正整数 | 百分数</li>
<li>B：蓝色值，正整数 | 百分数</li>
<li>正整数值的取值范围为：0 - 255。百分数值的取值范围为：0.0% - 100.0%。超出范围的数值将被截至其最接近的取值极限</li>
</ul>
</li>
<li>RGBA(R,G,B,A)。<ul>
<li>A：Alpha透明度。取值0~1之间。IE9+</li>
<li>对于IE6-8，可以使用滤镜filter处理</li>
</ul>
</li>
<li>HSL(H,S,L)。<ul>
<li>H：Hue(色调)。0(或360)表示红色，120表示绿色，240表示蓝色，也可取其他数值来指定颜色。取值为：0 - 360。</li>
<li>S：Saturation(饱和度)。取值为：0.0% - 100.0%</li>
<li>L：Lightness(亮度)。取值为：0.0% - 100.0%</li>
</ul>
</li>
<li>HSLA(H,S,L,A)<ul>
<li>A：Alpha透明度。取值0~1之间。</li>
</ul>
</li>
<li>transparent 是全透明黑色(black)的速记法，即一个类似rgba(0,0,0,0)这样的值。<ul>
<li>在CSS1中，transparent被用来作为background-color的一个参数值，用于表示背景透明。</li>
<li>在CSS2中，border-color也开始接受transparent作为参数值，《Open eBook(tm) Publication Structure 1.0.1》[OEB101]延伸到color也接受transparent作为参数值。</li>
<li>在CSS3中，transparent被延伸到任何一个有color值的属性上。</li>
</ul>
</li>
<li>currentColor是 color 属性的值，具体意思是指：currentColor关键字的使用值是 color 属性值的计算值。<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line">  <span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">上述代码将会让div拥有一个红色的边框，这就解释了 border-color 属性的默认值是 color 属性的值；</span></span><br><span class="line"><span class="comment">如果将上述代码中的color属性定义删除，那么边框的颜色将取决于父元素的 color 计算值，因为 color 拥有继承性。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

</li>
</ol>
<h1 id="文本取值"><a href="#文本取值" class="headerlink" title="文本取值"></a>文本取值</h1><table>
<thead>
<tr>
<th align="left">文本取值</th>
<th align="left">版本</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">inherit</td>
<td align="left">CSS2.1</td>
<td align="left">该值使得属性能够继承祖先设置</td>
</tr>
<tr>
<td align="left">initial</td>
<td align="left">CSS3</td>
<td align="left">属性初始值</td>
</tr>
<tr>
<td align="left">unset</td>
<td align="left">CSS3</td>
<td align="left">擦除属性申明</td>
</tr>
<tr>
<td align="left"><code>&lt;string&gt;</code></td>
<td align="left">CSS2</td>
<td align="left">字符串(含转义字符串)</td>
</tr>
<tr>
<td align="left"><code>&lt;url&gt;</code></td>
<td align="left">CSS2</td>
<td align="left">在网页上提供一个资源地址。（图像，声频，视频或浏览器支持的其他任何资源）</td>
</tr>
<tr>
<td align="left"><code>&lt;identifier&gt;</code></td>
<td align="left">CSS2</td>
<td align="left">使用用户自定义标识名作为组件取值</td>
</tr>
</tbody></table>
<ol>
<li>inherit 可以让一个不具备继承特性的属性可以继承父元素</li>
<li>initial 重置某个属性为UA默认设置</li>
<li>一个属性定义了unset值，如果该属性是默认继承属性，该值等同于inherit，如果该属性是非继承属性，该值等同于initial</li>
<li>字符串可以由双引号或单引号包起来；转义字符串由 反斜杠<code>(\)</code>开始，如：<code>\&#39;</code>, <code>\&quot;</code>。content、font-family 等。</li>
<li><url> 有引号和无引号都是正确的。background</url></li>
<li>自定义标识。如 myIdentifier<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">	<span class="attribute">animation</span>: myIdentifier <span class="number">3s</span> linear;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">keyframes</span> myIdentifier &#123;</span><br><span class="line">  0% &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  100% &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ol>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/zh/2016/01/01/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<a id="more"></a>

<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>Start your blog.</p>
<h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h2 id="找对象"><a href="#找对象" class="headerlink" title="找对象"></a>找对象</h2><p>月薪1万+，不打老婆，房产证上写你名，工资卡上交，拿去随便刷，买买买！家里没皇位继承不用生儿子，你若难产我保大！饭我做，碗我刷，衣服我洗，孩子我带。我负责赚钱养家，你负责貌美如花！我是认真的！你找吧，你能找到比我对你更好的，我给你跪下！</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>git相关</title>
    <url>/zh/2018/10/26/git%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>Git 是一个免费的开源分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p>
<p>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。</p>
<a id="more"></a>

<p><a href="https://git-scm.com/" target="_blank" rel="noopener">git</a></p>
<p><a href="https://git-scm.com/book/zh/v2/" target="_blank" rel="noopener">doc</a></p>
<p><a href="https://git-scm.com/book/zh/v2/起步-初次运行-Git-前的配置" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/起步-初次运行-Git-前的配置</a></p>
<p><a href="https://git-scm.com/book/zh/v2/Git-基础-获取-Git-仓库" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/Git-基础-获取-Git-仓库</a></p>
<p><a href="https://git-scm.com/book/zh/v2/Git-基础-记录每次更新到仓库" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/Git-基础-记录每次更新到仓库</a></p>
<p><a href="https://git-scm.com/book/zh/v2/Git-基础-查看提交历史" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/Git-基础-查看提交历史</a></p>
<p><a href="https://git-scm.com/book/zh/v2/Git-基础-撤消操作" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/Git-基础-撤消操作</a></p>
<p><a href="https://git-scm.com/book/zh/v2/Git-基础-远程仓库的使用" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/Git-基础-远程仓库的使用</a></p>
<p><a href="https://git-scm.com/book/zh/v2/Git-基础-打标签" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/Git-基础-打标签</a></p>
<p><a href="https://git-scm.com/book/zh/v2/Git-分支-分支的新建与合并" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/Git-分支-分支的新建与合并</a></p>
<p><a href="https://git-scm.com/book/zh/v2/Git-分支-分支管理" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/Git-分支-分支管理</a></p>
<p><a href="https://git-scm.com/book/zh/v2/Git-分支-远程分支" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/Git-分支-远程分支</a></p>
<p><a href="https://git-scm.com/book/zh/v2/服务器上的-Git-生成-SSH-公钥" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/服务器上的-Git-生成-SSH-公钥</a></p>
<p><a href="https://git-scm.com/book/zh/v2/GitHub-对项目做出贡献" target="_blank" rel="noopener">https://git-scm.com/book/zh/v2/GitHub-对项目做出贡献</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote add upstream [url] <span class="comment"># 将源版本库添加为一个远端，并命名为“upstream”（上游）</span></span><br><span class="line"></span><br><span class="line">git fetch upstream <span class="comment"># 从远端抓取最新的内容</span></span><br><span class="line"></span><br><span class="line">git merge upstream/master <span class="comment"># 将主分支的内容合并到你的分支中</span></span><br><span class="line"></span><br><span class="line">vim test.js <span class="comment"># 增删改查文件，推送</span></span><br><span class="line"></span><br><span class="line">git add test.js</span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'build: add test.js'</span></span><br><span class="line"></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>创建一个任务列表：</p>
<ul>
<li><input checked disabled type="checkbox"> 编写代码</li>
<li><input disabled type="checkbox"> 编写所有测试程序</li>
<li><input disabled type="checkbox"> 为代码编写文档</li>
</ul>
<h2 id="关于版本控制-VC"><a href="#关于版本控制-VC" class="headerlink" title="关于版本控制 VC"></a>关于版本控制 VC</h2><p>版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。</p>
<p>如果你是位图形或网页设计师，可能会需要保存某一幅图片或页面布局文件的所有修订版本（这或许是你非常渴望拥有的功能），采用版本控制系统（VCS）是个明智的选择。有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。使用版本控制系统通常还意味着，就算你乱来一气把整个项目中的文件改的改删的删，你也照样可以轻松恢复到原先的样子。但额外增加的工作量却微乎其微。</p>
<h3 id="本地版本控制系统-Local-Version-Control-Systems-LVCS"><a href="#本地版本控制系统-Local-Version-Control-Systems-LVCS" class="headerlink" title="本地版本控制系统 [Local Version Control Systems] LVCS"></a>本地版本控制系统 [Local Version Control Systems] LVCS</h3><p>复制整个项目，以改名加时间为备份。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. file-2018010101.md</span><br><span class="line">2. file-2018010102.md</span><br><span class="line">...</span><br><span class="line">3. file-2018010201.md</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。 甚至在流行的 Mac OS X 系统上安装了开发者工具包之后，也可以使用 rcs 命令。 它的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。</p>
<h3 id="集中化的版本控制系统-Centralized-Version-Control-Systems-CVCS"><a href="#集中化的版本控制系统-Centralized-Version-Control-Systems-CVCS" class="headerlink" title="集中化的版本控制系统 [Centralized Version Control Systems] CVCS"></a>集中化的版本控制系统 [Centralized Version Control Systems] CVCS</h3><p>如何让在不同系统上的开发者协同工作？CVCS 就产生了。</p>
<p>CVS、Subversion[svn] 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。</p>
<p>好处是相较于老式的本地 LVCS 可以进行协同开发。但缺点是中央服务器的单点故障。如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。</p>
<h3 id="分布式版本控制系统-Distributed-Version-Control-System-DVCS"><a href="#分布式版本控制系统-Distributed-Version-Control-System-DVCS" class="headerlink" title="分布式版本控制系统 [Distributed Version Control System] DVCS"></a>分布式版本控制系统 [Distributed Version Control System] DVCS</h3><p>为了应对这种问题，DVCS 就面世了。</p>
<p>Git、Mercurial、Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。</p>
<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><h3 id="存储每个文件与初始版本的差异"><a href="#存储每个文件与初始版本的差异" class="headerlink" title="存储每个文件与初始版本的差异"></a>存储每个文件与初始版本的差异</h3><p>Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流。</p>
<h3 id="Git-近乎所有操作都是本地执行"><a href="#Git-近乎所有操作都是本地执行" class="headerlink" title="Git 近乎所有操作都是本地执行"></a>Git 近乎所有操作都是本地执行</h3><p>在无网情况也可以进行提交，只需要等待有网再上传即可。</p>
<h3 id="Git-保证完整性"><a href="#Git-保证完整性" class="headerlink" title="Git 保证完整性"></a>Git 保证完整性</h3><p>Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。</p>
<p>Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来。</p>
<h3 id="三种状态"><a href="#三种状态" class="headerlink" title="三种状态"></a>三种状态</h3><p>Git 有三种状态，你的文件可能处于其中之一：已提交（committed）、已修改（modified）和已暂存（staged）。 已提交表示数据已经安全的保存在本地数据库中。 已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</p>
<h3 id="三个工作区域"><a href="#三个工作区域" class="headerlink" title="三个工作区域"></a>三个工作区域</h3><p>三个工作区域的概念：Git 仓库（Git Repository）、工作目录（Working Directory）以及暂存区域（Staging Area）。</p>
<p>push: 工作目录 -&gt; 暂存区域 -&gt; Git 仓库</p>
<p>clone/fetch/merge: Git 仓库 -&gt; 工作目录</p>
<p>Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。</p>
<p>工作目录是对项目的某个版本独立提取出来的内容。这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</p>
<p>暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作’索引’，不过一般说法还是叫暂存区域。</p>
<p>基本的 Git 工作流程如下：</p>
<ul>
<li><p>在工作目录中修改文件。</p>
</li>
<li><p>暂存文件，将文件的快照放入暂存区域。</p>
</li>
<li><p>提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</p>
</li>
</ul>
<h2 id="命令行"><a href="#命令行" class="headerlink" title="命令行"></a>命令行</h2><p>Mac OS 用户，使用 Terminal 或者 <a href="https://iterm2.com/" target="_blank" rel="noopener">iTerm2</a></p>
<p>Windows 用户，使用 <a href="https://gitforwindows.org/" target="_blank" rel="noopener">git-bash</a></p>
<h2 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h2><p>Mac OS 用户 <code>brew install git</code></p>
<p>Windows 用户 <code>http://git-scm.com/download/win</code></p>
<h2 id="初次运行前的配置"><a href="#初次运行前的配置" class="headerlink" title="初次运行前的配置"></a>初次运行前的配置</h2><p>Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置：</p>
<ul>
<li>/etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 –system 选项的 git config 时，它会从此文件读写配置变量。</li>
<li>~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 可以传递 –global 选项让 Git 读写此文件。</li>
<li>当前使用仓库的 Git 目录中的 config 文件（就是 .git/config）：针对该仓库。</li>
</ul>
<p><strong>每一个级别覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。</strong></p>
<h3 id="列出配置项"><a href="#列出配置项" class="headerlink" title="列出配置项"></a>列出配置项</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure>

<h3 id="修改或增加配置"><a href="#修改或增加配置" class="headerlink" title="修改或增加配置"></a>修改或增加配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name RainJoy</span><br><span class="line">git config --global user.email 1490079545@qq.com</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config user.name RainJoy</span><br><span class="line">git config user.email 1490079545@qq.com</span><br></pre></td></tr></table></figure>

<h3 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git --<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">git <span class="built_in">help</span> xxxx</span><br></pre></td></tr></table></figure>

<h2 id="获取-git-仓库"><a href="#获取-git-仓库" class="headerlink" title="获取 git 仓库"></a>获取 git 仓库</h2><p>有两种取得 Git 项目仓库的方法。</p>
<p>第一种是：生成。在现有项目或目录下导入所有文件到 Git 中。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git init</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git add LICENSE <span class="comment"># 增加证书</span></span><br><span class="line"></span><br><span class="line">git commit -m <span class="string">'init'</span></span><br><span class="line"></span><br><span class="line">git remote add origin git@github.com:zhouyu1993/zhouyu1993.github.io.git</span><br><span class="line"></span><br><span class="line">git push --<span class="built_in">set</span>-upstream origin master</span><br></pre></td></tr></table></figure>

<p>第二种是：克隆。从一个服务器克隆一个现有的 Git 仓库。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:zhouyu1993/zhouyu1993.github.io.git</span><br></pre></td></tr></table></figure>

<h2 id="git-clone-url"><a href="#git-clone-url" class="headerlink" title="git clone [url]"></a>git clone [url]</h2><p>克隆远程 Git 仓库</p>
<p><code>Git</code> 支持许多数据传输协议。之前的例子使用的是 <code>git://</code> 协议，不过你也可以用 <code>http(s)://</code> 或者 <code>user@server:/path.git</code> 表示的 <code>SSH</code> 传输协议。</p>
<p>使用 <code>git://</code> 协议或者 <code>SSH</code> 传输协议，更安全！</p>
<blockquote>
<p>git@[host]:[user-name]/[project-name].git</p>
</blockquote>
<p>使用 <code>http(s)://</code> 协议</p>
<blockquote>
<p>https://[host]/[user-name]/[project-name].git</p>
</blockquote>
<h2 id="检测当前文件状态"><a href="#检测当前文件状态" class="headerlink" title="检测当前文件状态"></a>检测当前文件状态</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git status -s</span><br></pre></td></tr></table></figure>

<h2 id="查看已暂存和未暂存的修改（具体修改了什么地方）"><a href="#查看已暂存和未暂存的修改（具体修改了什么地方）" class="headerlink" title="查看已暂存和未暂存的修改（具体修改了什么地方）"></a>查看已暂存和未暂存的修改（具体修改了什么地方）</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git diff</span><br><span class="line"></span><br><span class="line">git diff [filename]</span><br></pre></td></tr></table></figure>

<h2 id="撤销文件的修改"><a href="#撤销文件的修改" class="headerlink" title="撤销文件的修改"></a>撤销文件的修改</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 撤销单个文件</span></span><br><span class="line"></span><br><span class="line">git checkout [filename]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 撤销所有</span></span><br><span class="line"></span><br><span class="line">git checkout .</span><br></pre></td></tr></table></figure>

<h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><p><a href="https://help.github.com/articles/ignoring-files/" target="_blank" rel="noopener">.gitignore 文件</a></p>
<p>文件 .gitignore 的格式规范如下：</p>
<ul>
<li>所有空行或者以 ＃ 开头的行都会被 Git 忽略。</li>
<li>可以使用标准的 glob 模式匹配。</li>
<li>匹配模式可以以（/）开头防止递归。</li>
<li>匹配模式可以以（/）结尾指定目录。</li>
<li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">touch .gitignore</span><br></pre></td></tr></table></figure>

<h2 id="查看库的整体提交记录"><a href="#查看库的整体提交记录" class="headerlink" title="查看库的整体提交记录"></a>查看库的整体提交记录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure>

<h2 id="从库中删除对某文件的控制"><a href="#从库中删除对某文件的控制" class="headerlink" title="从库中删除对某文件的控制"></a>从库中删除对某文件的控制</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rm --cached [filename]</span><br></pre></td></tr></table></figure>

<h2 id="查看库的远程地址"><a href="#查看库的远程地址" class="headerlink" title="查看库的远程地址"></a>查看库的远程地址</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure>

<h2 id="将本地项目提交到远程仓库"><a href="#将本地项目提交到远程仓库" class="headerlink" title="将本地项目提交到远程仓库"></a>将本地项目提交到远程仓库</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将所有修改过的工作文件提交暂存区</span></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line"><span class="comment"># 填写提交信息(message)</span></span><br><span class="line">git commit -m <span class="string">'message'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改提交信息(message)</span></span><br><span class="line">git commit --amend</span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传</span></span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<h2 id="将远程仓库更新到本地项目"><a href="#将远程仓库更新到本地项目" class="headerlink" title="将远程仓库更新到本地项目"></a>将远程仓库更新到本地项目</h2><h3 id="推荐-fetch-merge"><a href="#推荐-fetch-merge" class="headerlink" title="推荐 fetch + merge"></a>推荐 fetch + merge</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git fetch <span class="comment"># 默认更新所有分支</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git merge <span class="comment"># 合并冲突</span></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>

<h2 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打上标签并写备注信息</span></span><br><span class="line">git tag -l</span><br><span class="line"></span><br><span class="line">git tag -a v0.1.0 -m <span class="string">"修改网页风格，打标签 2017/04/27"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上传</span></span><br><span class="line">git push origin --tags</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除本地标签</span></span><br><span class="line">git tag -d v0.1.0</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除远程标签</span></span><br><span class="line">git push origin :refs/tags/v0.0.1</span><br></pre></td></tr></table></figure>

<h2 id="分支创建与合并"><a href="#分支创建与合并" class="headerlink" title="分支创建与合并"></a>分支创建与合并</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 本地创建新分支</span></span><br><span class="line">git branch [branche-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到分支</span></span><br><span class="line">git checkout [branche-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将第一次建立的新分支上传到远程仓库</span></span><br><span class="line">git add.</span><br><span class="line">git commit -m <span class="string">'add branche-name'</span></span><br><span class="line">git push --<span class="built_in">set</span>-upstream origin [branche-name]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切回主支</span></span><br><span class="line">git checkout master</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将分支合并到主支</span></span><br><span class="line">git merge [branche-name]</span><br></pre></td></tr></table></figure>

<h2 id="管理分支"><a href="#管理分支" class="headerlink" title="管理分支"></a>管理分支</h2><h3 id="查看当前分支信息"><a href="#查看当前分支信息" class="headerlink" title="查看当前分支信息"></a>查看当前分支信息</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -v</span><br></pre></td></tr></table></figure>

<h3 id="列出所有分支【本地和远程】"><a href="#列出所有分支【本地和远程】" class="headerlink" title="列出所有分支【本地和远程】"></a>列出所有分支【本地和远程】</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -a</span><br></pre></td></tr></table></figure>

<h3 id="拉取远程分支"><a href="#拉取远程分支" class="headerlink" title="拉取远程分支"></a>拉取远程分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b [branche-name] origin/[branche-name]</span><br></pre></td></tr></table></figure>

<h3 id="删除本地分支"><a href="#删除本地分支" class="headerlink" title="删除本地分支"></a>删除本地分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git branch -d [branche-name]</span><br></pre></td></tr></table></figure>

<h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push origin -d [branche-name]</span><br></pre></td></tr></table></figure>

<h1 id="提交空目录的方法"><a href="#提交空目录的方法" class="headerlink" title="提交空目录的方法"></a>提交空目录的方法</h1><p>只需要在目录下创建 .gitkeep 文件，然后在项目的 .gitignore 中设置不忽略 .gitkeep</p>
<h1 id="让-git-对文件大小写敏感"><a href="#让-git-对文件大小写敏感" class="headerlink" title="让 git 对文件大小写敏感"></a>让 git 对文件大小写敏感</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config core.ignorecase <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<h1 id="配置-SSH"><a href="#配置-SSH" class="headerlink" title="配置 SSH"></a>配置 SSH</h1><p><a href="https://gitlab.com/help/ssh/README" target="_blank" rel="noopener">ssh</a></p>
<ul>
<li><p>1.检查本机是否有 SSH key</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br></pre></td></tr></table></figure>

<p>如果 <code>.ssh</code> No such file or directory</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~</span><br><span class="line"></span><br><span class="line">mkdir .ssh</span><br><span class="line"></span><br><span class="line"><span class="comment"># 接 2</span></span><br></pre></td></tr></table></figure>

<p>如果正常进入, 查看是否有 <code>*_rsa.pub</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ls -a <span class="comment"># 或 ll -a</span></span><br></pre></td></tr></table></figure>

<p>如果无, 则清空</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rm *</span><br><span class="line"><span class="comment"># 接 2</span></span><br></pre></td></tr></table></figure>

<p>如果有，检查是否可用, 接 3</p>
</li>
<li><p>2.重新设置 SSH sey</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> ~/.ssh</span><br><span class="line"><span class="comment"># 填写库的登陆邮箱</span></span><br><span class="line">ssh-keygen -t rsa -C <span class="string">'1490079545@qq.com'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 有结果如下：</span></span><br><span class="line">Enter file <span class="keyword">in</span> <span class="built_in">which</span> to save the key (/c/Users/Administrator/.ssh/id_rsa): <span class="comment">#可不填直接回车# #如果填写，则重命名，例如 xiaomi_rsa</span></span><br><span class="line">Created directory <span class="string">'/c/Users/Administrator/.ssh'</span>. <span class="comment">#创建id_rsa#</span></span><br><span class="line">Enter passphrase (empty <span class="keyword">for</span> no passphrase): <span class="comment">#可不填直接回车# #如果填写则是密码</span></span><br><span class="line">Enter same passphrase again: <span class="comment">#可不填直接回车# #如果填写则是密码</span></span><br><span class="line">Your identification has been saved <span class="keyword">in</span> /c/Users/Administrator/.ssh/id_rsa. <span class="comment">#保存id_rsa#</span></span><br><span class="line">Your public key has been saved <span class="keyword">in</span> /c/Users/Administrator/.ssh/id_rsa.pub. <span class="comment">#创建id_rsa.pub#</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置 git</span></span><br><span class="line">git config --global user.name <span class="string">'RainJoy'</span> <span class="comment">#name#</span></span><br><span class="line">git config --global user.email <span class="string">'1490079545@qq.com'</span> <span class="comment">#email#</span></span><br><span class="line">git config --list</span><br></pre></td></tr></table></figure>
</li>
<li><p>3.在库的 Settings &gt; SSH key 对应 key 填写位置填写生成的 SSH key</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 复制 id_rsa.pub 内容，填写到相应位置</span></span><br><span class="line">cat ~/.ssh/id_rsa.pub</span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">pbcopy &lt; ~/.ssh/id_rsa.pub <span class="comment"># 复制文件内容</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>4.测试 SSH key 是否设置成功</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有结果如下：</span></span><br><span class="line">Are you sure you want to <span class="built_in">continue</span> connecting (yes/no)? <span class="comment"># 这里一定输入 yes 不能直接回车，不然会报 Host key verification failed.</span></span><br><span class="line">Enter passphrase <span class="keyword">for</span> key <span class="string">'/Users/xxx/.ssh/*_rsa'</span>: <span class="comment"># 输入设置的密码</span></span><br><span class="line"></span><br><span class="line">ssh -T git@gitlab.com</span><br><span class="line"></span><br><span class="line"><span class="comment"># 有结果如下：</span></span><br><span class="line">Are you sure you want to <span class="built_in">continue</span> connecting (yes/no)? <span class="comment"># 这里一定输入 yes 不能直接回车，不然会报 Host key verification failed.</span></span><br><span class="line">Enter passphrase <span class="keyword">for</span> key <span class="string">'/Users/xxx/.ssh/*_rsa'</span>: <span class="comment"># 输入设置的密码</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>以 SSH key 方式下载项目即可</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:zhouyu1993/zhouyu1993.github.io.git</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p><a href="https://daemon369.github.io/ssh/2015/03/21/using-ssh-config-file" target="_blank" rel="noopener">https://daemon369.github.io/ssh/2015/03/21/using-ssh-config-file</a></p>
<h1 id="LICENSE-开源许可证"><a href="#LICENSE-开源许可证" class="headerlink" title="LICENSE 开源许可证"></a>LICENSE 开源许可证</h1><p><a href="http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html</a></p>
<p>MIT 或 Apache</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>管理工具</tag>
      </tags>
  </entry>
  <entry>
    <title>upload组件</title>
    <url>/zh/2019/12/04/upload%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<p>upload组件</p>
<a id="more"></a>

<h2 id="代码解析"><a href="#代码解析" class="headerlink" title="代码解析"></a>代码解析</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">class</span>=<span class="string">"kfcv-upload"</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">:accept</span>=<span class="string">"accept"</span> <span class="attr">:capture</span>=<span class="string">"capture"</span> <span class="attr">:multiple</span>=<span class="string">"multiple"</span> @<span class="attr">change</span>=<span class="string">"onChange"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  props: &#123;</span><br><span class="line">    <span class="comment">// 设置可选文件类型, 默认图片 image/*, 其他值如视频 video/*, 音频 audio/* 等, 如果设置多值以逗号分割, 即 'image/*, video/*'</span></span><br><span class="line">    accept: &#123;</span><br><span class="line">      type: <span class="built_in">String</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="string">'image/*'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 捕获机制（有兼容问题）, 默认 false, 其他值如 camera 捕获相机, camcorder 捕获摄像, microphone 捕获录音</span></span><br><span class="line">    capture: &#123;</span><br><span class="line">      type: [<span class="built_in">Boolean</span>, <span class="built_in">String</span>],</span><br><span class="line">      <span class="keyword">default</span>: <span class="literal">false</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 是否支持多选, 默认 true, multiple 优先级高于 capture, 即当 multiple 为 true 时默认从相册选</span></span><br><span class="line">    multiple: &#123;</span><br><span class="line">      type: <span class="built_in">Boolean</span>,</span><br><span class="line">      <span class="keyword">default</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  onChange (e) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">typeof</span> FileReader === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.error(<span class="string">'您的浏览器不支持文件上传'</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// fileList -&gt; fileArray</span></span><br><span class="line">        <span class="keyword">const</span> files = [...e.target.files]</span><br><span class="line"></span><br><span class="line">        files.forEach(<span class="function"><span class="params">file</span> =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">const</span> &#123; type, &#125; = file</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (<span class="regexp">/image/i</span>.test(type)) &#123;</span><br><span class="line">            <span class="comment">// 图片</span></span><br><span class="line">            <span class="keyword">this</span>.handleImage(file)</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/video/i</span>.test(type)) &#123;</span><br><span class="line">            <span class="comment">// 视频</span></span><br><span class="line">            <span class="keyword">this</span>.handleVideo(file)</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="regexp">/audio/i</span>.test(type)) &#123;</span><br><span class="line">            <span class="comment">// 音频</span></span><br><span class="line">            <span class="keyword">this</span>.handleAudio(file)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  handleImage (file) &#123;</span><br><span class="line">    <span class="comment">// 读取图片 fileObj -&gt; base64Url</span></span><br><span class="line">    <span class="keyword">this</span>.readAsDataURL(file)</span><br><span class="line">  &#125;,</span><br><span class="line">  uploadImage (formData) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> xhr = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line"></span><br><span class="line">      xhr.timeout = <span class="number">5000</span></span><br><span class="line">      xhr.responseType = <span class="string">'json'</span></span><br><span class="line"></span><br><span class="line">      xhr.open(<span class="string">'POST'</span>, uploadUrl)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (<span class="regexp">/mobile/i</span>.test(navigator.userAgent)) &#123;</span><br><span class="line">        <span class="comment">// 移动端给个虚假 progress</span></span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'uploadProgress: '</span>, <span class="number">0.5</span>, <span class="string">'上传中'</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// PC 端支持 onprogress</span></span><br><span class="line">        xhr.upload.onprogress = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (e.lengthComputable) &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'uploadProgress: '</span>, e.loaded / e.total, <span class="string">'上传中'</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      xhr.onload = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> &#123; status, response &#125; = e.target</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((status &gt;= <span class="number">200</span> &amp;&amp; status &lt; <span class="number">300</span>) || status === <span class="number">304</span>) &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'uploadProgress: '</span>, <span class="number">1</span>, <span class="string">'上传成功'</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="built_in">console</span>.log(<span class="string">'uploadProgress: '</span>, <span class="number">0</span>, <span class="string">'上传失败'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      xhr.onerror = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'uploadProgress: '</span>, <span class="number">0</span>, <span class="string">'上传失败'</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      xhr.ontimeout = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e)</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'uploadProgress: '</span>, <span class="number">0</span>, <span class="string">'上传超时'</span>)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      xhr.send(formData)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  readAsDataURL (file) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> reader = <span class="keyword">new</span> FileReader()</span><br><span class="line"></span><br><span class="line">      reader.onload = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">const</span> base64Url = e.target.result</span><br><span class="line"></span><br><span class="line">        <span class="built_in">console</span>.log(base64Url)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理图片 base64Url -&gt; canvas -&gt; base64Url -&gt; blob</span></span><br><span class="line">        <span class="keyword">this</span>.processImage(file, base64Url)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      reader.onerror = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      reader.readAsDataURL(file)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  processImage (file, base64Url) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> img = <span class="keyword">new</span> Image()</span><br><span class="line"></span><br><span class="line">      img.src = base64Url</span><br><span class="line"></span><br><span class="line">      img.onload = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="comment">// 获取图片原始宽高</span></span><br><span class="line">        <span class="keyword">const</span> width = img.width</span><br><span class="line">        <span class="keyword">const</span> height = img.height</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理图片 base64Url -&gt; canvas</span></span><br><span class="line">        <span class="keyword">const</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>)</span><br><span class="line">        canvas.width = width</span><br><span class="line">        canvas.height = height</span><br><span class="line">        <span class="keyword">const</span> ctx = canvas.getContext(<span class="string">'2d'</span>)</span><br><span class="line">        ctx.fillStyle = <span class="string">'#fff'</span></span><br><span class="line">        ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, width, height)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取图片信息 exif</span></span><br><span class="line">        <span class="keyword">const</span> imgObj = &#123;</span><br><span class="line">          src: base64Url</span><br><span class="line">        &#125;</span><br><span class="line">        exif.getData(imgObj, () =&gt; &#123;</span><br><span class="line">          <span class="comment">// 根据 Orientation 调整图片角度</span></span><br><span class="line">          <span class="keyword">const</span> orientation = imgObj.exifdata.Orientation</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 1 横着, 3 右斜, 6 左斜, 8 倒着</span></span><br><span class="line">          <span class="keyword">if</span> (orientation &amp;&amp; orientation !== <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (orientation) &#123;</span><br><span class="line">              <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">                <span class="comment">// 8 倒着, 需要逆时针（向左）90 度旋转，并交换宽高</span></span><br><span class="line">                canvas.width = height</span><br><span class="line">                canvas.height = width</span><br><span class="line">                ctx.rotate(<span class="number">-0.5</span> * <span class="built_in">Math</span>.PI)</span><br><span class="line">                ctx.translate(<span class="number">-1</span> * width, <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">              <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                <span class="comment">// 6 左斜或横着, 需要顺时针（向右）90 度旋转</span></span><br><span class="line">                canvas.width = height</span><br><span class="line">                canvas.height = width</span><br><span class="line">                ctx.rotate(<span class="number">0.5</span> * <span class="built_in">Math</span>.PI)</span><br><span class="line">                ctx.translate(<span class="number">0</span>, <span class="number">-1</span> * height)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">              <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                <span class="comment">// 3 右斜, 需要顺时针（向右）180 度旋转</span></span><br><span class="line">                ctx.rotate(<span class="built_in">Math</span>.PI)</span><br><span class="line">                ctx.translate(<span class="number">-1</span> * width, <span class="number">-1</span> * height)</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">              <span class="keyword">default</span>:</span><br><span class="line">                ctx.rotate(<span class="number">0</span>)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          ctx.drawImage(img, <span class="number">0</span>, <span class="number">0</span>, width, height, <span class="number">0</span>, <span class="number">0</span>, width, height)</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 缩小图片</span></span><br><span class="line">          <span class="keyword">const</span> w = <span class="built_in">Math</span>.min(canvas.width, <span class="number">1000</span>)</span><br><span class="line">          <span class="keyword">const</span> h = canvas.height / canvas.width * w</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 缩小图片需要重绘</span></span><br><span class="line">          <span class="keyword">const</span> _canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>)</span><br><span class="line">          _canvas.width = w</span><br><span class="line">          _canvas.height = h</span><br><span class="line">          <span class="keyword">const</span> _ctx = _canvas.getContext(<span class="string">'2d'</span>)</span><br><span class="line">          _ctx.fillStyle = <span class="string">'#fff'</span></span><br><span class="line">          _ctx.fillRect(<span class="number">0</span>, <span class="number">0</span>, w, h)</span><br><span class="line">          _ctx.drawImage(canvas, <span class="number">0</span>, <span class="number">0</span>, canvas.width, canvas.height, <span class="number">0</span>, <span class="number">0</span>, w, h)</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 压缩图片 canvas -&gt; base64Url</span></span><br><span class="line">          <span class="keyword">const</span> _base64Url = _canvas.toDataURL(file.type, <span class="number">0.9</span>)</span><br><span class="line"></span><br><span class="line">          setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="comment">// base64Url -&gt; blob</span></span><br><span class="line">            <span class="keyword">this</span>.dataURL2Blob(file, _base64Url)</span><br><span class="line">          &#125;, <span class="number">0</span>)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      img.onerror = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(e)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  dataURL2Blob (file, base64Url) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// base64Url -&gt; buffer</span></span><br><span class="line">      <span class="keyword">let</span> byteStr</span><br><span class="line">      <span class="keyword">const</span> parts = base64Url.split(<span class="string">','</span>)</span><br><span class="line">      <span class="keyword">if</span> (parts[<span class="number">0</span>].indexOf(<span class="string">'base64'</span>) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        byteStr = atob(parts[<span class="number">1</span>])</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        byteStr = <span class="built_in">decodeURIComponent</span>(parts[<span class="number">1</span>])</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> leng = byteStr.length</span><br><span class="line">      <span class="keyword">const</span> buffer = <span class="keyword">new</span> <span class="built_in">ArrayBuffer</span>(leng)</span><br><span class="line">      <span class="keyword">const</span> uint8 = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(buffer)</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; leng; i += <span class="number">1</span>) &#123;</span><br><span class="line">        uint8[i] = byteStr.charCodeAt(i)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">const</span> type = parts[<span class="number">0</span>].split(<span class="string">':'</span>)[<span class="number">1</span>].split(<span class="string">';'</span>)[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">      <span class="comment">// buffer -&gt; blob</span></span><br><span class="line">      <span class="keyword">let</span> blob</span><br><span class="line">      <span class="keyword">const</span> Builder = <span class="built_in">window</span>.BlobBuilder || <span class="built_in">window</span>.WebKitBlobBuilder</span><br><span class="line">      <span class="keyword">if</span> (Builder) &#123;</span><br><span class="line">        <span class="comment">// android 不支持 new Blob, 只能借助 window.BlobBuilder || window.WebKitBlobBuilder</span></span><br><span class="line">        <span class="keyword">const</span> bb = <span class="keyword">new</span> Builder()</span><br><span class="line">        bb.append(buffer)</span><br><span class="line">        blob = bb.getBlob(type)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ios</span></span><br><span class="line">        blob = <span class="keyword">new</span> Blob([buffer], type ? &#123; type &#125; : &#123;&#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">this</span>.blob2FormData(file, blob)</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  blob2FormData (file, blob) &#123;</span><br><span class="line">    <span class="keyword">const</span> formData = <span class="keyword">new</span> FormData()</span><br><span class="line">    formData.append(<span class="string">'file'</span>, blob, file.name)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 上传图片</span></span><br><span class="line">    <span class="keyword">this</span>.uploadImage(formData)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="具体解析"><a href="#具体解析" class="headerlink" title="具体解析"></a>具体解析</h2><ul>
<li>input 属性<ul>
<li>accept</li>
<li>capture</li>
<li>multiple</li>
</ul>
</li>
<li>change 事件</li>
<li>fileList -&gt; fileArray</li>
<li>FileReader 读取图片 fileObj -&gt; base64Url</li>
<li>base64Url -&gt; canvas</li>
<li>canvas 操作，缩放，裁剪，翻转，压缩，等等</li>
<li>canvas -&gt; base64Url</li>
<li>base64Url -&gt; blob</li>
<li>blob -&gt; formData</li>
<li>formData 的 xhr 上传</li>
<li><a href="https://github.com/exif-js/exif-js" target="_blank" rel="noopener">exif-js</a></li>
</ul>
<h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><p><a href="https://huodong.cekid.com/hd/order/14471393830/comment?cmd=share&sharetype=0&isMiniProgram=false" target="_blank" rel="noopener">孩子王-活动系统</a></p>
<h2 id="竞品对比"><a href="#竞品对比" class="headerlink" title="竞品对比"></a>竞品对比</h2><p><a href="https://github.com/iview/iview/blob/2.0/src/components/upload/upload.vue" target="_blank" rel="noopener">iview-upload</a></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx</title>
    <url>/zh/2019/06/03/nginx%E7%9B%B8%E5%85%B3/</url>
    <content><![CDATA[<p>不同系统中nginx的安装与使用。</p>
<p>包括：MacOS、linux、windows 等。</p>
<a id="more"></a>

<h1 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h1><h2 id="安装-nginx"><a href="#安装-nginx" class="headerlink" title="安装 nginx"></a>安装 nginx</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># First update the formulae and Homebrew itself:</span></span><br><span class="line">brew update</span><br><span class="line"></span><br><span class="line"><span class="comment"># You can now find out what is outdated with:</span></span><br><span class="line">brew outdated</span><br><span class="line"></span><br><span class="line"><span class="comment"># Upgrade everything with:</span></span><br><span class="line">brew upgrage</span><br><span class="line"></span><br><span class="line"><span class="comment"># Check nginx information to see if it is installed:</span></span><br><span class="line">brew search nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># Install nginx</span></span><br><span class="line">brew install nginx</span><br></pre></td></tr></table></figure>

<p>安装完成后，</p>
<p>nginx 目录在 <code>/usr/local/Cellar/nginx</code></p>
<p>nginx 的主页文件在 <code>/usr/local/var/www</code></p>
<p>nginx 的日志文件在 <code>/usr/local/var/log/nginx</code></p>
<p>nginx 的配置文件在 <code>/usr/local/etc/nginx/nginx.conf</code></p>
<h2 id="使用-nginx"><a href="#使用-nginx" class="headerlink" title="使用 nginx"></a>使用 nginx</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看使用 brew 安装的服务列表（包括服务状态）</span></span><br><span class="line">brew services list</span><br><span class="line"></span><br><span class="line"><span class="comment"># 清除已卸载应用的无用的配置</span></span><br><span class="line">brew services cleanup</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 80 端口</span></span><br><span class="line">lsof -i:80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 nginx 服务，并注册</span></span><br><span class="line">brew services start nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 停止 nginx 服务，并取消注册</span></span><br><span class="line">brew services stop nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重启 nginx 服务，并注册</span></span><br><span class="line">brew services restart nginx</span><br></pre></td></tr></table></figure>

<p>注意，这里不要使用 <code>nginx</code> 命令来启动 nginx 服务，这样不方便停止。</p>
<p>nginx 配置等详细见下面 <code>2.4. 使用nginx</code>。</p>
<h1 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h1><h2 id="linux-常用命令"><a href="#linux-常用命令" class="headerlink" title="linux 常用命令"></a>linux 常用命令</h2><ul>
<li><p>ls: 列出目录</p>
</li>
<li><p>cd: 切换目录</p>
</li>
<li><p>pwd: 显示目前的目录</p>
</li>
<li><p>mkdir: 创建一个新的目录</p>
</li>
<li><p>cp: 复制文件或目录</p>
</li>
<li><p>rm: 移除文件或目录</p>
</li>
<li><p>mv: 移动文件与目录，或修改文件与目录的名称</p>
</li>
<li><p>cat: 由第一行开始显示文件内容</p>
</li>
<li><p>nl: 显示的时候，顺道输出行号！</p>
</li>
<li><p>more: 一页一页的显示文件内容</p>
</li>
<li><p>less: 与 more 类似，但是比 more 更好的是，他可以往前翻页！</p>
</li>
<li><p>head: 只看头几行</p>
</li>
<li><p>tail: 只看尾巴几行</p>
</li>
<li><p>touch: 创建空白文档</p>
</li>
<li><p>vi: 创建一个编辑状态的空文档，只有保存退出后才创建成功，文件属性与 touch 创建的相同</p>
</li>
<li><p>vim: vi 的升级版本</p>
</li>
</ul>
<p><a href="https://www.runoob.com/linux/linux-command-manual.html" target="_blank" rel="noopener">linux 命令大全</a></p>
<h2 id="在终端利用-ssh-登录远程服务器"><a href="#在终端利用-ssh-登录远程服务器" class="headerlink" title="在终端利用 ssh 登录远程服务器"></a>在终端利用 ssh 登录远程服务器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 登录</span></span><br><span class="line">ssh -p [服务器port] [userName]@[服务器ip]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入密码</span></span><br></pre></td></tr></table></figure>

<h2 id="安装-nginx-1"><a href="#安装-nginx-1" class="headerlink" title="安装 nginx"></a>安装 nginx</h2><p><a href="https://nginx.org/en/linux_packages.html" target="_blank" rel="noopener">linux packages</a></p>
<p>需要根据 <code>linux</code> 的版本选择对应的包</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 打印当前系统相关信息（操作系统名称、在网络上的主机名称、操作系统的发行编号、操作系统的版本、处理器类型、硬件平台、电脑类型、操作系统名称等）</span></span><br><span class="line">uname -a</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看操作系统的标识文件</span></span><br><span class="line">cat /etc/*-release</span><br></pre></td></tr></table></figure>

<p>发现是 CentOS 7</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看机器的 ip</span></span><br><span class="line">ifconfig</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看机器是否能访问外网</span></span><br><span class="line">curl -l https://www.baidu.com</span><br><span class="line"></span><br><span class="line">wget https://www.baidu.com</span><br><span class="line"></span><br><span class="line">ping baidu.com</span><br></pre></td></tr></table></figure>

<h3 id="如果机器能访问外网："><a href="#如果机器能访问外网：" class="headerlink" title="如果机器能访问外网："></a>如果机器能访问外网：</h3><p><code>Install the prerequisites:</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum update &amp;&amp; yum install yum-utils</span><br></pre></td></tr></table></figure>

<p>To set up the yum repository, create the file named <code>/etc/yum.repos.d/nginx.repo</code> with the following contents:</p>
<blockquote>
<p>[nginx-stable]<br>name=nginx stable repo<br>baseurl=<a href="http://nginx.org/packages/centos/$releasever/$basearch/" target="_blank" rel="noopener">http://nginx.org/packages/centos/$releasever/$basearch/</a><br>gpgcheck=1<br>enabled=1<br>gpgkey=<a href="https://nginx.org/keys/nginx_signing.key" target="_blank" rel="noopener">https://nginx.org/keys/nginx_signing.key</a></p>
</blockquote>
<blockquote>
<p>[nginx-mainline]<br>name=nginx mainline repo<br>baseurl=<a href="http://nginx.org/packages/mainline/centos/$releasever/$basearch/" target="_blank" rel="noopener">http://nginx.org/packages/mainline/centos/$releasever/$basearch/</a><br>gpgcheck=1<br>enabled=0<br>gpgkey=<a href="https://nginx.org/keys/nginx_signing.key" target="_blank" rel="noopener">https://nginx.org/keys/nginx_signing.key</a></p>
</blockquote>
<p>By default, the repository for stable nginx packages is used. If you would like to use mainline nginx packages, run the following command:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum-config-manager --<span class="built_in">enable</span> nginx-mainline</span><br></pre></td></tr></table></figure>

<p>To install nginx, run the following command:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install nginx</span><br></pre></td></tr></table></figure>

<h3 id="如果机器不能访问外网："><a href="#如果机器不能访问外网：" class="headerlink" title="如果机器不能访问外网："></a>如果机器不能访问外网：</h3><p>本地安装 <code>PCRE</code> 和 <code>Nginx</code> ：</p>
<p><code>PCRE</code> 作用是让 <code>Nginx</code> 支持 <code>Rewrite</code> 功能。</p>
<ol>
<li>下载 <code>PCRE</code> 安装包，下载地址：<a href="https://sourceforge.net/projects/pcre/files/pcre/" target="_blank" rel="noopener">https://sourceforge.net/projects/pcre/files/pcre/</a></li>
</ol>
<p>选择最新的 <code>zip</code> 包，例如：<a href="http://downloads.sourceforge.net/project/pcre/pcre/8.43/pcre-8.43.tar.gz" target="_blank" rel="noopener">http://downloads.sourceforge.net/project/pcre/pcre/8.43/pcre-8.43.tar.gz</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://downloads.sourceforge.net/project/pcre/pcre/8.43/pcre-8.43.tar.gz</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>下载 <code>Nginx</code> 安装包，下载地址：<a href="http://nginx.org/en/download.html" target="_blank" rel="noopener">http://nginx.org/en/download.html</a></li>
</ol>
<p>选择最新的 <code>zip</code> 包，例如：<a href="http://nginx.org/download/nginx-1.17.0.tar.gz" target="_blank" rel="noopener">http://nginx.org/download/nginx-1.17.0.tar.gz</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget http://nginx.org/download/nginx-1.17.0.tar.gz</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>使用 <code>ssh</code> 上传 <code>PCRE</code> 和 <code>Nginx</code> 的安装包</li>
</ol>
<p>如果已知服务器密码，在本地：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r [本地文件路径] [userName]@[服务器ip]/[服务器文件路径]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入密码</span></span><br></pre></td></tr></table></figure>

<p>如果未知服务器密码，在服务器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">scp -r [userName]@[本地ip]/[本地文件路径] [服务器文件路径]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输入密码</span></span><br></pre></td></tr></table></figure>

<p>当然，未知服务器密码时，需要本地开启 <code>ssh</code>。下面给出 <code>MacOS</code> 开启 <code>ssh</code> 服务的方法：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemsetup -getremotelogin <span class="comment"># 查看 ssh 服务状态</span></span><br><span class="line"></span><br><span class="line">sudo systemsetup -setremotelogin on <span class="comment"># 开启 ssh 服务</span></span><br><span class="line"></span><br><span class="line">sudo systemsetup -setremotelogin off <span class="comment"># 关闭 ssh 服务</span></span><br></pre></td></tr></table></figure>

<p>或者 <code>系统偏好设置 -&gt; 共享 -&gt; 远程登录</code></p>
<ol start="4">
<li>解压 <code>pcre</code> 安装包并编译安装</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入刚刚上传安装包的文件目录，自定义。这里选择 /usr/local/src</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压 pcre</span></span><br><span class="line">tar -zxvf pcre-8.43.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译安装 pcre</span></span><br><span class="line"><span class="built_in">cd</span> pcre-8.43</span><br><span class="line"></span><br><span class="line">./configure</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 pcre 版本</span></span><br><span class="line">pcre-config --version</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>解压 <code>nginx</code> 安装包并编译安装</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 进入刚刚上传安装包的文件目录，自定义。这里选择 /usr/local/src</span></span><br><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/src</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解压 nginx</span></span><br><span class="line">tar -zxvf nginx-1.17.0.tar.gz</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看是否存在 openssl</span></span><br><span class="line"><span class="built_in">which</span> openssl</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编译安装 nginx</span></span><br><span class="line"><span class="built_in">cd</span> nginx-1.17.0</span><br><span class="line"></span><br><span class="line">./configure --with-http_stub_status_module --with-http_ssl_module --with-pcre=/usr/<span class="built_in">local</span>/src/pcre-8.43</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 nginx 版本</span></span><br><span class="line">/usr/<span class="built_in">local</span>/nginx/sbin/nginx -v</span><br></pre></td></tr></table></figure>

<p><code>nginx</code> 编译选项：</p>
<ul>
<li>–prefix=path 定义一个目录，存放服务器上的文件，也就是 nginx 的安装目录。默认为 <code>/usr/local/nginx</code>。</li>
<li>–sbin-path=path 设置 nginx 的可执行文件的路径，默认为 <code>*prefix*/sbin/nginx</code>。</li>
<li>–conf-path=path 设置 nginx.conf 文件的路径。默认为 <code>*prefix*/conf/nginx.conf</code>。</li>
<li>–pid-path=path 设置 nginx.pid 文件的路径。安装完成后，可以随时改变的文件名，在 nginx.conf 配置文件中使用 PID 指令。默认为 <code>*prefix*/logs/nginx.pid</code>。</li>
<li>–error-log-path=path 设置主错误、警告和诊断文件的路径。安装完成后，可以随时改变的文件名，在 nginx.conf 配置文件中使用 error_log 指令。默认为 <code>*prefix*/logs/error.log</code>。</li>
<li>–http-log-path=path 设置主请求的 HTTP 服务器的日志文件的路径。安装完成后，可以随时改变的文件名，在nginx.conf 配置文件中使用 access_log 指令。默认为 <code>*prefix*/logs/access.log</code>。</li>
<li>–with-http_stub_status_module 开启 <code>stub_status</code> 模块监控，查看 <code>Nginx</code> 的一些状态信息。</li>
<li>–with-http_ssl_module 使用 <code>https</code> 协议模块。默认情况下，该模块没有被构建。建立并运行此模块的 <code>openssl</code> 库是必需的。</li>
<li>–with-pcre=path 设置 <code>PCRE</code> 库的源码路径。让 <code>Nginx</code> 支持 <code>Rewrite</code> 功能。</li>
</ul>
<ol start="5">
<li>将 <code>nginx</code> 命令添加到 <code>PATH</code> 中</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 修改 /etc/profile</span></span><br><span class="line">vi /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 找到 export 行，在下面新增加一行，内容为：</span></span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/usr/<span class="built_in">local</span>/webserver/nginx/sbin</span><br><span class="line"></span><br><span class="line"><span class="comment"># 保持并退出：</span></span><br><span class="line">:wq</span><br><span class="line"></span><br><span class="line"><span class="comment"># 立即生效</span></span><br><span class="line"><span class="built_in">source</span> /etc/profile</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 nginx 版本</span></span><br><span class="line">nginx -v</span><br></pre></td></tr></table></figure>

<h2 id="使用-nginx-1"><a href="#使用-nginx-1" class="headerlink" title="使用 nginx"></a>使用 <code>nginx</code></h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -h/--<span class="built_in">help</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 启动 nginx</span></span><br><span class="line">nginx</span><br></pre></td></tr></table></figure>

<p>修改 <code>/usr/local/nginx/conf/nginx.conf</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /usr/<span class="built_in">local</span>/nginx/conf/nginx.conf</span><br></pre></td></tr></table></figure>

<p>在 <code>http</code> 块下加 <code>include conf.d/*.conf;</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">http &#123;</span><br><span class="line">  include       mime.types;</span><br><span class="line">  default_type  application/octet-stream;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 新增</span></span><br><span class="line">  include       conf.d/*.conf;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新建 <code>/usr/local/nginx/conf/conf.d</code> 文件夹，新建 <code>dev.zhouyu.com.conf</code>：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /usr/<span class="built_in">local</span>/nginx/conf &amp;&amp; mkdir conf.d</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> conf.d &amp;&amp; vi dev.zhouyu.com.conf</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen 80;</span><br><span class="line">  server_name dev.zhouyu.com;</span><br><span class="line">  ssi on;</span><br><span class="line"></span><br><span class="line">  error_log /home/work/<span class="built_in">log</span>/nginx/dev.zhouyu.com-error.log; <span class="comment"># 修改为实际目录</span></span><br><span class="line">  access_log /home/work/<span class="built_in">log</span>/nginx/dev.zhouyu.com-access.log; <span class="comment"># 修改为实际目录</span></span><br><span class="line">  log_not_found on;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">set</span> <span class="variable">$root_dir</span> /home/work/html/dev.zhouyu.com; <span class="comment"># 修改为实际目录</span></span><br><span class="line">  <span class="built_in">set</span> <span class="variable">$root_dir_zh</span> <span class="variable">$root_dir</span>/zh_CN/;</span><br><span class="line">  <span class="built_in">set</span> <span class="variable">$root_dir_en</span> <span class="variable">$root_dir</span>/en/;</span><br><span class="line"></span><br><span class="line">  root <span class="variable">$root_dir</span>;</span><br><span class="line"></span><br><span class="line">  location / &#123;</span><br><span class="line">    rewrite ^(.*)$ http://dev.zhouyu.com/zh_CN/<span class="variable">$1</span> permanent;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  location ^~ /zh_CN &#123;</span><br><span class="line">    <span class="built_in">alias</span> <span class="variable">$root_dir_zh</span>;</span><br><span class="line">    try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /zh_CN/index.html;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  location ^~ /en &#123;</span><br><span class="line">    <span class="built_in">alias</span> <span class="variable">$root_dir_en</span>;</span><br><span class="line">    try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /en/index.html;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  location /baidu &#123;</span><br><span class="line">    proxy_pass https://www.baidu.com/;</span><br><span class="line">    proxy_set_header Host www.baidu.com; <span class="comment"># 如果使用 $host 或 $http_host 会报 403</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  error_page 404 /404.html;</span><br><span class="line">  error_page 500 /500.html;</span><br><span class="line">  error_page 502 /502.html;</span><br><span class="line">  error_page 503 /503.html;</span><br><span class="line">  error_page 504 /504.html;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 自定义 404</span></span><br><span class="line">  location = /404.html &#123;</span><br><span class="line">    root <span class="variable">$root_dir</span>/404.html;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新加载 <code>nginx</code> 配置文件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 检查</span></span><br><span class="line">nginx -t</span><br><span class="line"></span><br><span class="line"><span class="comment"># 重载</span></span><br><span class="line">nginx -s reload</span><br></pre></td></tr></table></figure>

<p>测试，配置：<code>127.0.0.1 dev.zhouyu.com</code>，浏览器访问：<code>http://dev.zhouyu.com/baidu</code>，看是否打开百度首页。</p>
<p>停止 <code>nginx</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nginx -s quit/stop</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看 80 端口</span></span><br><span class="line">lsof -i:80</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查询 nginx 主进程号</span></span><br><span class="line">ps -ef | grep nginx</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制停止 nginx</span></span><br><span class="line"><span class="built_in">kill</span> -9 [主进程号]</span><br></pre></td></tr></table></figure>

<h1 id="nginx-常用命令"><a href="#nginx-常用命令" class="headerlink" title="nginx 常用命令"></a>nginx 常用命令</h1><p>nginx -h</p>
<p>nginx -v</p>
<p>nginx -V</p>
<p>nginx -t</p>
<p>nginx -s stop/quit/reopen/reload</p>
<h1 id="nginx-配置相关知识"><a href="#nginx-配置相关知识" class="headerlink" title="nginx 配置相关知识"></a>nginx 配置相关知识</h1><h2 id="location-匹配"><a href="#location-匹配" class="headerlink" title="location 匹配"></a>location 匹配</h2><h3 id="语法规则"><a href="#语法规则" class="headerlink" title="语法规则"></a>语法规则</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location [ = | ^~ | ~ | ~* | !~ | !~* | / ] uri &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location @name &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>语法规则很简单，一个 location 关键字，后面跟着可选的修饰符，后面是要匹配的字符，花括号中是要执行的操作。</p>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">=   <span class="comment"># 进行普通字符精确匹配。只有请求的 url 路径与后面的字符串完全相等时，才会命中</span></span><br><span class="line"></span><br><span class="line">^~  <span class="comment"># 表示普通字符匹配，如果该选项匹配，只匹配该选项，不再匹配别的选项，一般用来匹配目录</span></span><br><span class="line"></span><br><span class="line">~   <span class="comment"># 表示执行一个正则匹配，区分大小写</span></span><br><span class="line"></span><br><span class="line">~*  <span class="comment"># 表示执行一个正则匹配，不区分大小写</span></span><br><span class="line"></span><br><span class="line">!~  <span class="comment"># 表示执行一个正则不匹配，区分大小写</span></span><br><span class="line"></span><br><span class="line">!~*  <span class="comment"># 表示执行一个正则不匹配，不区分大小写</span></span><br><span class="line"></span><br><span class="line">/    <span class="comment"># 通用匹配, 如果没有其它匹配，任何请求都会匹配到</span></span><br><span class="line"></span><br><span class="line">@    <span class="comment"># 定义一个命名的 location，使用在内部定向时，例如 error_page, try_files</span></span><br></pre></td></tr></table></figure>

<p>顺序 no优先级：</p>
<p>(location =) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location <del>、</del>* 正则顺序) &gt; (location 部分起始路径) &gt; (/)</p>
<p>建议使用：<code>=、^~、~*、/</code></p>
<h3 id="匹配过程"><a href="#匹配过程" class="headerlink" title="匹配过程"></a>匹配过程</h3><ul>
<li>对请求的 url 序列化。例如，对 %xx 等字符进行解码，去除 url 中多个相连的 /，解析 url 中的 .，.. 等。这一步是匹配的前置工作。</li>
<li>location 有两种表示形式，一种是使用前缀字符，一种是使用正则。如果是正则的话，前面有 ~ 或 ~* 修饰符。</li>
<li>具体的匹配过程如下：<ul>
<li>首先先检查使用前缀字符定义的 location，选择最长匹配的项并记录下来。</li>
<li>如果找到了精确匹配的 location，也就是使用了 = 修饰符的 location，结束查找，使用它的配置。</li>
<li>然后按顺序查找使用正则定义的 location，如果匹配则停止查找，使用它定义的配置。</li>
<li>如果没有匹配的正则 location，则使用前面记录的最长匹配前缀字符 location。</li>
</ul>
</li>
</ul>
<p>基于以上的匹配过程，我们可以得到以下两点启示：</p>
<ol>
<li>使用正则定义的 location 在配置文件中出现的顺序很重要。因为找到第一个匹配的正则后，查找就停止了，后面定义的正则就是再匹配也没有机会了。</li>
<li>使用精确匹配可以提高查找的速度。例如经常请求 / 的话，可以使用 = 来定义 location。</li>
</ol>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location = / &#123;</span><br><span class="line">  <span class="comment"># 精确匹配 / ，主机名后面不能带任何字符串</span></span><br><span class="line">  [ configuration A ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">  <span class="comment"># 因为所有的地址都以 / 开头，所以这条规则将匹配到所有请求</span></span><br><span class="line">  <span class="comment"># 但是正则和最长字符串会优先匹配</span></span><br><span class="line">  [ configuration B ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /documents/ &#123;</span><br><span class="line">  <span class="comment"># 匹配任何以 /documents/ 开头的地址，匹配符合以后，记住还要继续往下搜索</span></span><br><span class="line">  <span class="comment"># 只有后面的正则表达式没有匹配到时，这一条才会采用这一条</span></span><br><span class="line">  [ configuration C ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~ /documents/Abc &#123;</span><br><span class="line">  <span class="comment"># 匹配任何以 /documents/Abc 开头的地址，匹配符合以后，还要继续往下搜索</span></span><br><span class="line">  <span class="comment"># 只有后面的正则表达式没有匹配到时，这一条才会采用这一条</span></span><br><span class="line">  [ configuration CC ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ^~ /images/ &#123;</span><br><span class="line">  <span class="comment"># 匹配任何以 /images/ 开头的地址，匹配符合以后，停止往下搜索正则，采用这一条。</span></span><br><span class="line">  [ configuration D ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* \.(gif|jpg|jpeg)$ &#123;</span><br><span class="line">  <span class="comment"># 匹配所有以 .gif, .jpg 或 .jpeg 结尾的请求</span></span><br><span class="line">  <span class="comment"># 然而，所有请求 /images/ 下的图片会被 config D 处理，因为 ^~ 到达不了这一条正则</span></span><br><span class="line">  [ configuration E ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /images/ &#123;</span><br><span class="line">  <span class="comment"># 字符匹配到 /images/，继续往下，会发现 ^~ 存在</span></span><br><span class="line">  [ configuration F ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /images/abc &#123;</span><br><span class="line">  <span class="comment"># 最长字符匹配到 /images/abc，继续往下，会发现 ^~ 存在</span></span><br><span class="line">  <span class="comment"># F 与 G 的放置顺序是没有关系的</span></span><br><span class="line">  [ configuration G ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~ /images/abc/ &#123;</span><br><span class="line">  <span class="comment"># 只有去掉 config D 才有效：先最长匹配 config G 开头的地址，继续往下搜索，匹配到这一条正则，采用</span></span><br><span class="line">  [ configuration H ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* /js/.*/\.js &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>/ -&gt; config A<br>精确完全匹配，匹配到A，即使 /index.html 也匹配不了</li>
<li>/downloads/download.html -&gt; config B<br>完整路径，匹配到B，往下继续搜索发现没有任何匹配，最后采用B</li>
<li>/images/1.gif -&gt; configuration D<br>完整路径，匹配到F，往下匹配到D，停止往下，采用D</li>
<li>/images/abc/def -&gt; config D<br>完整路径，最长匹配到G，往下匹配到D，停止往下，采用D<br>你可以看到 任何以 /images/ 开头的都会匹配到D并停止，FG写在这里是没有任何意义的，H是永远轮不到的，这里只是为了说明匹配顺序</li>
<li>/documents/document.html -&gt; config C<br>完整路径，匹配到C，往下继续搜索发现没有任何匹配，最后采用C</li>
<li>/documents/1.jpg -&gt; configuration E<br>完整路径，匹配到C，往下正则匹配到E</li>
<li>/documents/Abc.jpg -&gt; config CC<br>完整路径，最长匹配到C，往下正则顺序匹配到CC，不会往下到E（正则匹配时，顺序很重要，一旦匹配就停止了）</li>
</ul>
<h3 id="实际使用建议"><a href="#实际使用建议" class="headerlink" title="实际使用建议"></a>实际使用建议</h3><p>实际使用中，个人觉得至少有三个匹配规则定义，如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。</span></span><br><span class="line"><span class="comment"># 这里是直接转发给后端应用服务器了，也可以是一个静态首页</span></span><br><span class="line"><span class="comment"># 第一个必选规则</span></span><br><span class="line">location = / &#123;</span><br><span class="line">  proxy_pass http://tomcat:8080/index</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第二个必选规则是处理静态文件请求，这是 nginx 作为 http 服务器的强项</span></span><br><span class="line"><span class="comment"># 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用</span></span><br><span class="line">location ^~ /static/ &#123;</span><br><span class="line">  root /webroot/static/;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~* \.(gif|jpg|jpeg|png|css|js|ico)$ &#123;</span><br><span class="line">  root /webroot/res/;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 第三个规则就是通用规则，用来转发动态请求到后端应用服务器</span></span><br><span class="line"><span class="comment"># 非静态文件请求就默认是动态请求，自己根据实际把握</span></span><br><span class="line"><span class="comment"># 毕竟目前的一些框架的流行，带 .php, .jsp 后缀的情况很少了</span></span><br><span class="line">location / &#123;</span><br><span class="line">  proxy_pass http://tomcat:8080/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="location-name-的用法"><a href="#location-name-的用法" class="headerlink" title="location @name 的用法"></a>location <code>@name</code> 的用法</h3><p>@用来定义一个命名 location。主要用于内部重定向，不能用来处理正常的请求。其用法如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ @custom</span><br><span class="line">&#125;</span><br><span class="line">location @custom &#123;</span><br><span class="line">  <span class="comment"># ...do something</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上例中，当尝试访问 url 找不到对应的文件就重定向到我们自定义的命名 location（此处为custom）。</p>
<p>值得注意的是，命名 location 中不能再嵌套其它的命名 location。</p>
<h3 id="URL-尾部的-需不需要"><a href="#URL-尾部的-需不需要" class="headerlink" title="URL 尾部的 / 需不需要"></a>URL 尾部的 / 需不需要</h3><p>推荐带</p>
<p>根据约定，URL 尾部的 / 表示目录，没有 / 表示文件。</p>
<p>访问 /some-dir/ 时，服务器会自动去该目录下找对应的默认文件。</p>
<p>访问 /some-dir 时，服务器会先去找 some-dir 文件，找不到的话会将 some-dir 当成目录，重定向到 /some-dir/，去该目录下找默认文件。</p>
<h2 id="set"><a href="#set" class="headerlink" title="set"></a>set</h2><p>定义在 server, location, if 模块中</p>
<p>设置指定变量的值。变量的值可以包含文本，变量或者是它们的组合形式。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">    <span class="built_in">set</span> <span class="variable">$var1</span> <span class="string">"host is "</span>;</span><br><span class="line">    <span class="built_in">set</span> <span class="variable">$var2</span> <span class="variable">$host</span>;</span><br><span class="line">    <span class="built_in">set</span> <span class="variable">$var3</span> <span class="string">" uri is <span class="variable">$request_uri</span>"</span>;</span><br><span class="line">    <span class="built_in">return</span> 200 <span class="string">"response ok <span class="variable">$var1</span><span class="variable">$var2</span><span class="variable">$var3</span>"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 发送如下请求</span></span><br><span class="line"><span class="comment"># curl 127.0.0.1:8080/test</span></span><br><span class="line"><span class="comment"># response ok host is 127.0.0.1 uri is /test</span></span><br></pre></td></tr></table></figure>

<h2 id="root-与-alias"><a href="#root-与-alias" class="headerlink" title="root 与 alias"></a>root 与 alias</h2><p>推荐 alias</p>
<p>都可以定义在 location 模块中，都是用来指定请求资源的真实路径。</p>
<p>root，是把location那部分也给拼接起来了。</p>
<p>alias，正如其名，代理！是将 <code>/i/</code> 代理为 <code>/data/w3</code>。</p>
<ol>
<li>alias 只能作用在 location 中，而 root 可以存在 server、http 和 location 中。</li>
<li>alias 后面必须要用 “/” 结束，否则会找不到文件，而 root 则对 ”/” 可有可无。</li>
</ol>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location /i/ &#123;</span><br><span class="line">  root /data/w3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://localhost/i/" target="_blank" rel="noopener">http://localhost/i/</a> -&gt; /data/w3</p>
<p><strong><a href="http://localhost/i/test.html" target="_blank" rel="noopener">http://localhost/i/test.html</a> -&gt; /data/w3/i/test.html</strong></p>
<p><strong><a href="http://localhost/i/j/test.html" target="_blank" rel="noopener">http://localhost/i/j/test.html</a> -&gt; /data/w3/i/j/test.html</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location /i/ &#123;</span><br><span class="line">  <span class="built_in">alias</span> /data/w3/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="http://localhost/i/" target="_blank" rel="noopener">http://localhost/i/</a> -&gt; /data/w3</p>
<p><strong><a href="http://localhost/i/test.html" target="_blank" rel="noopener">http://localhost/i/test.html</a> -&gt; /data/w3/test.html</strong></p>
<p><strong><a href="http://localhost/i/j/test.html" target="_blank" rel="noopener">http://localhost/i/j/test.html</a> -&gt; /data/w3/j/test.html</strong></p>
<h2 id="try-files"><a href="#try-files" class="headerlink" title="try_files"></a>try_files</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upstream mongrel &#123;</span><br><span class="line">  server 127.0.0.1:4000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">  try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">$uri</span>.html =404;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location / &#123;</span><br><span class="line">  try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ /index.html @mongrel;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location @mongrel &#123;</span><br><span class="line">  proxy_pass http://mongrel;</span><br><span class="line">  proxy_set_header Host <span class="variable">$http_host</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当用户请求 <a href="http://localhost/example" target="_blank" rel="noopener">http://localhost/example</a> 时，这里的 $uri 就是 <code>/example</code>。</p>
<p>try_files 会到服务器里尝试找这个文件。如果存在名为 <code>/$root/example</code>（其中 $root 是项目代码安装目录）的文件，就直接把这个文件的内容发送给用户。</p>
<p>显然，目录中没有叫 example 的文件。然后就看 $uri/，增加了一个 /，也就是看有没有名为 <code>/$root/example/</code> 的目录，如果有则去该目录下找默认文件 <code>/$root/example/index.html</code>。</p>
<p>又找不到，就会看 /index.html，发起一个内部 “子请求”，重定向到 <a href="http://localhost/index.html。" target="_blank" rel="noopener">http://localhost/index.html。</a></p>
<p>又找不到，就会看 @mongrel，发起一个内部 “子请求”，重定向到 <code>@mongrel</code> 模块。</p>
<h2 id="index"><a href="#index" class="headerlink" title="index"></a>index</h2><p>指令拥有默认值，<code>index index.html</code>，即，如果没有给出 <code>index</code>，默认初始页为 <code>index.html</code>。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  root  /data/www;</span><br><span class="line">  try_files <span class="variable">$uri</span> <span class="variable">$uri</span>/ <span class="variable">$uri</span>.html =404;</span><br><span class="line">  index index.html index.htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="rewrite"><a href="#rewrite" class="headerlink" title="rewrite"></a>rewrite</h2><p>rewrite 功能就是，使用 nginx 提供的全局变量或自己设置的变量，结合正则表达式和标志位实现 url 重写以及重定向。</p>
<h3 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h3><p>rewrite 只能放在 server {}, location {}, if {} 中，并且只能对域名后边的除去传递的参数外的字符串起作用。例如 <a href="http://seanlook.com/a/we/index.php?id=1&amp;u=str" target="_blank" rel="noopener">http://seanlook.com/a/we/index.php?id=1&amp;u=str</a> 只对 <code>/a/we/index.php</code> 重写。</p>
<p>语法：<code>rewrite regex replacement [flag];</code></p>
<p>如果相对域名或参数字符串起作用，可以使用全局变量匹配，也可以使用 proxy_pass 反向代理。</p>
<p>表面看 rewrite 和 location 功能有点像，都能实现跳转，主要区别在于 rewrite 是在同一域名内更改获取资源的路径，而 location 是对一类路径做控制访问或反向代理，可以 proxy_pass 到其他机器。很多情况下 rewrite 也会写在 location 里，它们的执行顺序是：</p>
<ol>
<li>执行 server 块的 rewrite 指令</li>
<li>执行 location 匹配</li>
<li>执行选定的 location 中的 rewrite 指令</li>
</ol>
<p>如果其中某步 uri 被重写，则重新循环执行 1-3，直到找到真实存在的文件；循环超过 10 次，则返回 500 Internal Server Error 错误。</p>
<ul>
<li><code>rewrite</code> 指令是使用指定的正则表达式 <code>regex</code> 来匹配请求的 <code>uri</code>，如果匹配成功，则使用 <code>replacement</code> 更改 <code>uri</code>。</li>
<li><code>rewrite</code> 指令按照它们在配置文件中出现的顺序执行。可以使用 <code>flag</code> 标志来终止指令的进一步处理。如果替换字符串</li>
<li><code>replacement</code> 以 <code>http://</code>，<code>https://</code> 或 <code>$ scheme</code> 开头，则停止处理后续内容，并直接重定向返回给客户端。</li>
</ul>
<p>第一种情况 重写的字符串带 <code>http://</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  <span class="comment"># 当匹配正则表达式 /test1/(.*)时 请求将被临时重定向到 http://www.$1.com</span></span><br><span class="line">  <span class="comment"># 相当于 flag 写为 redirect</span></span><br><span class="line">  rewrite /test1/(.*) http://www.<span class="variable">$1</span>.com;</span><br><span class="line">  <span class="built_in">return</span> 200 <span class="string">"ok"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 在浏览器中输入 127.0.0.1:8080/test1/baidu</span></span><br><span class="line"><span class="comment"># 则临时重定向到 http://www.baidu.com</span></span><br><span class="line"><span class="comment"># 后面的 return 指令将没有机会执行了</span></span><br></pre></td></tr></table></figure>

<p>第二种情况 重写的字符串不带 <code>http://</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">  rewrite /test1/(.*) www.<span class="variable">$1</span>.com;</span><br><span class="line">  <span class="built_in">return</span> 200 <span class="string">"ok"</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 在终端中输入 curl 127.0.0.1:8080/test1/baidu</span></span><br><span class="line"><span class="comment"># ok</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 此处没有带 http:// 所以只是简单的重写。请求的 uri 由 /test1/baidu 重写为 www.baidu.com</span></span><br><span class="line"><span class="comment"># 因为会顺序执行 rewrite 指令，所以下一步执行 return 指令，响应了 ok</span></span><br></pre></td></tr></table></figure>

<h3 id="flag-标志位"><a href="#flag-标志位" class="headerlink" title="flag 标志位"></a>flag 标志位</h3><ul>
<li>last: 相当于 Apache 的 [L] 标记，表示完成 rewrite。</li>
<li>break: 停止执行当前虚拟主机的后续 rewrite 指令集。</li>
<li>redirect: 返回 302 临时重定向，地址栏会显示跳转后的地址</li>
<li>permanent: 返回 301 永久重定向，地址栏会显示跳转后的地址</li>
</ul>
<p>因为 301 和 302 不能简单的只返回状态码，还必须有重定向的 URL，这就是 return 指令无法返回 301、302 的原因了。这里 last 和 break 区别有点难以理解：</p>
<h4 id="last-与-break"><a href="#last-与-break" class="headerlink" title="last 与 break"></a>last 与 break</h4><ol>
<li>last 一般写在 server 和 if 中，而 break 一般使用在 location 中</li>
<li>last 不终止重写后的 url 匹配，即新的 url 会再从 server 走一遍匹配流程，而 break 终止重写后的匹配</li>
<li>last 和 break 都能阻止继续执行后面的 rewrite 指令</li>
</ol>
<p>例子：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">rewrite xxx1 yyy last; ⑦</span><br><span class="line">rewrite xxx2 yyy last; ⑧</span><br><span class="line">rewrite xxx3 yyy last; ⑨</span><br><span class="line">rewrite xxx4 yyy last; ⑩</span><br><span class="line"></span><br><span class="line">location ~  url1 &#123;</span><br><span class="line">  rewrite url1 url2 last; ①</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~  url3 &#123;</span><br><span class="line">  rewrite url3 url4 <span class="built_in">break</span>; ②</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 这条指令会被忽略</span></span><br><span class="line">  rewrite url3 url5;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 因为 fastcgi_pass 不是 rewrite 模块的指令，所以它不会被 break终止</span></span><br><span class="line">  fastcgi_pass 127.0.0.1:9000;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location ~  url5 &#123;</span><br><span class="line">  rewrite url5 url6 <span class="built_in">break</span>;  ②</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 这条指令会被忽略</span></span><br><span class="line">  rewrite url5 url7;</span><br><span class="line"></span><br><span class="line">  <span class="comment"># 因为 proxy_pass 不是 rewrite 模块的指令，所以它不会被 break终止</span></span><br><span class="line">  proxy_pass https://www.baidu.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第一个 location 中的 rewrite 指令处理完成之后，会跳出 location，再重新判断 rewrite 7 ~ 9 的规则。</p>
<p>第二个 location 中的 rewrite 指令处理完成之后，不会跳出 location，更不会重新判断 rewrite 7 ~ 9 的规则。而只能将信息传递给后面的 fastcgi_pass 或者 proxy_pass 等指令。</p>
<p>last: 使用了 last 指令，rewrite 后会跳出 location 作用域，重新开始再走一次刚刚的行为。</p>
<p>break: 使用了 break 指令，rewrite 后不会跳出 location 作用域。它的生命也在这个 location 中终结。</p>
<p>last 和 break 相对于访问日志的请求状态码是 200。</p>
<h4 id="permanent-和-redirect"><a href="#permanent-和-redirect" class="headerlink" title="permanent 和 redirect"></a>permanent 和 redirect</h4><p>permanent 301 永久重定向</p>
<p>redirect 302 临时重定向</p>
<p>SEO</p>
<p>在利用百度的搜索引擎的时候，301 的 SEO 是对应重定向后的内容和 url，302 的 SEO 是对应重定向后的内容和重定向前的 url；<br>在利用 Google 的搜索引擎的时候，Google会将 302 按照 301 处理，所以 SEO 都是重定向后的内容和 url；</p>
<p>尽量要使用 301 跳转，防止网址劫持。</p>
<p>尽量使用 permanent。</p>
<p>浏览器会缓存 301 的请求，不会缓存 302 的。</p>
<p>如果是个人网站，或网站用途只是开发测试，改动的可能性比较大，建议使用 302。</p>
<p>如果是生产环境，或改动的可能性比较小，建议使用 301。</p>
<h3 id="rewrite-后的请求参数"><a href="#rewrite-后的请求参数" class="headerlink" title="rewrite 后的请求参数"></a>rewrite 后的请求参数</h3><p>如果替换字符串 replacement 包含新的请求参数，则在它们之后附加先前的请求参数。如果你不想要之前的参数，则在替换字符串 replacement 的末尾放置一个问号，避免附加它们。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 由于最后加了个 ?，原来的请求参数将不会被追加到 rewrite 之后的 url 后面</span></span><br><span class="line">rewrite ^/users/(.*)$ /show?user=<span class="variable">$1</span>? last;</span><br></pre></td></tr></table></figure>

<h3 id="if-指令"><a href="#if-指令" class="headerlink" title="if 指令"></a>if 指令</h3><p>if 可放在 server {}, location {} 中，语法为 <code>if (condition) { ... }</code>。</p>
<p>对给定的条件 condition 进行判断。如果为真，大括号内的 rewrite 指令将被执行，if 条件 (conditon) 可以是如下任何内容：</p>
<ul>
<li><p>当表达式只是一个变量时，如果值为空或任何以 0 开头的字符串都会当做 false</p>
</li>
<li><p>直接比较变量和内容时，使用 = 或 !=。注意此处不要把相等当做赋值语句啊</p>
</li>
<li><p><code>~</code>  区分大小写的正则匹配，<code>~*</code> 不区分大小写的正则匹配，<code>!~</code>、<code>!~*</code> 前面两者的非</p>
</li>
<li><p>检测文件是否存在，使用 -f(存在) 和 !-f(不存在)</p>
</li>
<li><p>检测路径是否存在，使用 -d(存在) 和 !-d(不存在) 后面判断可以是字符串也可是变量</p>
</li>
<li><p>检测文件、路径、或者链接文件是否存在，使用 -e(存在) 和 !-e(不存在) 后面判断可以是字符串也可是变量</p>
</li>
<li><p>检测文件是否为可执行文件，使用 -x(可执行) 和 !-x(不可执行) 后面判断可以是字符串也可是变量</p>
</li>
</ul>
<p>注意，上面第1、2、3条被判断的必须是变量，第4、5、6、7则可以是变量也可是字符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set $variable &quot;0&quot;;</span><br><span class="line"></span><br><span class="line">if ($variable) &#123;</span><br><span class="line">  # 不会执行，因为 &quot;0&quot; 为 false</span><br><span class="line">  break;            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 使用变量与正则表达式匹配 没有问题</span><br><span class="line">if ($http_host ~ &quot;^star\.igrow\.cn$&quot;) &#123;</span><br><span class="line">  break;            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 字符串与正则表达式匹配 报错</span><br><span class="line">if (&quot;star&quot; ~ &quot;^star\.igrow\.cn$&quot;) &#123;</span><br><span class="line">  break;            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"># 检查文件类的 字符串与变量均可</span><br><span class="line">if (!-f &quot;/data.log&quot;) &#123;</span><br><span class="line">    break;            </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (!-f $filename) &#123;</span><br><span class="line">  break;            </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if ($http_user_agent ~ MSIE) &#123;</span><br><span class="line">  rewrite ^(.*)$ /msie/$1 break;</span><br><span class="line">&#125; //如果 UA 包含 &quot;MSIE&quot;，rewrite 请求到 /msid/ 目录下</span><br><span class="line"></span><br><span class="line">if ($http_cookie ~* &quot;id=([^;]+)(?:;|$)&quot;) &#123;</span><br><span class="line">  set $id $1;</span><br><span class="line">&#125; // 如果 cookie 匹配正则，设置变量 $id 等于正则引用部分</span><br><span class="line"></span><br><span class="line">if ($request_method = POST) &#123;</span><br><span class="line">  return 405;</span><br><span class="line">&#125; // 如果提交方法为 POST，则返回状态 405（Method not allowed）。return 不能返回 301，302</span><br><span class="line"></span><br><span class="line">if ($slow) &#123;</span><br><span class="line">  limit_rate 10k;</span><br><span class="line">&#125; // 限速，$slow 可以通过 set 指令设置</span><br><span class="line"></span><br><span class="line">if (!-f $request_filename)&#123;</span><br><span class="line">  break;</span><br><span class="line">  proxy_pass http://127.0.0.1;</span><br><span class="line">&#125; // 如果请求的文件名不存在，则反向代理到 localhost。这里的 break 也是停止 rewrite 检查</span><br><span class="line"></span><br><span class="line">if ($args ~ post=140)&#123;</span><br><span class="line">  rewrite ^ http://example.com/ permanent;</span><br><span class="line">&#125; // 如果 query string 中包含 &quot;post=140&quot;，永久重定向到 example.com</span><br><span class="line"></span><br><span class="line">location ~* \.(gif|jpg|png|swf|flv)$ &#123;</span><br><span class="line">  valid_referers none blocked www.jefflei.com www.leizhenfang.com;</span><br><span class="line">  if ($invalid_referer) &#123;</span><br><span class="line">    return 404;</span><br><span class="line">  &#125; // 防盗链</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>下面是可以用作 if 判断的全局变量：</p>
<ul>
<li>$args ： 这个变量等于请求行中的参数，同 $query_string</li>
<li>$content_length ： 请求头中的 Content-length 字段。</li>
<li>$content_type ： 请求头中的 Content-Type 字段。</li>
<li>$document_root ： 当前请求在 root 指令中指定的值。</li>
<li>$host ： 请求主机头字段，否则为服务器名称。</li>
<li>$http_user_agent ： 客户端 agent 信息</li>
<li>$http_cookie ： 客户端 cookie 信息</li>
<li>$limit_rate ： 这个变量可以限制连接速率。</li>
<li>$request_method ： 客户端请求的动作，通常为 GET 或 POST。</li>
<li>$remote_addr ： 客户端的 IP 地址。</li>
<li>$remote_port ： 客户端的端口。</li>
<li>$remote_user ： 已经经过 Auth Basic Module 验证的用户名。</li>
<li>$request_filename ： 当前请求的文件路径，由 root 或 alias 指令与 uri 请求生成。</li>
<li>$scheme ： HTTP 方法（如 http，https）。</li>
<li>$server_protocol ： 请求使用的协议，通常是 HTTP/1.0 或 HTTP/1.1。</li>
<li>$server_addr ： 服务器地址，在完成一次系统调用后可以确定这个值。</li>
<li>$server_name ： 服务器名称。</li>
<li>$server_port ： 请求到达服务器的端口号。</li>
<li>$request_uri ： 包含请求参数的原始 uri，不包含主机名，如：”/foo/bar.php?arg=baz”。</li>
<li>$uri ： 不带请求参数的当前 uri，$uri 不包含主机名，如 ”/foo/bar.html”。</li>
<li>$document_uri ： 与 $uri 相同。</li>
</ul>
<h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>return 可放在 server {}, location {}, if (conditon) {} 中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">return</span> code [text];</span><br><span class="line"><span class="built_in">return</span> code URL;</span><br><span class="line"><span class="built_in">return</span> URL;</span><br></pre></td></tr></table></figure>

<p>该指令将结束执行直接返回 http 状态码到客户端.</p>
<p>支持的 http 状态码：200, 204, 400, 402-406, 408, 410, 411, 413, 416, 500-504，还有非标准的 444 状态码。</p>
<p>从 <code>0.8.42</code> 版本开始，<code>return</code> 语句可以指定重定向 <code>url</code> (状态码可以为如下几种 301,302,303,307)，也可以为其他状态码指定响应的文本内容，并且重定向的 <code>url</code> 和响应的文本可以包含变量。</p>
<p>有一种特殊情况，就是重定向的 <code>url</code> 可以指定为此服务器本地的 <code>uri</code> ，这样的话，<code>nginx</code> 会依据请求的协议 <code>$scheme</code>， <code>server_name_in_redirect</code> 和 <code>port_in_redirect</code> 自动生成完整的 <code>url</code> （此处要说明的是 <code>server_name_in_redirect</code> 和 <code>port_in_redirect</code> 指令是表示是否将 <code>server</code> 块中的 <code>server_name</code> 和 <code>listen</code> 的端口作为 <code>redirect</code> 用）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># return code [text]; 返回 ok 给客户端</span></span><br><span class="line">location = /ok &#123;</span><br><span class="line">  <span class="built_in">return</span> 200 <span class="string">"ok"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># return code URL; 临时重定向到 百度</span></span><br><span class="line">location = /redirect &#123;</span><br><span class="line">  <span class="built_in">return</span> 302 http://www.baidu.com;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># return URL; 和上面一样 默认也是临时重定向</span></span><br><span class="line">location = /redirect &#123;</span><br><span class="line">  <span class="built_in">return</span> http://www.baidu.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="proxy-pass"><a href="#proxy-pass" class="headerlink" title="proxy_pass"></a>proxy_pass</h2><p>反向代理。在 proxy_pass 后面的 url 加 /，表示绝对根路径；如果没有 /，表示相对路径，把匹配的路径部分也给代理走。</p>
<p>最好 location 后面的 url 加 /，proxy_pass 后面的 url 也加 /。当然也视具体情况！</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location /proxy &#123;</span><br><span class="line">  proxy_pass https://www.baidu.com/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>/proxy -&gt; <a href="https://www.baidu.com/" target="_blank" rel="noopener">https://www.baidu.com/</a></p>
<p>/proxys?wd=nginx -&gt; <a href="https://www.baidu.com/s?wd=nginx" target="_blank" rel="noopener">https://www.baidu.com/s?wd=nginx</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location /proxy &#123;</span><br><span class="line">  proxy_pass https://www.baidu.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>/proxy -&gt; <a href="https://www.baidu.com/proxy" target="_blank" rel="noopener">https://www.baidu.com/proxy</a> -&gt; 404 -&gt; /search/error.html -&gt; 502</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location /proxy/ &#123;</span><br><span class="line">  proxy_pass https://www.baidu.com/;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>/proxy -&gt; 301 -&gt; /proxy/ -&gt; <a href="https://www.baidu.com/" target="_blank" rel="noopener">https://www.baidu.com/</a></p>
<p>/proxy/s?wd=nginx -&gt; <a href="https://www.baidu.com/s?wd=nginx" target="_blank" rel="noopener">https://www.baidu.com/s?wd=nginx</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">location /proxy/ &#123;</span><br><span class="line">  proxy_pass https://www.baidu.com;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>/proxy -&gt; 301 -&gt; /proxy/ -&gt; <a href="https://www.baidu.com/proxy/" target="_blank" rel="noopener">https://www.baidu.com/proxy/</a> -&gt; 404 -&gt; /search/error.html -&gt; 502</p>
<h3 id="正向代理与反向代理"><a href="#正向代理与反向代理" class="headerlink" title="正向代理与反向代理"></a>正向代理与反向代理</h3><p>例子！！！</p>
<h2 id="proxy-host、-host-与-http-host"><a href="#proxy-host、-host-与-http-host" class="headerlink" title="$proxy_host、$host 与 $http_host"></a>$proxy_host、$host 与 $http_host</h2><p>默认是 <code>proxy_set_header Host $proxy_host;</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">upstream my-localhost &#123;  </span><br><span class="line">  server 127.0.0.1:8080;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">upstream my-baidu &#123;  </span><br><span class="line">  server www.baidu.com;  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;  </span><br><span class="line">  listen       80;  </span><br><span class="line">  server_name  chuan.aty.sohuno.com;  </span><br><span class="line">  proxy_set_header Host <span class="variable">$http_host</span>;  </span><br><span class="line"></span><br><span class="line">  location /myLocalhost &#123;  </span><br><span class="line">    proxy_pass http://my-localhost;</span><br><span class="line">  &#125;  </span><br><span class="line"></span><br><span class="line">  location /baidu &#123;  </span><br><span class="line">    proxy_pass http://my-baidu;  </span><br><span class="line">    proxy_set_header Host <span class="variable">$proxy_host</span>;  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  location /baidu2 &#123;  </span><br><span class="line">    proxy_pass http://my-baidu;  </span><br><span class="line">    proxy_set_header Host www.baidu.com;  </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  location /baidu3 &#123;  </span><br><span class="line">    proxy_pass http://my-baidu;  </span><br><span class="line">    proxy_set_header Host <span class="variable">$http_host</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  location /baidu4 &#123;  </span><br><span class="line">    proxy_pass http://my-baidu;  </span><br><span class="line">    proxy_set_header Host <span class="variable">$host</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  location /baidu5 &#123;  </span><br><span class="line">    proxy_pass http://my-baidu;  </span><br><span class="line">    proxy_set_header Host <span class="variable">$host</span>:<span class="variable">$proxy_port</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当匹配到 /baidu 时，使用 baidu 处理，到 upstream 就匹配到 w<a href="http://www.baidu.com，这里接转换成" target="_blank" rel="noopener">www.baidu.com，这里接转换成</a> IP 进行转发了。假如 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 是在另一台 nginx 下配置的，ip 为 10.22.10.116，则 $proxy_host 则对应为 10.22.10.116。此时相当于设置了 Host 为 10.22.10.116。如果想让 Host 是 <a href="http://www.baidu.com，则进行如下设置：" target="_blank" rel="noopener">www.baidu.com，则进行如下设置：</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxy_set_header Host www.baidu.com;</span><br></pre></td></tr></table></figure>

<p>如果不想改变请求头 Host 的值，可以这样来设置：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxy_set_header Host <span class="variable">$http_host</span>;</span><br></pre></td></tr></table></figure>

<p>但是，如果客户端请求头中没有携带这个头部，那么传递到后端服务器的请求也不含这个头部。这种情况下，更好的方式是使用 <code>$host</code> 变量——它的值在请求包含 Host 请求头时为 Host 字段的值，在请求未携带 Host 请求头时为虚拟主机的主域名：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxy_set_header Host <span class="variable">$host</span>;</span><br></pre></td></tr></table></figure>

<p>此外，服务器名可以和后端服务器的端口一起传送：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxy_set_header Host <span class="variable">$host</span>:<span class="variable">$proxy_port</span>;</span><br></pre></td></tr></table></figure>

<p>如果某个请求头的值为空，那么这个请求头将不会传送给后端服务器：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxy_set_header Accept-Encoding <span class="string">""</span>;</span><br></pre></td></tr></table></figure>

<h2 id="document-uri、-uri-与-request-uri"><a href="#document-uri、-uri-与-request-uri" class="headerlink" title="$document_uri、$uri 与 $request_uri"></a>$document_uri、$uri 与 $request_uri</h2><p>$document_uri 与 $uri 一样</p>
<p>$uri 指的是请求的文件和路径，不包含 ”?” 或者 ”#” 之类的东西</p>
<p>$request_uri 则指的是请求的整个字符串，包含了后面请求的东西（”?”、”#”等）</p>
<p>例如，请求地址：<a href="https://www.baidu.com/s?wd=nginx" target="_blank" rel="noopener">https://www.baidu.com/s?wd=nginx</a></p>
<p>$uri：<code>/s</code></p>
<p>$request_uri：<code>/s?wd=nginx</code></p>
<h2 id="upstream"><a href="#upstream" class="headerlink" title="upstream"></a>upstream</h2><p>nginx 负载均衡</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title>vite</title>
    <url>/zh/2021/03/11/vite/</url>
    <content><![CDATA[<p>vite</p>
<a id="more"></a>

<p><a href="https://cn.vitejs.dev/guide" target="_blank" rel="noopener">vite</a></p>
<h2 id="现实问题"><a href="#现实问题" class="headerlink" title="现实问题"></a>现实问题</h2><p>在浏览器支持 ES 模块之前，开发者没有以模块化的方式开发 JavaScript 的原生机制。这也是 “打包” 这个概念出现的原因：使用工具抓取、处理和链接我们的源码模块到文件中，使其可以运行在浏览器中。然而，当我们开始构建越来越大型的应用时，需要处理的 JavaScript 代码量也呈指数级增长。大型项目包含数千个模块的情况并不少见。我们开始遇到性能瓶颈 —— 使用 JavaScript 开发的工具通常需要很长时间（甚至是几分钟！）才能启动开发服务器，即使使用 HMR，文件修改后的效果也需要几秒钟才能在浏览器中反映出来。如此循环往复，迟钝的反馈会极大地影响开发者的开发效率和幸福感。</p>
<p>Vite 旨在利用生态系统中的新进展解决上述问题：浏览器开始原生支持 ES 模块，越来越多 JavaScript 工具使用编译型语言编写。</p>
<h3 id="缓慢的服务器启动："><a href="#缓慢的服务器启动：" class="headerlink" title="缓慢的服务器启动："></a>缓慢的服务器启动：</h3><p>当冷启动开发服务器时，基于打包器的方式是在提供服务前去急切地抓取和构建你的整个应用。</p>
<p>Vite 通过在一开始将应用中的模块区分为 依赖 和 源码 两类，改进了开发服务器启动时间。</p>
<p>依赖 大多为纯 JavaScript 并在开发时不会变动。一些较大的依赖（例如有上百个模块的组件库）处理的代价也很高。依赖也通常会以某些方式（例如 ESM 或者 CommonJS）被拆分到大量小模块中。</p>
<p>Vite 将会使用 esbuild 预构建依赖。</p>
<p>源码 通常包含一些并非直接是 JavaScript 的文件，需要转换（例如 JSX，CSS 或者 Vue/Svelte 组件），时常会被编辑。同时，并不是所有的源码都需要同时被加载。（例如基于路由拆分的代码模块）。</p>
<p>Vite 以 原生 ESM 方式服务源码。这实际上是让浏览器接管了打包程序的部分工作：Vite 只需要在浏览器请求源码时进行转换并按需提供源码。根据情景动态导入的代码，即只在当前屏幕上实际使用时才会被处理。</p>
<h3 id="缓慢的更新："><a href="#缓慢的更新：" class="headerlink" title="缓慢的更新："></a>缓慢的更新：</h3><p>当基于打包器启动时，编辑文件后将重新构建文件本身。显然我们不应该重新构建整个包，因为这样更新速度会随着应用体积增长而直线下降。</p>
<p>一些打包器的开发服务器将构建内容存入内存，这样它们只需要在文件更改时使模块图的一部分失活[1]，但它也仍需要整个重新构建并重载页面。</p>
<p>这样代价很高，并且重新加载页面会消除应用的当前状态，所以打包器支持了动态模块热重载（HMR）：允许一个模块 “热替换” 它自己，而对页面其余部分没有影响。这大大改进了开发体验 - 然而，在实践中我们发现，即使是 HMR 更新速度也会随着应用规模的增长而显著下降。</p>
<p>在 Vite 中，HMR 是在原生 ESM 上执行的。当编辑一个文件时，Vite 只需要精确地使已编辑的模块与其最近的 HMR 边界之间的链失效（大多数时候只需要模块本身），使 HMR 更新始终快速，无论应用的大小。</p>
<p>Vite 同时利用 HTTP 头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）：源码模块的请求会根据 304 Not Modified 进行协商缓存，而依赖模块请求则会通过 Cache-Control: max-age=31536000,immutable 进行强缓存，因此一旦被缓存它们将不需要再次请求。</p>
<h2 id="为什么生产环境仍需打包"><a href="#为什么生产环境仍需打包" class="headerlink" title="为什么生产环境仍需打包?"></a>为什么生产环境仍需打包?</h2><p>尽管原生 ESM 现在得到了广泛支持，但由于嵌套导入会导致额外的网络往返，在生产环境中发布未打包的 ESM 仍然效率低下（即使使用 HTTP/2）。</p>
<p>为了在生产环境中获得最佳的加载性能，最好还是将代码进行 tree-shaking、懒加载和 chunk 分割（以获得更好的缓存）。</p>
<h2 id="vite-为何不用-esbuild-？"><a href="#vite-为何不用-esbuild-？" class="headerlink" title="vite 为何不用 esbuild ？"></a>vite 为何不用 esbuild ？</h2><p><a href="https://esbuild.github.io/" target="_blank" rel="noopener">esbuild</a></p>
<p>esbuild &gt; rollup &gt; wepack &gt; parcel</p>
<p>虽然 esbuild 快得惊人，并且已经是一个在构建库方面比较出色的工具，但一些针对构建 应用 的重要功能仍然还在持续开发中 —— 特别是代码分割和 CSS 处理方面。就目前来说，Rollup 在应用打包方面更加成熟和灵活。尽管如此，当未来这些功能稳定后，我们也不排除使用 esbuild 作为生产构建器的可能。</p>
<p><a href="https://webpack.docschina.org/concepts/hot-module-replacement/" target="_blank" rel="noopener">concepts-HMR</a><br><a href="https://webpack.docschina.org/guides/hot-module-replacement/" target="_blank" rel="noopener">guides-HMR</a></p>
<p>Hot Module Replacement</p>
<p><a href="https://zhuanlan.zhihu.com/p/30669007" target="_blank" rel="noopener">Webpack HMR 原理解析</a><br><a href="https://juejin.cn/post/6844904008432222215" target="_blank" rel="noopener">轻松理解webpack热更新原理</a><br><a href="https://segmentfault.com/a/1190000020310371" target="_blank" rel="noopener">彻底搞懂并实现webpack热更新原理</a></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack中alias别名配置</title>
    <url>/zh/2018/08/13/webpack%E4%B8%ADalias%E5%88%AB%E5%90%8D%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<p>webpack 中 alias 别名配置</p>
<a id="more"></a>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">resolve: &#123;</span><br><span class="line"> alias: &#123;</span><br><span class="line">   <span class="string">'@'</span>: path.resolve(__dirname, <span class="string">'src'</span>),</span><br><span class="line">   <span class="string">'@a'</span>: path.resolve(__dirname, <span class="string">'src'</span>, <span class="string">'assets'</span>),</span><br><span class="line">   <span class="string">'@c'</span>: path.resolve(__dirname, <span class="string">'src'</span>, <span class="string">'components'</span>),</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在 js 中使用：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原本这样写</span></span><br><span class="line"><span class="keyword">import</span> formatTime <span class="keyword">from</span> <span class="string">'../../src/utils/formatTime'</span></span><br><span class="line"><span class="keyword">import</span> banner <span class="keyword">from</span> <span class="string">'../../src/assets/img/banner.png'</span></span><br><span class="line"><span class="keyword">import</span> swiper <span class="keyword">from</span> <span class="string">'../../src/components/swiper'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 现在可以这样写</span></span><br><span class="line"><span class="keyword">import</span> formatTime <span class="keyword">from</span> <span class="string">'@/utils/formatTime'</span></span><br><span class="line"><span class="keyword">import</span> banner <span class="keyword">from</span> <span class="string">'@/src/assets/img/banner.png'</span></span><br><span class="line"><span class="keyword">import</span> swiper <span class="keyword">from</span> <span class="string">'@/src/components/swiper'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> banner <span class="keyword">from</span> <span class="string">'@a/img/banner.png'</span></span><br><span class="line"><span class="keyword">import</span> swiper <span class="keyword">from</span> <span class="string">'@c/swiper'</span></span><br></pre></td></tr></table></figure>

<p>在 scss 中使用：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 原本这样写 */</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'../../src/assets/css/mixin'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 现在可以这样写 */</span></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'~@src/assets/css/mixin'</span>;</span><br><span class="line"></span><br><span class="line">@<span class="keyword">import</span> <span class="string">'~@a/css/mixin'</span>;</span><br></pre></td></tr></table></figure>

<p>在 template 中使用：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 原本这样写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"../../src/assets/img/logo.png"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 现在可以这样写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"~@/src/assets/img/logo.png"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"~@a/img/logo.png"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>注意区别，<code>@</code> 前需要多加个 <code>~</code></p>
]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>健康指标</title>
    <url>/zh/2018/08/14/%E5%81%A5%E5%BA%B7%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<p>罗列一些生活中需要知道健康指标。</p>
<a id="more"></a>

<h1 id="血糖"><a href="#血糖" class="headerlink" title="血糖"></a>血糖</h1><p>血中的葡萄糖称为血糖。</p>
<p>血糖的来源包括：①食物消化、吸收；②肝内储存的糖原分解；③脂肪和蛋白质的转化。</p>
<p>血糖的去路包括：①氧化转变为能量；②转化为糖原储存于肝脏、肾脏和肌肉中；③转变为脂肪和蛋白质等其他营养成分加以储存。</p>
<p>胰岛是体内调节血糖的血糖浓度的主要器官，肝脏储存肝糖元。此外，血糖浓度还受神经、内分泌激素的调节。</p>
<h2 id="血糖值"><a href="#血糖值" class="headerlink" title="血糖值"></a>血糖值</h2><h3 id="空腹血糖"><a href="#空腹血糖" class="headerlink" title="空腹血糖"></a>空腹血糖</h3><p>全血血糖(手指)。血浆血糖(静脉)。</p>
<p>空腹血糖正常值，全血血糖：3.89～6.11 mmol/L，血浆血糖：3.90～6.90 mmol/L</p>
<p>空腹全血血糖 ≥ 6.70 mmol/L，血浆血糖 ≥ 7.80 mmol/L，2 次重复测定可诊断为糖尿病。</p>
<h3 id="餐后血糖"><a href="#餐后血糖" class="headerlink" title="餐后血糖"></a>餐后血糖</h3><p>餐后 1 小时：血糖 6.7-9.4 mmol/L。最多也不超过 11.1 mmol/L。</p>
<p>餐后 2 小时：血糖 ≤ 7.8 mmol/L。</p>
<p>餐后 3 小时：第三小时后恢复正常，各次尿糖均为阴性。</p>
<h3 id="孕妇血糖"><a href="#孕妇血糖" class="headerlink" title="孕妇血糖"></a>孕妇血糖</h3><p>空腹不超过 5.1 mmol/L。</p>
<p>餐后 1 小时不得超过 10.0 mmol/L 才是血糖的正常水平。</p>
<h2 id="糖尿病"><a href="#糖尿病" class="headerlink" title="糖尿病"></a>糖尿病</h2><p>糖尿病患者的空腹血糖参考值：</p>
<p>轻度糖尿病：7.0<del>8.4 mmol/L，中度糖尿病：8.4</del>11.1 mmol/L，重度糖尿病：大于 11.1 mmol/L。</p>
<h2 id="药物"><a href="#药物" class="headerlink" title="药物"></a>药物</h2><p>二甲双胍。</p>
<ol>
<li>二甲双胍片首选用单纯饮食控制及体育锻炼治疗无效的2型糖尿病，特别是肥胖的2型糖尿病。</li>
<li>本品与胰岛素合用，可减少胰岛素用量，防止低血糖发生。</li>
<li>可与磺酰脲类降血糖药合用，具协同作用。</li>
</ol>
<p>服用本品时应尽量避免饮酒。</p>
<h2 id="哪些食物降血糖"><a href="#哪些食物降血糖" class="headerlink" title="哪些食物降血糖"></a>哪些食物降血糖</h2><p>1.饮食宜清淡，忌辛辣，低糖、低油、低盐，按时饮食</p>
<p>2.可以吃：苦瓜、洋葱、山药、海带、魔芋多吃，冬瓜、芹菜、菠菜、藕等少吃</p>
<p>3.可以吃：柚子、苹果、橘子、樱桃、草莓、梨、桃等升糖指数比较低，西瓜吃靠近瓜皮的，不吃瓜心</p>
<p>4.不能吃：香蕉、山楂、柿子、枣子</p>
<p>5.多喝凉白开，不要憋尿</p>
<p>6.检测足部，保护足部</p>
<p>7.多做足部运动，踮脚、脚趾抓地、泡完脚后用掌心搓脚心</p>
<p>8.不含糖的甜味剂，比如木糖醇、三氯蔗糖、阿斯巴甜、甜菊糖苷这类甜味剂；如果含有这些的食品，可以少量食用。燕麦片</p>
<p>多吃：冬瓜、苦瓜、洋葱、山药、海带、魔芋、芹菜、菠菜、木耳、藕</p>
<h3 id="燕麦片"><a href="#燕麦片" class="headerlink" title="燕麦片"></a>燕麦片</h3><p>燕麦片是燕麦粒轧制而成，呈扁平状，直径约相当于黄豆粒，形状完整的一种食品。燕麦煮出来高度粘稠，其中 beta 葡聚糖健康成分所带来的，具有降血脂、降血糖、高饱腹的效果，长期食用具有减肥功效。此外，燕麦中含有丰富的维生素 B1、B2、E、叶酸等，可以改善血液循环、缓解生活工作带来的压力；含有的钙、磷、铁、锌、锰等矿物质也有预防骨质疏松、促进伤口愈合、防止贫血的功效。</p>
<h3 id="魔芋"><a href="#魔芋" class="headerlink" title="魔芋"></a>魔芋</h3><p>降血糖、降血脂、降血压、散毒、养颜、通脉、减肥、通便、开胃。</p>
<p>生魔芋有毒，必须煎煮 3 小时以上才可食用。</p>
<p>消化不良的人，每次食量不宜过多。</p>
<p>有皮肤病的人少食。</p>
<p>魔芋性寒，有伤寒感冒症状的应少食用。</p>
<h3 id="海带"><a href="#海带" class="headerlink" title="海带"></a>海带</h3><p>海带是一种营养价值很高的蔬菜，同时具有一定的药用价值。含有丰富的碘等矿物质元素。海带含热量低、蛋白质含量中等、矿物质丰富。研究发现，海带具有降血脂、降血糖、调节免疫、抗凝血、抗肿瘤、排铅解毒和抗氧化等多种生物功能。</p>
<p>吃海带后不要马上喝茶(茶含鞣酸)，也不要立刻吃酸涩的水果(酸涩水果含植物酸)。</p>
<p>吃多也不好，会得甲亢。</p>
<h3 id="山药"><a href="#山药" class="headerlink" title="山药"></a>山药</h3><p>具有滋养强壮，助消化，敛虚汗，止泻之功效，主治脾虚腹泻、肺虚咳嗽、糖尿病消渴、小便短频、遗精、妇女带下及消化不良的慢性肠炎。</p>
<h1 id="血压"><a href="#血压" class="headerlink" title="血压"></a>血压</h1><p>是指血液在血管内流动时作用于单位面积血管壁的侧压力，它是推动血液在血管内流动的动力。在不同血管内被分别称为动脉血压、毛细血管压和静脉血压，通常所说的血压是指体循环的动脉血压。</p>
<p>影响动脉血压的因素主要有五个方面：①每搏输出量；②外周阻力；③心率；④主动脉和大动脉管壁的弹性；⑤循环血量与血管容量。</p>
<h2 id="血压值"><a href="#血压值" class="headerlink" title="血压值"></a>血压值</h2><p>收缩压：高压。舒张压：低压。</p>
<p>正常成人安静状态下的血压范围较稳定，正常范围收缩压 90～139 mmHg，舒张压 60～89 mmHg，脉压 30～40 mmHg。</p>
<p>高血压：未使用抗高血压药的前提下，18 岁以上成人收缩压 ≥ 140 mmHg 和(或)舒张压 ≥ 90mmHg。</p>
<p>低血压：未使用抗高血压药的前提下，18 岁以上成人收缩压 &lt; 90 mmHg 和(或)舒张压 &lt; 60mmHg。</p>
<h2 id="哪些食物降血压"><a href="#哪些食物降血压" class="headerlink" title="哪些食物降血压"></a>哪些食物降血压</h2><h3 id="茄子"><a href="#茄子" class="headerlink" title="茄子"></a>茄子</h3><p>降低胆固醇，降血脂、降血压，防治胃癌，治疗慢性胃炎、肾炎水肿，防治坏血病及促进伤口愈合，清热解毒。</p>
<p>消化不良、容易腹泻、脾胃虚寒、便溏症状的人不宜多吃。</p>
<p>秋后的茄子有一定的毒素，不要吃。</p>
<h3 id="白萝卜"><a href="#白萝卜" class="headerlink" title="白萝卜"></a>白萝卜</h3><p>清肠排毒，促进消化，增强食欲，防癌抗癌，降血压</p>
<h3 id="芹菜"><a href="#芹菜" class="headerlink" title="芹菜"></a>芹菜</h3><p>降低胆固醇，降血压</p>
<p>【芹菜+鸡肉】容易伤元气。</p>
<p>【芹菜+兔肉】容易引起脱皮。</p>
<h1 id="BMI-指数"><a href="#BMI-指数" class="headerlink" title="BMI 指数"></a>BMI 指数</h1><p>身体质量指数，简称体质指数，又称体重.</p>
<p>体质指数(BMI)= 体重(kg)÷ 身高(m)^ 2</p>
<p>成人的BMI数值：</p>
<ul>
<li>过轻：低于 18.5</li>
<li>正常：18.5-23.9</li>
<li>过重：24-27</li>
<li>肥胖：28-32</li>
<li>非常肥胖：高于 32</li>
</ul>
<p>60 / (1.68 * 1.68) = 21.26</p>
<p>65 / (1.68 * 1.68) = 23.04</p>
<p>67 / (1.68 * 1.68) = 23.74</p>
<p>60 / (1.70 * 1.70) = 20.77</p>
<p>65 / (1.70 * 1.70) = 22.50</p>
<p>69 / (1.70 * 1.70) = 23.88</p>
<p>60 / (1.72 * 1.72) = 20.29</p>
<p>65 / (1.72 * 1.72) = 21.98</p>
<p>70 / (1.72 * 1.72) = 23.67</p>
<h1 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h1><h2 id="韭菜"><a href="#韭菜" class="headerlink" title="韭菜"></a>韭菜</h2><p>补肾，健胃，提神，降低胆固醇。</p>
<p>春食则香，夏食则臭。</p>
<p>【韭菜+菠菜】同食会有滑肠作用，容易引起腹泻。</p>
<p>【韭菜+牛肉】发 热动火，引起牙齿肿痛，口疮。</p>
<p>【韭菜+白酒】引起胃炎，胃溃肠病复发。</p>
<p>【韭菜+蜂蜜】同食容易引起腹泻。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>健康</tag>
      </tags>
  </entry>
  <entry>
    <title>免费域名申请与使用</title>
    <url>/zh/2019/03/17/%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D%E7%94%B3%E8%AF%B7%E4%B8%8E%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p>分享一下如何申请一个免费域名</p>
<a id="more"></a>

<h1 id="域名申请"><a href="#域名申请" class="headerlink" title="域名申请"></a>域名申请</h1><p>在这个 <a href="http://www.freenom.com/zh/index.html" target="_blank" rel="noopener">freenom</a> 页面上，注册登录</p>
<h2 id="检查域名是否可用"><a href="#检查域名是否可用" class="headerlink" title="检查域名是否可用"></a>检查域名是否可用</h2><p>例如输入 <code>zhouyu.com</code>，检查是否可用。</p>
<p>当然一般是要钱的。</p>
<p>然后选一个免费的，如 <code>zhouyu.cf</code> 后缀名像游戏 <code>cf</code> 好记。免费域名只支持 <code>http</code> 不支持 <code>https</code>。</p>
<h2 id="管理已选域名"><a href="#管理已选域名" class="headerlink" title="管理已选域名"></a>管理已选域名</h2><p>在这个 <a href="https://my.freenom.com/clientarea.php?action=domains" target="_blank" rel="noopener">域名列表</a> 页面上，管理域名</p>
<p>Manage -&gt; Management Tools -&gt; Nameservers -&gt; Use custom nameservers (enter below)</p>
<p>在 <code>Nameserver 1</code> 输入 <code>F1G1NS1.DNSPOD.NET</code></p>
<p>在 <code>Nameserver 2</code> 输入 <code>F1G1NS2.DNSPOD.NET</code></p>
<h2 id="域名解析"><a href="#域名解析" class="headerlink" title="域名解析"></a>域名解析</h2><p>在这个 <a href="https://www.qcloud.com/" target="_blank" rel="noopener">腾讯云</a> 页面上，注册登录。</p>
<p>控制台 -&gt; 域名解析 -&gt; 添加解析 -&gt; 填写域名 <code>zhouyu.cf</code></p>
<p>点击对应域名的解析按钮 -&gt; 快速添加网站 -&gt; 绑定对应主机/服务器的 IP 地址</p>
<p>一个 <code>IP</code> 可以对应多个域名，后期用 <code>nginx</code> 去管理。</p>
<p>以及在这个 <a href="https://www.dnspod.cn/" target="_blank" rel="noopener">dnspod</a> 页面上，注册登录。</p>
<p>可用开启 D 监控，时刻查看域名状况。</p>
<h2 id="购买主机-服务器"><a href="#购买主机-服务器" class="headerlink" title="购买主机/服务器"></a>购买主机/服务器</h2><p>上面域名解析需要绑定对应主机/服务器的 IP 地址，这需要购买了。当然也可以免费申请。</p>
<p>我们如果需要翻墙（爬梯子），看一些特殊的神奇的东西，会购买 <code>vps</code> 之类的东西，例如有这样一个网站 <a href="https://www.vultr.com/" target="_blank" rel="noopener">vultr</a>。</p>
<p>购买后，我们就可用建自己的 <code>centOS</code>。</p>
<p>上面说的 <code>nginx</code> 就是在这 <code>centOS</code> 上安装管理。</p>
<h1 id="More"><a href="#More" class="headerlink" title="More"></a>More</h1><p>累了 睡觉</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title>全栈工程师的自我修养</title>
    <url>/zh/2019/11/04/%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB/</url>
    <content><![CDATA[<p>全栈工程师的自我修养</p>
<a id="more"></a>

<h1 id="什么是全栈？"><a href="#什么是全栈？" class="headerlink" title="什么是全栈？"></a>什么是全栈？</h1><p>既不是全端，也不是全站。</p>
<p>栈（Stack）：指一系列子模块的集合。这些软件子模块或者组件组合在一起即可实现既定功能，不再需要其他模块。</p>
<p>全栈工程师（Full-Stack Engineer）：表示为了完成一个项目，所需要的一系列技术的集合。</p>
<p>web栈：html+css+js（hcj） + apache+mysql+php（amp）</p>
<h1 id="为什么以前没有全栈？"><a href="#为什么以前没有全栈？" class="headerlink" title="为什么以前没有全栈？"></a>为什么以前没有全栈？</h1><ul>
<li>服务器管理员</li>
<li>数据库管理员</li>
<li>后台开发工程师</li>
<li>前端开发工程师</li>
</ul>
<p>优点：</p>
<ul>
<li>降低复杂度</li>
<li>提升质量</li>
<li>方便测试</li>
</ul>
<p>缺点：</p>
<ul>
<li>工程师职责不清 导致 效率低</li>
<li>工程师缺乏主人感 导致 产品体验差</li>
<li>工程师缺乏全局的视野 影响 个人成长</li>
</ul>
<h1 id="为什么现在可以了？"><a href="#为什么现在可以了？" class="headerlink" title="为什么现在可以了？"></a>为什么现在可以了？</h1><p>js / nodejs 越来越流行</p>
<h1 id="如何成为全栈工程师"><a href="#如何成为全栈工程师" class="headerlink" title="如何成为全栈工程师"></a>如何成为全栈工程师</h1><ul>
<li>一专多长（专业知识、专精、亮点，知识面广，作品说话）</li>
<li>围绕商业目标（服务于商业、减少成本、增加收入）</li>
<li>关注用户体验</li>
</ul>
<ul>
<li>初创型（60%）</li>
<li>成长型（30%）</li>
<li>成熟型（10%）</li>
</ul>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>职业</tag>
      </tags>
  </entry>
  <entry>
    <title>「2019 JSConf.Asia - 尤雨溪」在框架设计中寻求平衡</title>
    <url>/zh/2019/12/05/%E5%88%86%E4%BA%AB-2019%20JSConf.Asia%20-%20%E5%B0%A4%E9%9B%A8%E6%BA%AA%E3%80%8D%E5%9C%A8%E6%A1%86%E6%9E%B6%E8%AE%BE%E8%AE%A1%E4%B8%AD%E5%AF%BB%E6%B1%82%E5%B9%B3%E8%A1%A1/</url>
    <content><![CDATA[<p>「2019 JSConf.Asia - 尤雨溪」在框架设计中寻求平衡</p>
<a id="more"></a>

<h2 id="框架取舍"><a href="#框架取舍" class="headerlink" title="框架取舍"></a>框架取舍</h2><p>Scope、Render Mechanism、State Mechanism</p>
<p>第一：职责范围。从本质说是指这个框架可以为你做多少事情。</p>
<p>第二：渲染机制。当你在使用一个框架的时候，你会如何表达你的视图层，框架如何处理代码？它是如何将实际渲染东西展示到页面上的？</p>
<p>第三：状态机制。可变和不可变，脏检查和依赖追踪，响应式和类响应式。</p>
<h3 id="职责范围"><a href="#职责范围" class="headerlink" title="职责范围"></a>职责范围</h3><p>一个框架能为我们做什么事情？</p>
<p>我们将它一分为二，从你们的角度来看，这个框架或库能做一些特有的小事情，从我们的角度来看，我们会有很多整体性的考量，拿框架来说，我会尽量提供尽可能多的特性。</p>
<p>1、React &amp; Angular</p>
<p>React 接近于原生库，Angular 则提供更多抽象概念。</p>
<p>很少有人会去说清楚原理，这个库（React）专注于提供一个非常基础的 UI 模型，它专注于提供更底层的原生实现，基于此你可以构建出一套属于自己的抽象。</p>
<p>有意缩小职责范围（设计理念），这也是 React 整个生态系统非常活跃的原因所在，React的社区环境就像个商城（系统），围绕着 React 的核心模型自底向上建立起来的一整套生态系统。</p>
<p>另外一方面，像 Angular 以及其他的一些框架，如 Ember、 aralia 这种，则更像是大教堂吧。<br>它们则是自上而下进行设计的，在设计过程中，用户可能会遇到的问题都被考虑在内。</p>
<p>例如你们在日常开发中会经常遇到的表单验证，动画效果等等。</p>
<p>为了让框架可以给我们提供一个解决方案，在这个框架设计之初，我们就要以自上而下的方式来对它进行设计，即我们需要去思考如何将所有事情放到一起去工作。</p>
<p>有意扩大职责范围（设计理念），这个设计理念就是当你尝试解决一个问题时，你在框架内就能找到解决方案。</p>
<p>我们把这称之为大小职责范围（这里指两种设计理念），而这也没有好坏之说。</p>
<p>2、Small Scope</p>
<p>小的职责范围（设计理念）它的好处在于，刚开始的时候需要理解的概念很少。</p>
<p>而且它具有更好的灵活性。由于框架、库只提供了部分底层的原生实现，所以当你需要一个组件类的话，它得有一些 Props，然后你可以通过 Props 来传递数据，返回 VDOM 节点。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue.js 源码解析</title>
    <url>/zh/2019/04/16/%E5%88%86%E4%BA%AB-Vue.js%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-answershuto/</url>
    <content><![CDATA[<p><a href="https://github.com/answershuto/learnVue" target="_blank" rel="noopener">Vue.js 源码解析</a>。转。作者 answershuto。</p>
<a id="more"></a>

<h2 id="Vue-js响应式原理"><a href="#Vue-js响应式原理" class="headerlink" title="Vue.js响应式原理"></a>Vue.js响应式原理</h2><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty" target="_blank" rel="noopener">Object.defineProperty</a></p>
<p>将数据data变成可观察（observable）的</p>
<p>代理</p>
<p>一是通过observe将所有数据变成observable。二是将_data上面的数据代理到vm上</p>
<h2 id="Vue-js依赖收集"><a href="#Vue-js依赖收集" class="headerlink" title="Vue.js依赖收集"></a>Vue.js依赖收集</h2><p>做的是这样一件事：对于 data 中定义的某些变量，在实际模板中并没有被用到，修改这些变量时如何避免重新渲染模版？</p>
<p>???</p>
<h2 id="从Vue-js源码角度再看数据绑定"><a href="#从Vue-js源码角度再看数据绑定" class="headerlink" title="从Vue.js源码角度再看数据绑定"></a>从Vue.js源码角度再看数据绑定</h2><p>首先通过一次渲染操作触发Data的getter（这里保证只有视图中需要被用到的data才会触发getter）进行依赖收集，这时候其实Watcher与data可以看成一种被绑定的状态（实际上是data的闭包中有一个Deps订阅者，在修改的时候会通知所有的Watcher观察者），在data发生变化的时候会触发它的setter，setter通知Watcher，Watcher进行回调通知组件重新渲染的函数，之后根据diff算法来决定是否发生视图的更新。</p>
<p>Vue在初始化组件数据时，在生命周期的beforeCreate与created钩子函数之间实现了对data、props、computed、methods、events以及watch的处理。</p>
<p>Observer为数据加上响应式属性进行双向绑定。如果是对象则进行深度遍历，为每一个子对象都绑定上方法，如果是数组则为每一个成员都绑定上方法。</p>
<p>如果是修改一个数组的成员，该成员是一个对象，那只需要递归对数组的成员进行双向绑定即可。但这时候出现了一个问题：如果我们进行pop、push等操作的时候，push进去的对象根本没有进行过双向绑定，更别说pop了，那么我们如何监听数组的这些变化呢？ Vue.js提供的方法是重写push、pop、shift、unshift、splice、sort、reverse这七个数组方法。</p>
<p>看晕了，想睡觉zzzz</p>
<h2 id="Vue-js事件机制"><a href="#Vue-js事件机制" class="headerlink" title="Vue.js事件机制"></a>Vue.js事件机制</h2><p>四个事件API，分别是$on，$once，$off，$emit。</p>
<h2 id="VNode节点-Vue-js实现"><a href="#VNode节点-Vue-js实现" class="headerlink" title="VNode节点(Vue.js实现)"></a>VNode节点(Vue.js实现)</h2>]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>PNG图片压缩原理解析</title>
    <url>/zh/2019/04/16/%E5%88%86%E4%BA%AB-PNG%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-airuikun/</url>
    <content><![CDATA[<p><a href="https://mp.weixin.qq.com/s/YkCbGv35zjMgGZPV9w5bcw" target="_blank" rel="noopener">PNG图片压缩原理解析</a>。转。作者 airuikun。</p>
<a id="more"></a>

<h2 id="什么是-PNG-？"><a href="#什么是-PNG-？" class="headerlink" title="什么是 PNG ？"></a>什么是 PNG ？</h2><p>PNG 的全称叫便携式网络图型（Portable Network Graphics）是目前最流行的网络传输和展示的图片格式，原因有如下几点：</p>
<ul>
<li>无损压缩：PNG 图片采取了基于 LZ77 派生算法对文件进行压缩，使得它压缩比率更高，生成的文件体积更小，并且不损失数据。</li>
<li>体积小：它利用特殊的编码方法标记重复出现的数据，使得同样格式的图片，PNG 图片文件的体积更小。网络通讯中因受带宽制约，在保证图片清晰、逼真的前提下，优先选择 PNG 格式的图片。</li>
<li>支持透明效果：PNG 支持对原图像定义 256 个透明层次，使得图像的边缘能与任何背景平滑融合，这种功能是 GIF 和 JPEG 没有的。</li>
</ul>
<h2 id="PNG-类型"><a href="#PNG-类型" class="headerlink" title="PNG 类型"></a>PNG 类型</h2><p>PNG 图片主要有三个类型，分别为 PNG 8 / PNG 24 / PNG 32。</p>
<p>PNG8：PNG 8中的8，其实指的是8bits，相当于用2^8（2的8次方）大小来存储一张图片的颜色种类，2^8等于256，也就是说PNG 8能存储256种颜色，一张图片如果颜色种类很少，将它设置成PNG 8得图片类型是非常适合的。</p>
<p>PNG24：PNG 24中的24，相当于3乘以8 等于 24，就是用三个8bits分别去表示 R（红）、G（绿）、B（蓝）。R(0<del>255),G(0</del>255),B(0~255)，可以表达256乘以256乘以256=16777216种颜色的图片，这样PNG 24就能比PNG 8表示色彩更丰富的图片。但是所占用的空间相对就更大了。</p>
<p>PNG32：PNG 32中的32，相当于PNG 24 加上 8bits的透明颜色通道，就相当于R（红）、G（绿）、B（蓝）、A（透明）。R(0<del>255),G(0</del>255),B(0<del>255),A(0</del>255)。比PNG 24多了一个A（透明），也就是说PNG 32能表示跟PNG 24一样多的色彩，并且还支持256种透明的颜色，能表示更加丰富的图片颜色类型。</p>
<p>一类女神=PNG8：屌丝舔狗们见到第一类女神，顿时会觉得心情愉悦、笑逐颜开，屌丝发黑的印堂逐渐舒展，确认过眼神，是心动的感觉。</p>
<p>二类女神=PNG24：第二类女神开始厉害了，会给屌丝们一种菊花一紧、振聋发聩的心弦震撼，接触多了第二类女神能让屌丝每天精神抖擞，延年益寿。</p>
<p>三类女神=PNG32：在第三类女神面前，所有的语言都显得苍白无力。那是一种看了让屌丝上下通透、手眼通天的至尊级存在。超凡脱俗、天神下凡都不足以描摹她美色的二分之一。我曾经只有在梦里才见到过。</p>
<h2 id="PNG-图片数据结构"><a href="#PNG-图片数据结构" class="headerlink" title="PNG 图片数据结构"></a>PNG 图片数据结构</h2><p>PNG 图片的数据结构其实跟 http 请求的结构很像，都是一个数据头，后面跟着很多的数据块，如：</p>
<p>header -&gt; chunk -&gt; chunk -&gt; chunk -&gt; …</p>
<p>每一段十六进制编码就代表着一个特定的含义。</p>
<p>89504e470d0a1a0a：这个是 PNG 图片的头，所有的 PNG 图片的头都是这一串编码，图片软件通过这串编码判定这个文件是不是 PNG 格式的图片。</p>
<p>再 8 位是iHDR数据块的长度。</p>
<p>再 8 位是数据块的 type</p>
<p>再 8 位是图片的宽度</p>
<p>再 8 位是图片的高度</p>
<p>…</p>
<h2 id="什么样的-PNG-图片更适合压缩"><a href="#什么样的-PNG-图片更适合压缩" class="headerlink" title="什么样的 PNG 图片更适合压缩"></a>什么样的 PNG 图片更适合压缩</h2><p>颜色越单一，颜色值越少，压缩率就越大</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>小菜前端的技术栈是如何规划和演进的</title>
    <url>/zh/2019/04/16/%E5%88%86%E4%BA%AB-%E5%B0%8F%E8%8F%9C%E5%89%8D%E7%AB%AF%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A0%88%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%84%E5%88%92%E5%92%8C%E6%BC%94%E8%BF%9B%E7%9A%84-Scott/</url>
    <content><![CDATA[<p><a href="https://mp.weixin.qq.com/s/v7yT8pXt1UH9-FEWF8SfMg" target="_blank" rel="noopener">小菜前端的技术栈是如何规划和演进的</a>。转。作者 Scott。</p>
<a id="more"></a>

<h2 id="一、团队管理"><a href="#一、团队管理" class="headerlink" title="一、团队管理"></a>一、团队管理</h2><p>首先说团队管理，这个是前提，没有配套的团队管理手段辅助，是很难单纯的让技术栈发生持续的好的变化，也很难将架构理念推进落地的，在团队管理这里我主要是分成四步走。</p>
<h3 id="第一步-了解团队的长与短"><a href="#第一步-了解团队的长与短" class="headerlink" title="第一步 了解团队的长与短"></a>第一步 了解团队的长与短</h3><p>新加入到一个团队，尤其是成为资深工程师后新带领一个团队，除了埋头做事外，有一个很重要的事情要尽早做，那就是去了解团队，方式有很多，比如：</p>
<ul>
<li>主动去看团队仓库里的历史代码，了解大家的编码水平，编程风格，工程维护的方式，架构的成熟度</li>
<li>与每个同学单独聊聊天，聊聊他对于一个技术的看法，对于业务上思考，对于自己和所处团队的认知</li>
<li>请大家去吃吃饭，听听大家都聊什么，玩什么，关注什么，每个人的气场和表达方式，在办公桌和餐桌上有什么不同</li>
<li>找服务端团队和业务团队的同学，问问他们对于前端团队的印象，对于合作童鞋的看法</li>
<li>在会议上抛出一些问题，观察大家的参与积极性和表述观点的深度</li>
</ul>
<p>还可以一起去打游戏看电影，一起参加公司活动等等，这是一个比较粗的了解，我进团队后，也是挑了上面两三种方式对团队成员有了一个比较粗的摸底，看到了很多好的特征也看到了不少问题。</p>
<p>技术分享作为一个大家共同做的事情，让团队在这一件事情达成唯一的共识 - 技术团队影响力的提升和个人总结能力的提高。</p>
<h3 id="第二步-鞭策团队完善内部短板"><a href="#第二步-鞭策团队完善内部短板" class="headerlink" title="第二步 鞭策团队完善内部短板"></a>第二步 鞭策团队完善内部短板</h3><p>所谓内部短板，就是完全是自己的锅的问题，比如发布系统不完善，比如代码不规范，比如工具不健全这些都是甩都别想甩出去的锅，有了第一步的总结归纳后，就可以在这些问题里面，优先挑选跟业务有强关系的问题重点突破。</p>
<p>开发上线流：工程骨架 -&gt; 组件安装 -&gt; Mock -&gt; 代码校验 -&gt; 打包测试 -&gt; 打包线上 -&gt; 推包 -&gt; 配置白名单 -&gt; 审核发布</p>
<h3 id="第三步-推动团队迈向无主之地"><a href="#第三步-推动团队迈向无主之地" class="headerlink" title="第三步 推动团队迈向无主之地"></a>第三步 推动团队迈向无主之地</h3><p>如果已经解决掉了团队的核心内部问题，接下来就可以把跟产品，运营、业务有关系的环节完善掉了，比如 App 在线上运行的异常监控这些，实际上在创业公司，一般是没有一个部门直接对它负责的，大家都焦点在业务上，那么这时候从前端团队手里出去的作品，理应由前端自己驱动自己来为它负责，这里我把线上运行时的监控单独作为一条线，它配合内部问题的 Mock 阶段的 GPM（GraphQL 数据聚合服务层），都是跨出了前端团队的职能，与其他团队产生了关系</p>
<p>为公司内三不管的无主之地做一些协同的工具和系统，这会给团队带来很多正向的口碑，同时也有技术的提升，最重要的是，在内部问题和外部协同上，一旦你成为发起者和驱动者，你的角色和身份就发生了变化，你既是产品经理也是项目经理，既是需求方也是业务方，对于个人的综合能力会有很大的提升，对于整个团队在公司内部的影响力提升也有帮助，在工作中部门之间互相帮助也打下了一些底子，这一点对于不善表达比较木讷的工程师团队很有意义。</p>
<h3 id="第四步-鼓励团队技术与业务创新"><a href="#第四步-鼓励团队技术与业务创新" class="headerlink" title="第四步 鼓励团队技术与业务创新"></a>第四步 鼓励团队技术与业务创新</h3><p>从前面的三步，大家可以看出我的套路，带团队往前走，比较稳的方式就是从内到外，从技术到跨团队事务到业务，最终也就是第四步，再回归到业务和技术的结合，来利用技术创新驱动业务，利用业务可能性倒逼技术突破，这虽然不是终极态，但对于工程师团队已经是一个非常可接受的状态了。</p>
<h2 id="二、技术栈规划"><a href="#二、技术栈规划" class="headerlink" title="二、技术栈规划"></a>二、技术栈规划</h2><p>ReactJS</p>
<p>VueJS</p>
<p>NodeJS</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>我在孩子王的第一次分享</title>
    <url>/zh/2017/08/08/%E5%88%86%E4%BA%AB-%E6%88%91%E5%9C%A8%E5%AD%A9%E5%AD%90%E7%8E%8B%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<p>我在公司的第一次分享。分享两次事故。</p>
<a id="more"></a>

<p>7月4日，因为项目中有一个记录用户报名推荐人的需求（类似分享赚），这个需要从 cookie 中获取。由于工作人员对相关技术问题知之甚少，链接配置有问题会导致推荐人获取错误。为了定位这个问题，我私下和后端商议，多写入一个 location.href 的信息，但是双方都没有考虑到数据库的最大写入值。由于在测试及预发验证不到位，这个隐患问题没有被发现。下午4点左右发版上线。我于6点下班。很快在6点半到7点半之间陆续暴露出问题。急忙赶回家，7点50分左右，因为很清楚是什么地方改动，而且属于小改动，我对此进行修复。</p>
<p>总结：客观原因是，前端写入值超过后端数据库规定最大写入值，但后端未做拦截；主观原因是，我私下和后端商议，未考虑周全，未做风险评估，未上报测试。</p>
<p>8月8日，项目新需求准备发版，因框架升级可以修复之前的问题，所以借此次需求我对项目进行升级。在升级过程中，从本地到开发到测试到预发环境，依次都展现出框架升级后的各类问题，针对各类问题，我在各类环境进行修复。主要是框架升级后，和其他库或者代码有所冲突。本次升级还有个比较麻烦的事是在各类环境装包 npm install 或者 yarn install 都失败，因此我将本地包压缩上传到开发环境，再进行解压。很快，开发环境调通。再发布到测试环境，测试环境经过测试人员验证，也没有问题。再发布到预发布环境，依然正常。最后于下午3点半左右发版上线，因为框架升级，由运维解压包然后我重启服务器。注意，我隐约觉得有问题，发之前我也和测试透露出可能有问题（我心里知道会出现和预发布环境一样的包问题），但觉得预发布环境调通了，线上即使出现问题，应该很快就可以解决，过于自信，过于大胆，我让运维在两台服务器上同时进行解压，然后我同时进行了重启。下一秒后，整个项目挂了。我第一反应是，立马暂停服务器，从而线上报 502。然后我去看线上环境的包，发现线上包和预发布环境包不一样，我立马让运维重新进行解压，并且我尝试进行手动发布包。于此同时，陆续有人反应项目挂了，说明此时确实是高峰期。我和运维不断发布／上传／压缩／解压／重启，但是依然不成功，时间已经过去半个小时，这时候多方人员要求我先进行回滚。我说没法回滚，主要原因是太麻烦了，而且回滚了也不一定成功。因为整个项目进行了升级，很多包发生变化，新的包覆盖旧的包没有完全生效，此时若回滚，需要将旧的包重新上传对【旧-新杂交包】进行覆盖，我没有把握可以成功。在4点和5点之间我们还在定位问题，我一边让运维将线上的包全部删除后再重新安装，一边在准备回滚（将上个版本的打包尝试替换）。线上安装的很慢，而我这里回滚进展的也很慢。而时间已经到了下午5点，事故已经发生一个半小时，上级领导决定让运维将线上切到预发布，这样可以让项目暂时可用，毕竟预发布是正常的，可以堵住问题的继续喷发。这样我就暂停了回滚，继续和运维在线上服务器进行尝试安装包，期待是因为包的问题导致项目异常。下午6点左右，两台装了一个半小时包的服务器终于装完了。。。我立马进行重启，终于正常了。。。</p>
<p>总结：客观原因是，由于网络或其他原因，各环境装包困难，由本地装的包发到线上后，可能存在兼容问题，或者在解压覆盖过程中，出现偏差，具体是什么原因，真的不知道，反正包不对；主观原因是，我对框架进行升级，有一些包发生变化，这样可能带来隐患，未做考虑周全，未风险评估，未上报测试，虽然知道可能会出现问题但是没有做好事故发生的应对方案。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>我在孩子王的第二次分享</title>
    <url>/zh/2017/09/22/%E5%88%86%E4%BA%AB-%E6%88%91%E5%9C%A8%E5%AD%A9%E5%AD%90%E7%8E%8B%E7%9A%84%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<p>我在公司的第二次分享。分享前端一些基础知识；分享 node + express 做接口封装；分享 vue + typeScript 的实践。</p>
<a id="more"></a>

<h2 id="浏览器兼容性"><a href="#浏览器兼容性" class="headerlink" title="浏览器兼容性"></a>浏览器兼容性</h2><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">"&gt; 1%"</span>,</span><br><span class="line">  <span class="string">"last 3 versions"</span>,</span><br><span class="line">  <span class="string">"ie &gt;= 9"</span>,</span><br><span class="line">  <span class="string">"ios &gt;= 8"</span>,</span><br><span class="line">  <span class="string">"android &gt;= 4.4"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h2 id="防抖和节流"><a href="#防抖和节流" class="headerlink" title="防抖和节流"></a>防抖和节流</h2><p><a href="http://demo.nimius.net/debounce_throttle/" target="_blank" rel="noopener">防抖和节流</a></p>
<h3 id="防抖-debounce"><a href="#防抖-debounce" class="headerlink" title="防抖 debounce"></a>防抖 debounce</h3><p><a href="https://github.com/lodash/lodash/blob/master/debounce.js" target="_blank" rel="noopener">lodash.debounce</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> debounce = <span class="function"><span class="keyword">function</span>(<span class="params">func, wait, immediate</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// immediate 默认为 false</span></span><br><span class="line">  <span class="keyword">var</span> timeout, args, context, timestamp, result;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> later = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 当 wait 指定的时间间隔期间多次调用 debounce 返回的函数，则会不断更新 timestamp 的值，导致 last &lt; wait &amp;&amp; last &gt;= 0 一直为 true，从而不断启动新的计时器延时执行 func</span></span><br><span class="line">    <span class="keyword">var</span> last = +<span class="keyword">new</span> <span class="built_in">Date</span>() - timestamp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (last &lt; wait &amp;&amp; last &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">      timeout = setTimeout(later, wait - last);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      timeout = <span class="literal">null</span>;</span><br><span class="line">      <span class="keyword">if</span> (!immediate) &#123;</span><br><span class="line">        result = func.apply(context, args);</span><br><span class="line">        <span class="keyword">if</span> (!timeout) context = args = <span class="literal">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    context = <span class="keyword">this</span>;</span><br><span class="line">    args = <span class="built_in">arguments</span>;</span><br><span class="line">    timestamp = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line">    <span class="comment">// 第一次调用该方法时，且immediate为true，则调用func函数</span></span><br><span class="line">    <span class="keyword">var</span> callNow = immediate &amp;&amp; !timeout;</span><br><span class="line">    <span class="comment">// 在wait指定的时间间隔内首次调用该方法，则启动计时器定时调用func函数</span></span><br><span class="line">    <span class="keyword">if</span> (!timeout) timeout = setTimeout(later, wait);</span><br><span class="line">    <span class="keyword">if</span> (callNow) &#123;</span><br><span class="line">      result = func.apply(context, args);</span><br><span class="line">      context = args = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="节流-throttle"><a href="#节流-throttle" class="headerlink" title="节流 throttle"></a>节流 throttle</h3><h2 id="H5网页基础"><a href="#H5网页基础" class="headerlink" title="H5网页基础"></a>H5网页基础</h2>]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>我在小米的第一次分享</title>
    <url>/zh/2020/10/16/%E5%88%86%E4%BA%AB-%E6%88%91%E5%9C%A8%E5%B0%8F%E7%B1%B3%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<p>如何快速开发脚手架</p>
<a id="more"></a>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><h3 id="什么是-cli"><a href="#什么是-cli" class="headerlink" title="什么是 cli"></a>什么是 cli</h3><p>Command Line Interface，命令行工具，通过命令行来交互的工具或应用。</p>
<p>前端日常开发中，会遇见各种各样的 cli，比如：</p>
<p>  vue-cli</p>
<p>  create-react-app</p>
<p>  angular-cli</p>
<p>  webpack-dashboard</p>
<p>  webpack-cli</p>
<p>  gulp-cli</p>
<p>  …</p>
<p>web 开发者的辅助工具，旨在减少低级重复劳动，专注业务提高开发效率，规范 develop workflow。</p>
<p>使用 cli 的场景：</p>
<ul>
<li>快速生成应用模板，如 vue-cli 等根据与开发者的一些交互式问答生成应用框架。自己搭建脚手架、组件库等</li>
<li>创建 module 模板文件，如 angular-cli，创建 component、module 等。项目十分庞大，开发一个新页面需要大量繁琐的步骤</li>
<li>服务启动，serve</li>
<li>代码校验，lint</li>
<li>编译 build</li>
<li>自动化测试</li>
<li>编译分析</li>
<li>git 操作</li>
<li>生成的代码上传 CDN</li>
<li>其他小工具：http 请求 api、图片压缩、生成雪碧图等</li>
</ul>
<blockquote>
<p>比如 vue 常见的项目结构：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- src</span><br><span class="line">  - views</span><br><span class="line">    - a.vue</span><br><span class="line">  - components</span><br><span class="line">    - b.vue</span><br><span class="line">  - router</span><br><span class="line">    - routes</span><br><span class="line">  - api</span><br><span class="line">  - store</span><br><span class="line">    - actions</span><br><span class="line">    - mutations</span><br><span class="line">    - state</span><br></pre></td></tr></table></figure>

<p><strong>在 views、components 创建 .vue 文件 -&gt; 在 router 指定路由 -&gt; 在 api 新增接口 -&gt; 在 store 中处理接口</strong></p>
<blockquote>
<p>又比如 react 常见的项目结构：</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">- src</span><br><span class="line">  - feature</span><br><span class="line">    - a</span><br><span class="line">      - index.tsx</span><br><span class="line">      - components</span><br><span class="line">        - b.tsx</span><br><span class="line">      - redux</span><br><span class="line">        - constants.ts</span><br><span class="line">        - fetchData.ts</span><br><span class="line">        - hooks.ts</span><br><span class="line">        - initilState.ts</span><br><span class="line">        - reducer.ts</span><br></pre></td></tr></table></figure>

<p>推荐 <a href="http://rekit.js.org/docs/cli.html" target="_blank" rel="noopener">rekit</a></p>
<p><code>rekit add feature</code> <code>rekit add component</code> <code>rekit add action</code> …</p>
<p>以及上次分享 angular 中 <a href="https://angular.cn/cli" target="_blank" rel="noopener">@angular/cli</a></p>
<p><code>ng generate component hero-detail</code> …</p>
<h3 id="Node-js-编写-cli-的本质"><a href="#Node-js-编写-cli-的本质" class="headerlink" title="Node.js 编写 cli 的本质"></a>Node.js 编写 cli 的本质</h3><p>Node.js 编写的就是 js</p>
<blockquote>
<p>test/index.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>命令行调用</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; node index.js</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出：</span></span><br><span class="line">&gt; hello world</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>npm init</code> 新增 <code>package.json</code>，在 <code>scripts</code> 字段添加命令：</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"hello-cli"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"hello-cli"</span>: <span class="string">"node index.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>命令行调用</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; npm run hello-cli</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出：</span></span><br><span class="line">&gt; hello world</span><br></pre></td></tr></table></figure>

<h3 id="给-cli-命名"><a href="#给-cli-命名" class="headerlink" title="给 cli 命名"></a>给 cli 命名</h3><p><code>hello-cli</code></p>
<blockquote>
<p>test2/index.js</p>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/usr/bin/env node</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件顶部声明执行环境</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'hello world'</span>)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在 <code>package.json</code> 中添加：</p>
</blockquote>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"hello-cli"</span>,</span><br><span class="line">  <span class="attr">"bin"</span>: &#123;</span><br><span class="line">    <span class="attr">"hello-cli"</span>: <span class="string">"index.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在当前 <code>package.json</code> 目录下，执行 <code>npm link</code>，然后就会在 <code>node/v${version}/bin</code> 目录生成一个快捷方式</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm link</span><br><span class="line"></span><br><span class="line"><span class="built_in">cd</span> ~/.nvm/versions/node/v12.16.3/bin</span><br><span class="line"></span><br><span class="line">ls</span><br></pre></td></tr></table></figure>

<p>这样就能在任意地方执行 <code>hello-cli</code> 这个命令了</p>
<p>卸载：<code>npm uninstall -g hello-cli</code></p>
<h3 id="npm-link-后与-npm-scripts-的对比"><a href="#npm-link-后与-npm-scripts-的对比" class="headerlink" title="npm link 后与 npm scripts 的对比"></a>npm link 后与 npm scripts 的对比</h3><p>显而易见，脱离业务，全局使用，可以不断迭代开发发布</p>
<h2 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h2><h3 id="组件库"><a href="#组件库" class="headerlink" title="组件库"></a>组件库</h3><p><a href="https://github.com/zhouyu1993/rj-component-vue" target="_blank" rel="noopener">rj-component-vue</a> 组件库，<a href="https://zhouyu1993.github.io/awesome/rjcv/#/">demo</a>，<a href="https://zhouyu1993.github.io/awesome/rjcv/#/swiper">demo-swiper</a> …</p>
<p><code>npm run contribute xxxx</code> 新增组件</p>
<h3 id="脚手架"><a href="#脚手架" class="headerlink" title="脚手架"></a>脚手架</h3><p>有了 <code>vue-cli</code>、<code>create-react-app</code> 等，为什么还要自己开发脚手架？</p>
<p>前端往往是欲求不满的，希望自己折腾。随着业务的不断发展，必然会出现需要针对业务开发的实际情况来进行调整。例如：</p>
<ul>
<li>脚手架功能不足，每次新增又很麻烦</li>
<li>脚手架有些功能冗余，删除无用</li>
<li>融合公司业务特色</li>
<li>通过调整插件与配置实现性能优化</li>
</ul>
<p>总而言之，随着业务发展，需要追求“个性化”，走出一条具有「我米」特色的前端主义道路。</p>
<h4 id="脚手架要干什么事情"><a href="#脚手架要干什么事情" class="headerlink" title="脚手架要干什么事情"></a>脚手架要干什么事情</h4><p>功能丰富程度不同的脚手架，复杂程度自然也不太一样。但是总体来说，脚手架的工作大体都会包含几个步骤：</p>
<ul>
<li>init，初始化，一般是对环境的初始化，前置检查，选项配置</li>
<li>用户输入，自定义配置</li>
<li>生成配置文件</li>
<li>生成项目结构，需要定义一个项目模版</li>
<li>安装依赖</li>
<li>lint，代码检查，校验，清理等</li>
<li>component，组件/模块构建</li>
</ul>
<h4 id="定义一个项目模版"><a href="#定义一个项目模版" class="headerlink" title="定义一个项目模版"></a>定义一个项目模版</h4><p>脚手架其实就是复制粘贴，我们首先需要一个模版做样本。其中涉及到自定义可配置的部分，就需要我们使用模版变量进行动态填充。例如根据用户在终端中输入的内容，动态填充 <code>package.json</code> 中的 <code>name</code> 值。</p>
<h5 id="模版引擎"><a href="#模版引擎" class="headerlink" title="模版引擎"></a>模版引擎</h5><p>ejs、pug、artTemplate、handlehars…我一般使用artTemplate、handlehars，是大胡子语法，跟 vue 模版语言贴合。</p>
<h5 id="模版位置"><a href="#模版位置" class="headerlink" title="模版位置"></a>模版位置</h5><p>本地还是远程？放本地速度快，但升级困难；放远程便于升级</p>
<h4 id="构建脚手架"><a href="#构建脚手架" class="headerlink" title="构建脚手架"></a>构建脚手架</h4><p>这里举一个微信小程序脚手架的🌰</p>
<p><a href="https://github.com/zhouyu1993/rjmp-template" target="_blank" rel="noopener">rjmp-template</a> 小程序模版</p>
<ul>
<li>规范目录结构</li>
<li>css -&gt; sass/scss/less，内置常用 reset、mixin，小程序起初只支持 css</li>
<li>内置常用 components</li>
<li>内置常用 utils/plugins</li>
<li>第三方插件，如阿拉丁统计</li>
<li>内置 store，小程序起初没有 store 概念</li>
<li>支持 npm 构建，小程序起初不支持（<a href="https://github.com/zhouyu1993/rjmp-template/blob/master/compile.js" target="_blank" rel="noopener">compile.js</a>，参考 <a href="https://github.com/Tencent/wepy/tree/master/packages" target="_blank" rel="noopener">wepy</a>，遍历文件识别 require，读写，babel 转化，uglify 混淆）踩了一个 buffer 坑，加 npmHack 单独处理</li>
</ul>
<p><a href="https://github.com/zhouyu1993/rjmp-cli" target="_blank" rel="noopener">rjmp-cli</a> 生成小程序脚手架</p>
<ul>
<li><a href="https://github.com/tj/commander.js/blob/HEAD/Readme_zh-CN.md" target="_blank" rel="noopener">commander</a> 完整的 node.js 命令行解决方案</li>
<li>使用 <code>process.argv</code> 读取参数</li>
<li><a href="https://www.npmjs.com/package/inquirer" target="_blank" rel="noopener">inquirer</a> 常见的交互式命令行用户界面的集合</li>
<li><a href="https://www.npmjs.com/package/download-git-repo" target="_blank" rel="noopener">download-git-repo</a> 下载模版</li>
<li>自定义模版 <code>handlebars</code> 大胡子语法；渲染模版 <code>utils/render.js</code></li>
<li>安装依赖 <code>utils/install.js</code>，使用 <code>child_process</code> 开启子进程</li>
<li>界面美化：<ul>
<li><a href="https://github.com/chalk/chalk" target="_blank" rel="noopener">chalk</a> 彩色输出</li>
<li><a href="https://www.npmjs.com/package/log-symbols" target="_blank" rel="noopener">log-symbols</a> 彩色符号</li>
<li><a href="https://github.com/sindresorhus/ora" target="_blank" rel="noopener">ora</a> 创建 spinner，loading 加载中效果</li>
<li><a href="https://github.com/sindresorhus/boxen" target="_blank" rel="noopener">boxen</a> 创建头尾的那个小“面板”</li>
<li><a href="https://github.com/sindresorhus/beeper" target="_blank" rel="noopener">beeper</a>，发出 “哔” 声 😂 例如出错时报警</li>
</ul>
</li>
</ul>
<h2 id="衍生：微信小程序框架的演变"><a href="#衍生：微信小程序框架的演变" class="headerlink" title="衍生：微信小程序框架的演变"></a>衍生：微信小程序框架的演变</h2><p>这个脚手架是2018年开发的，当时供公司内部开发使用，后来离职把业务部分抽离后开放出去，不过已经不适用了，原因是微信小程序进入了云开发时代。</p>
<p>小程序框架开发 -&gt; wepy/mpvue/taro 开发 -&gt; 自定义开发 -&gt; 云开发</p>
<p>以前没有的现在基本都有了，而且前端能干后端的事。云数据库、云存储、云函数、云调用，实现热更新热修复。消息推送，去年为此还开发了一版适配小程序的小米推送 sdk。</p>
<hr>
<h1 id="web-app"><a href="#web-app" class="headerlink" title="web-app"></a>web-app</h1><p>Mobile</p>
<p>PC</p>
<h1 id="mini-app"><a href="#mini-app" class="headerlink" title="mini-app"></a>mini-app</h1><h1 id="quick-app"><a href="#quick-app" class="headerlink" title="quick-app"></a>quick-app</h1><h1 id="hybrid-app"><a href="#hybrid-app" class="headerlink" title="hybrid-app"></a>hybrid-app</h1><p>ionic</p>
<p>uni-app</p>
<p>react native</p>
<p>weex</p>
<p>flutter</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>我在小米的第二次分享</title>
    <url>/zh/2020/12/31/%E5%88%86%E4%BA%AB-%E6%88%91%E5%9C%A8%E5%B0%8F%E7%B1%B3%E7%9A%84%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%88%86%E4%BA%AB/</url>
    <content><![CDATA[<p><a href="https://zhouyu1993.github.io/share/浅谈帧动画.docx">浅谈帧动画</a></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>图解算法数据结构</title>
    <url>/zh/2021/03/17/%E5%9B%BE%E8%A7%A3%E7%AE%97%E6%B3%95%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/leetbook/detail/illustration-of-algorithm/" target="_blank" rel="noopener">图解算法数据结构</a></p>
<a id="more"></a>

<ul>
<li>算法：动态规划、回溯算法、查找算法、搜索算法、贪心算法、分治算法、位运算、双指针、排序、模拟、数学、……</li>
<li>数据结构：数组、栈、队列、字符串、链表、树、图、堆、哈希表、……</li>
</ul>
<p>大部分前端用 js，算法只知道查找、排序，数据结构只知道数组、字符串。</p>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>数据结构是为实现对计算机数据有效使用的各种数据组织形式，服务于各类计算机操作。</p>
<p>不同的数据结构具有各自对应的适用场景，旨在降低各种算法计算的时间与空间复杂度，达到最佳的任务执行效率。</p>
<p>常见的数据结构可分为「线性数据结构」与「非线性数据结构」。</p>
<p>「线性数据结构」Linear Data Structure：「数组」Array、「链表」Linked List、「栈」Stack、「队列」Queue。</p>
<p>「非线性数据结构」Non-linear Data Structure：「树」Tree、「堆」Heap、「散列表」Hashing、「图」Graph。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>数组是将相同类型的元素存储于连续内存空间的数据结构，其长度不可变。</p>
<p>「可变数组」是经常使用的数据结构，其基于数组和扩容机制实现，相比普通数组更加灵活。常用操作有：访问元素、添加元素、删除元素。</p>
<p>内存地址连续</p>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p>链表以节点为单位，每个元素都是一个独立对象，在内存空间的存储是非连续的。链表的节点对象具有两个成员变量：「值 val」，「后继节点引用 next」 。</p>
<p>建立此链表需要实例化每个节点，并构建各节点的引用指向。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListNode</span> (<span class="params">val, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.val = val || <span class="literal">null</span></span><br><span class="line">  <span class="keyword">this</span>.next = next || <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化节点</span></span><br><span class="line"><span class="keyword">const</span> n1 = <span class="keyword">new</span> ListNode(<span class="number">4</span>) <span class="comment">// head</span></span><br><span class="line"><span class="keyword">const</span> n2 = <span class="keyword">new</span> ListNode(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">const</span> n3 = <span class="keyword">new</span> ListNode(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建引用指向</span></span><br><span class="line">n1.next = n2</span><br><span class="line">n2.next = n3</span><br></pre></td></tr></table></figure>

<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈是一种具有「先入后出」特点的抽象数据结构，可使用数组或链表实现。</p>
<p>通过常用操作「入栈 push()」,「出栈 pop()」，展示了栈的先入后出特性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line"></span><br><span class="line">arr.push(<span class="number">1</span>) <span class="comment">// 元素 1 入栈</span></span><br><span class="line">arr.push(<span class="number">2</span>) <span class="comment">// 元素 2 入栈</span></span><br><span class="line"></span><br><span class="line">arr.pop() <span class="comment">// 元素 2 出栈</span></span><br><span class="line">arr.pop() <span class="comment">// 元素 1 出栈</span></span><br></pre></td></tr></table></figure>

<p><a href="https://blog.csdn.net/cartoon_/article/details/87992743" target="_blank" rel="noopener">Stack，ArrayDeque，LinkedList 的区别</a></p>
<p>Java 中 Stack，ArrayDeque，LinkedList 都可以作为栈使用，但在性能以及实现的细节上有些区别。</p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>队列是一种具有 「先入先出」 特点的抽象数据结构，可使用链表实现。</p>
<p>通过常用操作「入队 push()」,「出队 shift()」，展示了队列的先入先出特性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>()</span><br><span class="line"></span><br><span class="line">arr.push(<span class="number">1</span>) <span class="comment">// 元素 1 入栈</span></span><br><span class="line">arr.push(<span class="number">2</span>) <span class="comment">// 元素 2 入栈</span></span><br><span class="line"></span><br><span class="line">arr.shift() <span class="comment">// 元素 1 出栈</span></span><br><span class="line">arr.shift() <span class="comment">// 元素 2 出栈</span></span><br></pre></td></tr></table></figure>

<h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p>树是一种非线性数据结构，根据子节点数量可分为 「二叉树」 和 「多叉树」，最顶层的节点称为「根节点 root」。以二叉树为例，每个节点包含三个成员变量：「值 val」、「左子节点 left」、「右子节点 right」 。</p>
<p>建立此二叉树需要实例化每个节点，并构建各节点的引用指向。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TreeNode</span> (<span class="params">val, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.val = val || <span class="literal">null</span></span><br><span class="line">  <span class="keyword">this</span>.left = left || <span class="literal">null</span></span><br><span class="line">  <span class="keyword">this</span>.right = right || <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 实例化节点</span></span><br><span class="line"><span class="keyword">const</span> n1 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>) <span class="comment">// 根节点 root</span></span><br><span class="line"><span class="keyword">const</span> n2 = <span class="keyword">new</span> TreeNode(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">const</span> n3 = <span class="keyword">new</span> TreeNode(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">const</span> n4 = <span class="keyword">new</span> TreeNode(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">const</span> n5 = <span class="keyword">new</span> TreeNode(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建引用指向</span></span><br><span class="line">n1.left = n2</span><br><span class="line">n1.right = n3</span><br><span class="line"></span><br><span class="line">n2.left = n4</span><br><span class="line">n2.right = n5</span><br></pre></td></tr></table></figure>

<h3 id="图-？？？"><a href="#图-？？？" class="headerlink" title="图 ？？？"></a>图 ？？？</h3><p>图是一种非线性数据结构，由「节点（顶点）vertex」和「边 edge」组成，每条边连接一对顶点。根据边的方向有无，图可分为「有向图」和「无向图」。</p>
<p>顶点集合 vertices、边集合 edges</p>
<p>表示图的方法通常有两种：</p>
<p>1、邻接矩阵：使用数组 vertices 存储顶点，邻接矩阵 edges 存储边； edges[i][j] 代表 节点 i + 1 和 节点 j + 1 之间是否有边。<br>2、邻接表： 使用数组 vertices 存储顶点，邻接表 edges 存储边。edges 为一个二维容器，第一维 i 代表顶点索引，第二维 edges[i] 存储此顶点对应的边集和；例如 edges[0] = [1, 2, 3, 4] 代表 vertices[0] 的边集合为 [1, 2, 3, 4]。</p>
<blockquote>
<p>邻接矩阵 VS 邻接表 ：<br>邻接矩阵的大小只与节点数量有关，即 N^2，其中 N 为节点数量。因此，当边数量明显少于节点数量时，使用邻接矩阵存储图会造成较大的内存浪费。<br>因此，邻接表 适合存储稀疏图（顶点较多、边较少）；邻接矩阵 适合存储稠密图（顶点较少、边较多）。</p>
</blockquote>
<h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p>散列表是一种非线性数据结构，通过利用 Hash 函数将指定的「键 key」映射至对应的「值 value」，以实现高效的元素查找。</p>
<p><a href="https://es6.ruanyifeng.com/#docs/set-map#Map" target="_blank" rel="noopener">es6 之 Map</a></p>
<h3 id="堆-？？？"><a href="#堆-？？？" class="headerlink" title="堆 ？？？"></a>堆 ？？？</h3><p>堆是一种基于「完全二叉树」的数据结构，可使用数组实现。以堆为原理的排序算法称为「堆排序」，基于堆实现的数据结构为「优先队列」。堆分为「大顶堆」和「小顶堆」，大（小）顶堆：任意节点的值不大于（小于）其父节点的值。</p>
<blockquote>
<p>完全二叉树定义： 设二叉树深度为 k，若二叉树除第 k 层外的其它各层（第 1 至 k-1 层）的节点达到最大个数，且处于第 k 层的节点都连续集中在最左边，则称此二叉树为完全二叉树。</p>
</blockquote>
<h2 id="替换空格"><a href="#替换空格" class="headerlink" title="替换空格"></a>替换空格</h2><ol>
<li>正则表达式 \s 代表空格</li>
<li>遍历添加</li>
</ol>
<p>##</p>
<hr>
<ul>
<li>大海 10</li>
<li>心心苒 9.9</li>
<li>烟花 9.7</li>
<li>琳晚晚 9.6</li>
<li>幽若影 9.5 养老</li>
<li>钏言 9.3</li>
<li>尉迟 9.3</li>
<li>一柠檬一 9.2</li>
<li>灰发化 9.2</li>
<li>冰川 9.2</li>
<li>三千烟雨知江南 9.0 愿意</li>
<li>兰芝伤 9.0</li>
<li>幸运蓝莓 8.9</li>
<li>树莓味可乐 8.9</li>
<li>S5第一唐门 8.9</li>
<li>辣条 8.9</li>
<li>芊浅浅 8.8 养老</li>
<li>冷眸 8.8</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>好人有好报？</title>
    <url>/zh/2017/12/24/%E5%A5%BD%E4%BA%BA%E6%9C%89%E5%A5%BD%E6%8A%A5%EF%BC%9F/</url>
    <content><![CDATA[<p>好人有好报，这句话现在似乎变成了鸡汤。</p>
<a id="more"></a>

<p>今天是平安夜，本该是成双成对，你侬我侬着，显然我不是。</p>
<p>上午一踏进地铁站，听着地铁工作者特地点播的节日喜庆歌曲，心里却一直荡起，“lonely lonely christmas”，问我的心情，大概是哭笑不得。不过今天是出去旅游观光的，我得表现得 happy 点。</p>
<p>走马观花地看完大报应寺。</p>
<p><img src="/uploads/%E5%A4%A7%E6%8A%A5%E5%BA%94%E5%AF%BA.jpg" alt="大报应寺"></p>
<p>大报应寺，是继洛阳白马寺之后中国的第二座寺庙，也是中国南方建立的第一座佛寺。</p>
<p>大报恩寺内琉璃宝塔高达78.2米，通体用琉璃烧制，塔内外置长明灯一百四十六盏，自建成至衰毁一直是中国最高的建筑，也是世界建筑史上的奇迹，位列中世纪世界七大奇迹，被当时西方人视为代表中国的标志性建筑，有“中国之大古董，永乐之大窑器”之誉，被称为“天下第一塔”。</p>
<p>寺内阿育王塔中的佛顶骨舍利是世界现存唯一一枚佛祖(释迦摩尼)真身顶骨舍利，不过现在供奉于南京牛首山的佛顶宫中。</p>
<p>寺内三藏塔中供奉着玄奘法师(唐僧)的顶骨舍利。</p>
<p>南朝四百八十寺，多少楼台烟雨中。如今看风景，已全然没有少时那副怡然自得的欣赏，也不会看到一处就随口吟上一句相应的古诗。</p>
<p>大报应寺，报应报应，因果循环。</p>
<p>《吕祖说三世因果经》主要说的是：一是人的命是自己造就的；二是怎样为自己造一个好命；三是行善积德与行凶作恶干坏事的因果循环报应规律。因果报应指事物的起因和结果，种什么因，结什么果，宗教认为种什么因，结什么果报。</p>
<p>《涅槃经》讲：业有三报，一现报，现作善恶之报，现受苦乐之报；二生报，或前生作业今生报，或今生作业来生报；三速报，眼前作业，目下受报。</p>
<p>俗话说：善有善报，恶有恶报，不是不报，时候未到，时候一到，一切全报。</p>
<p>所以，常听周围说：好人有好报。</p>
<p>上面只是胡扯一通，瞎写一气，狗屁不是，不看也罢，看了无妨。</p>
<p>然而说说接下来的遭遇，报应真的一个接着一个，但我也没干什么坏事啊。</p>
<p>找了一家中华门城头下的羊肉馆，点一份羊杂汤，热乎吃完也罢。站着刚把钱付了，站我对面的是店家一老龄员工，手上端着估计有过百度的一大锅羊肉汤。大概是锅底被高温烫的脱掉了，哗啦啦，滚烫的羊肉汤顿时倾盆而下。恰巧泼到我脚下，我顿时炸毛，可由于这两年体态丰腴了些，敏捷性明显下降，还是慢了，左脚脚背被泼到了。顿时一股灼烧感从脚背传到头皮，疼得我牙痒痒。也不顾着形象了，当场脱了鞋袜。暗自感叹，还好鞋子好，防水，只是左脚一小片烫的发红。</p>
<p>事情发生到着，我先不往下说，各位先代入想想，假如是你遇到这种事情，你会怎么处理？</p>
<p>去医院和赔钱呗。但我们往往看到是一方抵赖，一方讹钱。我这花钱吃饭，却无端遭了这罪，脚被烫着，凭什么？另外我的鞋子虽然不算贵，也才几百块，经此一泼，虽然发挥些艰苦奋斗的精神，刷一刷还是照穿无误，但凭什么？当然事实是，老板说带我去医院，我说不用了，我也没有提要钱，甚至我都没让老板把我的单免了。脚被烫了一下而已，鞋子脏了而已，能忍则忍了，乡下人老实，不觉得这是多大事。但另一方面，也许是内心软弱吧，也许要被人以鲁迅先生的话训斥为“哀其不幸，怒其不争”。我们经常看到类似新闻，例如有，某一女子(不是歧视女性)的名牌包包被弄脏要求巨额赔偿，甚至说被人厌烦的碰瓷。我这里并不是说，我们遇到这事情，我们不该要求赔偿，如果确实有损失，那么要求赔偿是必然的。甚至是一些严重的事情，第一反应是报警去医院。不要为了钱而要钱，不要越过做人的底线。假如对方不是故意的，你也能够接受，不妨退一步海阔天空，人家也不容易，一大锅汤损失不少钱，不至于捡起来重煮吧。。。</p>
<p>大概看到这里，你会说，好人有好报的。你是在积德行善，将来你会娶个好老婆。</p>
<p>你可知，这只是开始。</p>
<p>我坐在城墙下的路边休息，阳光刺眼，我就闭眼假寐，顺便缓缓脚上的疼痛。突然一堆水溅了过来，不过这次是冷水，泼了我一腿。大哥，冰火两重天不是这么玩的啊，你怎么知道我脚需要降温，但是你浇鞋子就行了，浇我一腿干嘛。我看着晒水车扬长而去，看着那一行“城市清洁”字苦笑，我大概是城市垃圾。</p>
<p>我是不敢坐着了，赶紧站起来，朝着阳光，抖抖自己的裤子，自然风干吧。没过几分钟，哗啦啦，屁股一激灵，低头一看，我呢子大衣上挂着一颗颗水珠，投影着我胖乎乎的脸，我看着他们，他们看着我，仿佛听见一句和声，“傻逼”。不打招呼就来一场雷阵雨，我不想看啊。洒水大哥，你也挺幸苦的啊，政府规定要洒两遍还是咋地，我就站这休息，我犯法了吗，你不能提醒我一下？我是来大报应了吗？</p>
<p>不深入阐述了，也不说些什么升华的话语，鸡汤虽好喝，但是你们不爱喝啊。</p>
<p>我还活着，活着就好！</p>
<p>愿你喜乐安好！</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>人性</tag>
      </tags>
  </entry>
  <entry>
    <title>如何用保险保障自己的一生？</title>
    <url>/zh/2018/06/10/%E5%A6%82%E4%BD%95%E7%94%A8%E4%BF%9D%E9%99%A9%E4%BF%9D%E9%9A%9C%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%80%E7%94%9F%EF%BC%9F/</url>
    <content><![CDATA[<p>如何用保险保障自己的一生？</p>
<a id="more"></a>

<p>毕业后的这几年，保险这两个字逐渐进入我的视野。</p>
<p>保险，Insurance，本意是稳妥可靠保障；后延伸成一种保障机制，是用来规划人生财务的一种工具，是市场经济条件下风险管理的基本手段，是金融体系和社会保障体系的重要的支柱。</p>
<p>保险是一种保障机制，用来规避风险的。</p>
<h1 id="保险种类"><a href="#保险种类" class="headerlink" title="保险种类"></a>保险种类</h1><p>社会保险和商业保险</p>
<h2 id="社会保险"><a href="#社会保险" class="headerlink" title="社会保险"></a>社会保险</h2><p>是一种为丧失劳动能力、暂时失去劳动岗位或因健康原因造成损失的人口提供收入或补偿的一种社会和经济制度。</p>
<p>社会保险的主要项目包括养老保险、医疗保险、失业保险、工伤保险、生育保险，即所谓“五险一金”中的“五险”。</p>
<p>社会保险是一种缴费性的社会保障，资金主要是用人单位和劳动者本人共同缴纳，政府财政给予补贴并承担最终的责任。但是劳动者只有履行了法定的缴费义务，并在符合法定条件的情况下，才能享受相应的社会保险待遇。</p>
<p>社保是以城镇职工为保障对象的社会保险制度体系。</p>
<h3 id="社会医疗保险"><a href="#社会医疗保险" class="headerlink" title="社会医疗保险"></a>社会医疗保险</h3><p>包括城镇职工医疗保险，城镇居民医疗保险，新型农村合作医疗。</p>
<p>城乡居民基本医疗保险，是将城保和农保整合的新型保险制度，2016年提出，但目前还没有完全实现。</p>
<h4 id="城镇职工基本医疗保险"><a href="#城镇职工基本医疗保险" class="headerlink" title="城镇职工基本医疗保险"></a>城镇职工基本医疗保险</h4><p>就是“五险”中的医疗保险。</p>
<p>参保人是城镇职工。</p>
<h4 id="城镇居民基本医疗保险"><a href="#城镇居民基本医疗保险" class="headerlink" title="城镇居民基本医疗保险"></a>城镇居民基本医疗保险</h4><p>采取以政府为主导，以居民个人(家庭)缴费为主，政府适度补助为辅的筹资方式，按照缴费标准和待遇水平相一致的原则。</p>
<p>参保人是非从业的市民，具有城镇户口的人民。</p>
<h4 id="新型农村合作医疗保险"><a href="#新型农村合作医疗保险" class="headerlink" title="新型农村合作医疗保险"></a>新型农村合作医疗保险</h4><p>指由政府组织、引导、支持，农民自愿参加，个人、集体和政府多方筹资，以大病统筹为主的农民医疗互助共济制度。其采取个人缴费、集体扶持和政府资助的方式筹集资金。</p>
<p>参保人是农民，具有农村户口的人民。</p>
<h2 id="商业保险"><a href="#商业保险" class="headerlink" title="商业保险"></a>商业保险</h2><p>是指通过订立保险合同运营，以营利为目的的保险形式，由专门的保险企业经营。商业保险关系是由当事人自愿缔结的合同关系，投保人根据合同约定，向保险公司支付保险费，保险公司根据合同约定的可能发生的事故因其发生所造成的财产损失承担赔偿保险金责任，或者当被保险人死亡、伤残、疾病或达到约定的年龄、期限时承担给付保险金责任。</p>
<p>商业保险公司提供。</p>
<h3 id="强制保险"><a href="#强制保险" class="headerlink" title="强制保险"></a>强制保险</h3><p>机动车交通事故责任强制保险(交强险)</p>
<h3 id="非强制保险"><a href="#非强制保险" class="headerlink" title="非强制保险"></a>非强制保险</h3><ul>
<li>财产保险<ul>
<li>家庭财产保险<ul>
<li>房屋保险</li>
</ul>
</li>
</ul>
</li>
<li>人身保险<ul>
<li>意外伤害保险</li>
<li>健康保险<ul>
<li>医疗保险<ul>
<li>普通医疗保险</li>
<li>门(急)诊医疗保险</li>
<li>住院医疗保险</li>
<li>手术医疗保险</li>
<li>综合医疗保险</li>
</ul>
</li>
<li>疾病保险<ul>
<li>单项疾病保险</li>
<li>重大疾病保险</li>
</ul>
</li>
</ul>
</li>
<li>人寿保险<ul>
<li>定期人寿</li>
<li>终身人寿</li>
<li>生存保险</li>
<li>生死两全</li>
<li>养老保险</li>
</ul>
</li>
</ul>
</li>
</ul>
<h1 id="非强制但必备的商业保险"><a href="#非强制但必备的商业保险" class="headerlink" title="非强制但必备的商业保险"></a>非强制但必备的商业保险</h1><h2 id="房屋保险"><a href="#房屋保险" class="headerlink" title="房屋保险"></a>房屋保险</h2><p><a href="http://baoxian.pingan.com/product/jiatingcaichanbaoxian.shtml" target="_blank" rel="noopener">平安-家庭财产险</a></p>
<h2 id="意外伤害保险"><a href="#意外伤害保险" class="headerlink" title="意外伤害保险"></a>意外伤害保险</h2><p><a href="https://insurance.cekid.com/product/119" target="_blank" rel="noopener">孩子王-中国人寿-成人综合意外险</a></p>
<p>承保年龄18-50岁。保障期限1年。二级+公立医院。</p>
<p>意外身故伤残。意外医疗，门(急)诊、住院。</p>
<p>家庭成员人人必备！</p>
<h2 id="综合医疗保险"><a href="#综合医疗保险" class="headerlink" title="综合医疗保险"></a>综合医疗保险</h2><p><a href="https://insurance.cekid.com/product/140" target="_blank" rel="noopener">孩子王-平安-e生保</a></p>
<p><a href="http://chaoshi.pingan.com/baoxian/pinganeshengbao.shtml" target="_blank" rel="noopener">平安-e生保</a></p>
<p>首投28天到60岁，续保可到99岁。保障期限1年。二级+公立医院。</p>
<p>不限社保目录，自费药/进口药全可报。</p>
<p>不限疾病种类，门(急)诊、住院、手术均覆盖。</p>
<ul>
<li>一般医疗保险金</li>
<li>恶性肿瘤保险金</li>
</ul>
<p>有条件的话，家庭成员人人必备！因为是每次只保一年，所以没有先后之后。</p>
<h2 id="重大疾病保险"><a href="#重大疾病保险" class="headerlink" title="重大疾病保险"></a>重大疾病保险</h2><p><a href="http://www.kaixinbao.com/jiankang-baoxian/309551.shtml" target="_blank" rel="noopener">开心保-百年康惠保重大疾病保险</a></p>
<p>28天到55岁。100种重疾，30种轻症(轻症比较贵，不需要买，尤其是买了综合医疗保险后)。</p>
<p>家庭主心骨必备！</p>
<p>三高都是拒保的，所以早买早好，而且越早买保费越低。</p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="支付宝"><a href="#支付宝" class="headerlink" title="支付宝"></a>支付宝</h3><p>花钱与收钱，都可以领取保障金。</p>
<p>免费医疗金、门诊报销金。</p>
<p>门诊报销金：门诊保障可累计1000元，每次可报200元。门诊保障累计至1000元后，可继续累计大病保障(25种重大疾病)。</p>
<h3 id="京东金融"><a href="#京东金融" class="headerlink" title="京东金融"></a>京东金融</h3><p>签到送保障金</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>保险</tag>
      </tags>
  </entry>
  <entry>
    <title>新生态推送服务前期调研</title>
    <url>/zh/2019/01/30/%E6%96%B0%E7%94%9F%E6%80%81%E6%8E%A8%E9%80%81%E6%9C%8D%E5%8A%A1%E5%89%8D%E6%9C%9F%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<p>本文是对新生态推送服务前期调研的汇报。</p>
<a id="more"></a>

<p>利益相关，删除了</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title>机场初体验</title>
    <url>/zh/2018/04/30/%E6%9C%BA%E5%9C%BA%E5%88%9D%E4%BD%93%E9%AA%8C/</url>
    <content><![CDATA[<p>周六去了南京禄口机场。浪？不存在的。</p>
<a id="more"></a>

<p>长这么大，我没怎么出过江苏省。过年回老家会途径安徽，然后就是之前去浙江旅游过几次。省内其他城市也去的很少，无非镇江、无锡、常州等。</p>
<p>高铁都很少坐的我，飞机更是没当面见过。偶尔听到空中轰鸣，旁边哥们指着天空，大喊一句，“看，飞机！”此处@大学室友觊凯，我们会好奇地抬头仰望。</p>
<p>外公他今年79岁了，去年来南京的时候，我带着玩了两天，他去哪儿都免费，倒是我，陪着玩却花了不少门票钱。</p>
<p>他很早就想去新疆玩。并不是像很多西行青年一样，所谓的穷游体会人生，他去的主要原因还是那里有亲戚。</p>
<p>五一劳动节终于下定决心去。提前一个星期打电话给我，让我在网上订票。</p>
<p>第一次订飞机票，最简单方式，打开【支付宝】APP。这跟广告无关。推荐大家使用【孩子王】APP。嗯，这是条硬广。</p>
<p>点击首页快捷入口【更多】，找到【第三方服务】中的【火车票机票】。选择出发点与目的地，选择出发日期。由于家境一般，我只会选择筛选【经济舱】，这里不想解释。。。然后就是看起飞时间与价格。然后看航班类型。</p>
<p>关于航班类型，这里多说几句。分【直达】【经停】【中转】。直达意思很简单，从出发地直接飞到目的地，一般路程短时间少。经停是，经过某个地方停下来，然后再飞到目的地，一般是路程较远，而且出发地客源较少，飞机从出发地带第一批人，然后飞到经停地，再带第二批人，通常会让第一批人下飞机休息一会儿，并打扫飞机上卫生，当然如果遇到晚点，会让第一批人留在飞机上，并让第二批人迅速上飞机。而中转的意思是，从出发地坐第一架飞机坐到中转地，然后所有人都下飞机，到中转地的人直接走了，到目的地的人在中转地机场等第二架飞机飞到目的地。【经停】和【中转】的区别就是前者一架飞机，后者多架飞机，显然后者时间长。如果你不赶时间，而且想在中转地玩一玩，中转是个好选择，机票便宜，而且能多去一个城市。</p>
<p>因为外公年纪大，而且对航线这些不太懂，怕他转机麻烦，我选了经停。一般航线都是固定的，例如我选的南京去克拉玛依的深航ZH9591，都是早上6点55分起飞。</p>
<p>机票总价一般包含机票钱、基建燃油钱和保险钱。前两个是必交，后一个是选交。关于保险，航空意外险还是很有必要的。关于延误险，个人觉得，如果不赶时间，没必要选。</p>
<p>由于是第一次去机场，很多东西不懂，加上行李很多，要办托运，另外住的地方离禄口机场比较远，虽然有地铁，但是最早也要6点，所以为了保险起见，决定提前两小时打车过去。为了避免半夜叫不到车的尴尬，虽然我跟爸妈说半夜叫车也容易，但是还是于前一天晚上预约了滴滴。</p>
<p>大约5点到达机场。快下车的时候，司机问我是 T1 还是 T2。当时就懵逼了，啥意思？也怪自己英语丢回了英国，不懂 T 是啥意思。</p>
<p>一般机场包含多个航站楼 Terminals 。南京禄口机场有两个航站楼，即所谓的 T1 和 T2。原 T1 是货运，但目前 T1 已经“暂停休整”，所以 T2 正负责国内、国际出发。据了解，以后 T1 航站楼将主要承担国内航班的到发，T2 航站楼将承担国际及部分国内航班的到发。</p>
<p>关于航班动态信息，可登录<a href="http://www.njiairport.com/" target="_blank" rel="noopener">南京禄口国际机场</a>查看，也可关注微信公众号【南京禄口国际机场】。比如我们输入【ZH9591】可查询，可以得知在 T2，也可以得知对应的值机柜台。</p>
<p>到达 T2 后，在门口航班信息公告屏上也可查询到对应航班所在的值机柜台。然后找寻值机柜台所在地，然后找一台可用的自动取票机，凭身份证或护照或网值电子二维码领取登机牌。关于护照，这里只允许中国，包含港澳台地区。外国人必须在人工值机柜台领取登机牌。关于电子二维码，需要关注微信公众号【南京禄口国际机场】，然后在微信值机功能中领取电子二维码，而且必须提前60分钟办理，一般适用于无托运行李的旅客。凭电子二维码可以直接在国内安检通道进行安检，当然国外的是不行的。</p>
<p>另外老人岁数比较大，自动取票机也是不支持的，必须走人工值机柜台，需要询问健康。我外公岁数大，所以就需要等工作人员上班。还要注意自己是什么舱，例如经济舱，就要在经济舱指定的值机柜台处理。</p>
<p>期间，有一家外国人，在我旁边试了半天的自动取票。看女人头戴纱巾，可能是印度等地。然后男人用英语指着自动取票机，问我怎么取票。我其实没听懂他说啥，但手势大致明白了。禄口机场有个不好的地方，自动取票机长得不一样，他面前这台机器我一下子没找到外国人用护照取票的地方。看屏幕提示半天，发现机器顶部有个长的横向卡槽，需要将护照的条形码在上面从左到右滑动。于是，讲了一句蹩脚的英语：“This! Here, slide it from left to right!”我指了指他的护照，然后指了那个横向卡槽，做了一个从左到右的动作。显然他看懂了我的动作，捣鼓了一句，然后尝试了起来。试了四五次，没成功，很尴尬，我也不知道怎么弄。然后他放弃了，指了指屏幕上的二维码，问我 “How to get it?”。我当时根本不知道这个二维码是啥。上面关于电子二维码的知识，是我事后诸葛亮上网查的。当时我只知道那东西叫 “qr code”。我很想来一句，“Can you speak Chinese?”。我还是决定灰溜溜地走开。后来我办理托运的时候，看到他们在值机班长那边办理。现在我懂了，外国人都只能在人工柜台那边办理。所以这些东西，是不是能更人性化一点，让国人以及外国人一下子就清楚咋回事？</p>
<p>工作人员上班后，大概5点半，立马审核取票。然后办托运。关于行李，在家整理的时候，就要分两部分。随身携带的行李，一个五公斤以内的小包，一般是手提包或背包，放贵重物品如钱、手机、证件以及常用的物品如充电宝。托运行李，限重量不限数量，最多为40公斤。排队托运是个麻烦而且耗时的流程，所以如果有行李托运，一定要提前两小时左右去机场，而且去了立马排队。</p>
<p>托运办完后，就可以过安检了。一般是提前45分钟进行登机，所以安检尽量在45分钟前完成，除非有什么事情要处理。</p>
<p>走到对应安检区域，分国内和国外。安检过后，走到对应的登机口，等待安排登机。登机口可能随时发生变化，需要随时注意广播。</p>
<p>安检时，送行人员就不允许进入了。我给外公指清楚安检区域内大的指示牌提示的登机口，让他沿着那个方向走，找对应登机口，然后让他不懂的就问工作人员。</p>
<p>据外公说，到达登机口后，是安排小公交前往对应飞机的。</p>
<p>后面的事情我也不太清楚了，上诉有些是自己体验，有些是后来上网查询，总之也算对坐飞机的流程有了初步了解。</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>趣事</tag>
      </tags>
  </entry>
  <entry>
    <title>正宗的互联网码农，日子怎么过</title>
    <url>/zh/2020/02/18/%E6%AD%A3%E5%AE%97%E7%9A%84%E4%BA%92%E8%81%94%E7%BD%91%E7%A0%81%E5%86%9C%EF%BC%8C%E6%97%A5%E5%AD%90%E6%80%8E%E4%B9%88%E8%BF%87/</url>
    <content><![CDATA[<p>主题：正宗的互联网码农，日子怎么过</p>
<p>痛点：听说，你也想改变世界，真实的生活，真实的人</p>
<p>时间：2月19日 20:00</p>
<a id="more"></a>

<p>问题大纲</p>
<ol>
<li>简单自我介绍：做什么的；有没有特别喜欢且坚持的事</li>
</ol>
<p>Ladies and 乡亲们，好程序员就是我，我就是小宇。我是一名前端研发工程师，简单来说就是程序员，英文叫IT。</p>
<p>特别喜欢且坚持的事：</p>
<p>  老实说，我没有什么特别喜欢的事。遇到好吃的食物也会贪吃，玩到好玩的游戏也会贪玩，但确实觉得并没有什么特别喜欢。特别喜欢，应该是那种舍不得的，我想这辈子除了家人，没有什么不舍得的吧。可能会觉得自己找不到一件特别喜欢的事，感觉人生没有意义，特别无聊。直到有一天我忽然明白，这其实很好，因为我不需要在我不得不放弃它的时候，表现出难过或不舍。</p>
<p>  当然了，我还是列举了一些事儿的。</p>
<ul>
<li><p>我喜欢吃水饺，在传统节日里我会坚持吃水饺。</p>
</li>
<li><p>我喜欢吃面条，在我的生日、家人的生日，都坚持吃面条。</p>
</li>
<li><p>我坚持阅读</p>
<ul>
<li>以前读著作、历史、小说，现在更多的是电子读物，资料、新闻、影评，比如微信公众号、知乎、微博上面的一些文章都算</li>
</ul>
<p>还有我想说一下，我不喜欢格子衫，我也不头秃</p>
</li>
</ul>
<ol start="2">
<li>介绍一下互联网行业里写代码分哪些类型</li>
</ol>
<p>写代码类型：</p>
<ul>
<li>系统工程师/系统架构师（操作系统，比如电脑mac、windows、linux，手机iOS、android），比如你现在使用的手机</li>
<li>前端工程师（客户端，网页、软件APP、小程序）HTML + CSS + JS，Vue、React、Angular 等，比如我们现在用的直播软件，你看到的界面，你能操作的东西</li>
<li>后端工程师（服务端，服务器，数据库）Java、Php 等，你看不见的东西，音频、字幕怎么发出去的，怎么接受到的</li>
<li>测试工程师，专门做测试功能，测试一个软件是否正常</li>
<li>全栈工程师，同时掌握前端、后端、测试</li>
</ul>
<hr>
<p>普通程序员、文艺程序员、2B程序员</p>
<ol start="3">
<li>码农的日常工作，需要什么能力</li>
</ol>
<ul>
<li>找bugs的能力<ul>
<li>耐心</li>
<li>细心</li>
<li>逻辑</li>
</ul>
</li>
<li>学会运用工具<ul>
<li>搜索</li>
</ul>
</li>
<li>学会问问题</li>
<li>考虑全面<ul>
<li>一个功能，怎么做，可能存在的问题，解决方案的对比</li>
</ul>
</li>
<li>从用户角度思考</li>
<li>自我驱动，不断学习<ul>
<li>程序语音，迭代速度很快，需要不停地学，周期可能半年左右</li>
</ul>
</li>
</ul>
<hr>
<ol start="4">
<li>写代码的乐趣和追求是什么</li>
</ol>
<ul>
<li>我遇到一个问题，我解决了这个问题，我很快乐</li>
<li>别人遇到一个问题，我帮着解决了这个问题，我很快乐</li>
<li>我没遇到问题，别人夸我牛逼，我很快乐</li>
<li>一个产品上线了，用户用了反馈很好，用户量激增，给团队带来收益<ul>
<li>比如大家这段时间，经常使用的是「疫情地图」，这是程序员加班加点制作且维护的，全国人民大部分在关注这个，大家都通过这个去了解了这个事情，做这个「疫情地图」的程序员，心里很开心，很有成就感</li>
</ul>
</li>
</ul>
<hr>
<ol start="5">
<li>当初是怎么想到成为一名码农的</li>
</ol>
<p>上大学前，摸不到电脑计算机，但是想玩游戏，觉得电脑很神秘，那时候觉得程序员很厉害很舒服吧，可以整天玩电脑</p>
<hr>
<ol start="6">
<li>写不出来的时候你会怎么办，工作中会遇到什么困难</li>
</ol>
<ul>
<li>80%的问题，在网上都能找到答案</li>
<li>15%的问题，可以跟同事讨论研究</li>
<li>5%的问题，自己独自研究，可能会搞到很久，我最长的是通宵，一直弄到天亮</li>
</ul>
<p>工作中会遇到的困难，就是程序bugs吧；还有就是与产品经理的相爱相杀，对需求理解的不同；还有就是在有限的时间做成复杂的事情，疯狂赶进度。</p>
<hr>
<ol start="7">
<li>什么样的人适合写代码</li>
</ol>
<ul>
<li>耐心</li>
<li>细心</li>
<li>逻辑</li>
<li>自我驱动，不断学习</li>
</ul>
<hr>
<ol start="8">
<li>给想要成为码农的孩子一些建议</li>
</ol>
<ul>
<li>锻炼身体</li>
<li>护好眼睛</li>
<li>护好头发</li>
<li>护好颈椎</li>
<li>养成好的作息习惯</li>
<li>先学习计算机基础知识</li>
<li>玩游戏的话，玩一些益智类悬疑类的游戏</li>
</ul>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>每一个人都有灵魂，每一段文字都有思想</title>
    <url>/zh/2018/01/08/%E6%AF%8F%E4%B8%80%E4%B8%AA%E4%BA%BA%E9%83%BD%E6%9C%89%E7%81%B5%E9%AD%82%EF%BC%8C%E6%AF%8F%E4%B8%80%E6%AE%B5%E6%96%87%E5%AD%97%E9%83%BD%E6%9C%89%E6%80%9D%E6%83%B3/</url>
    <content><![CDATA[<p>“几年前，她抛弃了我，嫁给了一个开帕萨特的土鳖，我暗暗下定决心，将来一定要把现在受到的屈辱还给她。几年后，当我开着奔驰出现在她面前的时候，她一脸的惊讶，还招呼我去她家坐坐。”</p>
<a id="more"></a>

<p>方炎笑着说道。</p>
<p>蒋钦的心神完全被方炎的故事吸引，大眼睛一眨不眨地看着他。<br>　　<br>这是一个屌丝被女神抛弃，然后奋发图强终于成功的励志故事？<br>　　<br>“现在后悔了吧？早干什么去了？当然，我也果断地拒绝了她，因为我还得去公司接我老板下班呢～”方炎接着讲道。<br>　　<br>“啊哈哈哈……”<br>　　<br>蒋钦大笑，软软的身体前仰后合。<br>　　<br>“太好玩了。这个人怎么这么贱啊！”<br>　　<br>方炎说道：“这个段子很好笑，对不对？但是，你有没有想过，只要在这个段子里面改动一个字，就是一个很温馨浪漫的爱情故事。”<br>　　<br>蒋钦瞪大了眼睛，说道：“还可以这样？”<br>　　<br>“你改着试试。”方炎笑了起来。“看看能不能找到那个需要改动的字。”<br>　　<br>蒋钦习惯性的把笔杆咬在嘴里，小脸认真的思索起来。<br>　　<br>“改变一个字就成了温馨浪漫的爱情故事？”小丫头的嘴里念念有词。“要改动哪一个字呢？”<br>　　<br>方炎笑呵呵地看着她，等待着她的答案。<br>　　<br>蒋钦显然不是一个多么有耐心的人，三五分钟后就放弃了。<br>　　<br>她把沾着口水的铅笔丢在桌子上，烦躁地说道：“烦死了烦死了，人家想不出来。要改哪个字？”<br>　　<br>方炎笑呵呵地看着她，说道：“每一个人都有灵魂，每一段文字都有思想，这些字是活的，它们是一个整体，你要从这个整体上去寻找一颗痣。这颗痣很微小，但是也很显眼。如果你能够静下心来，就一定可以找到。”<br>　　<br>“我已经很静心了啊。”小丫头撒娇的说道。她赤裸的小脚从桌子底下去踢方炎的小腿，说道：“方老师，你快告诉我嘛。我真的很好奇。”<br>　　<br>“如果把‘老板’改成‘老婆’，只是换一个字，换一个身份，故事的意思是不是就全然不一样了？”<br>　　<br>“啊？”小丫头惊叫出声。她都没想过改动会如此的简单。<br>　　<br>可是，改动之后，故事的灵魂立即就发生了颠覆性的变化。</p>
<p>“几年前，她抛弃了我，嫁给了一个开帕萨特的土鳖，我暗暗下定决心，将来一定要把现在受到的屈辱还给她。几年后，当我开着奔驰出现在她面前的时候，她一脸的惊讶，还招呼我去她家坐坐。现在后悔了吧？早干什么去了？当然，我也果断地拒绝了她，因为我还得去公司接我老婆下班呢～”<br>　　<br>前面一个故事，男主角是屌丝，却仍然没有逆袭成功。而改动过一个字后，男主角不仅仅在社会上证明了自己的能力，还对自己的老婆忠贞不渝。那个“前女友”失去了一个对感情认真负责的潜力黑马。<br>　　<br>“你认真的想一想。”方炎说道。<br>　　<br>蒋钦点头答应，趴在桌子上沉默不语。<br>　　<br>“每一段文字都有一个命门，如果你能够找到它的命门，就再也没有什么问题能够难倒你了。”<br>　　<br>“生活也是。”蒋钦咯咯地笑。</p>
<p><a href="http://book.zongheng.com/chapter/347511/5872956.html" target="_blank" rel="noopener">原文</a></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>人性</tag>
      </tags>
  </entry>
  <entry>
    <title>生存指南</title>
    <url>/zh/2019/03/17/%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<p>瞎扯些要命题 — 生存指南</p>
<a id="more"></a>

<p>下次再说</p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>人性</tag>
      </tags>
  </entry>
  <entry>
    <title>网页刷新那些事</title>
    <url>/zh/2019/09/17/%E7%BD%91%E9%A1%B5%E5%88%B7%E6%96%B0%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
    <content><![CDATA[<p>网页刷新那些事</p>
<a id="more"></a>

<h1 id="什么是缓存"><a href="#什么是缓存" class="headerlink" title="什么是缓存"></a>什么是缓存</h1><p>缓存是我们在生活中经常听到一个词，像是“怎么清理浏览器的缓存”，“手机空间不够了，得删除缓存”，“硬盘的缓存是不是越大越好”等等。</p>
<p>其实这些“缓存”可以分成 3 种：一种指硬件上的，像硬盘缓存和 CPU 缓存，一种客户端缓存，还有一种是指服务端缓存。后两种更像是一种技术或者是服务。</p>
<ul>
<li>硬件缓存：它指的是一块芯片，可以被集成到硬盘或者是 CPU 上。它的作用就是充当硬盘（CPU）与外界接口（通常是内存）之间的暂存器。利用缓存可以减轻系统的负荷，同时提高数据的传输速率。</li>
<li>客户端缓存：某些应用，如浏览器、手机淘宝等，为了实现能够快速响应用户的请求，会把用户之前浏览的东西（如图片等）存在本地。在下次访问时，如果本地的缓存里有请求的内容，那么就直接展示出来，不用再次向服务器请求。</li>
<li>服务端缓存：它与客户端缓存目的相同，只不过是站在服务器这边考虑的。如果每次接到客户端请求都要连接一次数据库，当用户请求多的时候，负载过大。这时可以把一些经常被请求的数据存放在内存中，当有请求时直接返回，不用经过数据库。这样就可以减轻数据库的负担。</li>
</ul>
<h2 id="强制缓存和协商缓存"><a href="#强制缓存和协商缓存" class="headerlink" title="强制缓存和协商缓存"></a>强制缓存和协商缓存</h2><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://twei.site/2017/07/15/缓存那些事-什么是缓存，为什么要用缓存/" target="_blank" rel="noopener">缓存那些事–什么是缓存，为什么要用缓存</a></p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title>车</title>
    <url>/zh/2018/09/06/%E8%BD%A6/</url>
    <content><![CDATA[<p>车。</p>
<a id="more"></a>

<h1 id="开车步骤"><a href="#开车步骤" class="headerlink" title="开车步骤"></a>开车步骤</h1><p>带钥匙！</p>
<p>观察车身周围环境！</p>
<p>上车！</p>
<p>关好车门！</p>
<p>调整座椅！</p>
<p>调整后视镜！</p>
<p>系安全带！</p>
<p>开机！</p>
<p>如果要听歌或者导航或者要调整车窗/天窗等，现在就弄！</p>
<p>关闭发动机自动启停功能！（右手边）</p>
<p>踩住制动踏板，释放电子驻车制动器！（左手边）</p>
<p>踩住制动踏板，移除P(驻车)档，挂R(倒车)档或者挂D(前进)档！</p>
<p>打左转向灯！</p>
<p>双手握住方向盘！不要单手，杜绝陋习！</p>
<p>根据车身位置，选择向左打方向的角度。如果前方没有障碍物，稍微向左打。如果前方有障碍物，向左打死，或者确保能够安全转向使出！</p>
<p>轻轻释放制动踏板，但不要全部释放！</p>
<p>车身缓缓移动，及时缓动方向调整角度，观察左右后视镜以及收听驻车雷达提示，如果出现距离不够或出现提示，要立即停车观察，不要侥幸勉强！（2018年9月6日晚停车差点撞到车前面的树）</p>
<p>前进档和倒车档互相切换！调整车身位置！</p>
<p>当车身进入安全行驶区域，保持车身方向，释放制动踏板，并选择缓缓踩下油门进行加速！</p>
<p>行驶过程中注意专心、谨慎，保持目视前方，余光观察后视镜，保持车距（左右，前）！</p>
<p>如果有儿童靠近，一定要停车！如果有非机动车靠近，一定要减速慢行！人行横道处，有行人通过，一定要停车让行人先过！遇到路口或人行横道，一定要左右观察！</p>
<p>转弯、变道要打方向灯！</p>
<p>转弯让直行！</p>
<p>向左转弯时，靠路口中心点左侧转弯！</p>
<p>相对方向行驶的右转弯车让左转弯车先行！</p>
<p>直行 &gt; 左转 &gt; 右转</p>
<p>不能闯红灯！除非是圆盘红灯，可以右转！</p>
<p>出现箭头右转红灯，不能右转！只有出现圆盘红灯，可以右转！</p>
<p>直线行驶时保持方向，不要左右摇摆，也不要随意转动方向！</p>
<h1 id="停车步骤"><a href="#停车步骤" class="headerlink" title="停车步骤"></a>停车步骤</h1><p>打右转向灯！</p>
<p>释放油门！</p>
<p>踩住制动踏板，控制力度调整速度！</p>
<p>车身缓缓移动，及时缓动方向调整角度，观察左右后视镜以及收听驻车雷达提示，如果出现距离不够或出现提示，要立即停车观察，不要侥幸勉强！（2018年9月6日晚停车差点撞到车前面的树）</p>
<p>前进档和倒车档互相切换！调整车身位置！</p>
<p>将车停靠在适当位置！</p>
<p>踩住制动踏板，让车停止！</p>
<p>挂P(驻车)档！</p>
<p>启动电子驻车制动器！（左手边）</p>
<p>解安全带！</p>
<p>收起后视镜！</p>
<p>关闭听歌或者导航或者车窗/天窗等！</p>
<p>关机！</p>
<p>下车！</p>
<p>观察车身是否处于安全位置！</p>
<p>锁车门！</p>
<h2 id="A、B、C-柱"><a href="#A、B、C-柱" class="headerlink" title="A、B、C 柱"></a>A、B、C 柱</h2><p><img src="https://cmspic-10004025.image.myqcloud.com/77872ec0-b4d2-11e8-89ca-738ebe777463_size_880x498" alt="abc"></p>
<h3 id="A-柱"><a href="#A-柱" class="headerlink" title="A 柱"></a>A 柱</h3><p>驾驶员左前方和右前方的柱，是连接车棚和车身的柱子。</p>
<p><img src="https://cmspic-10004025.image.myqcloud.com/9b907e70-b4d2-11e8-89ca-738ebe777463_size_956x536" alt="a"></p>
<h3 id="B-柱"><a href="#B-柱" class="headerlink" title="B 柱"></a>B 柱</h3><p>驾驶员最侧后方的，安全带一段固定的柱子。也是分为左右两侧的。</p>
<p><img src="https://cmspic-10004025.image.myqcloud.com/a6f13e80-b4d2-11e8-89ca-738ebe777463_size_948x574" alt="b"></p>
<h3 id="C-柱"><a href="#C-柱" class="headerlink" title="C 柱"></a>C 柱</h3><p>车的后排座椅左右两侧的车篷与车身连接的柱子。</p>
<p><img src="https://cmspic-10004025.image.myqcloud.com/caba9f00-b4d2-11e8-89ca-738ebe777463_size_900x460" alt="c"></p>
<h2 id="难点"><a href="#难点" class="headerlink" title="难点"></a>难点</h2><h3 id="左右转弯！"><a href="#左右转弯！" class="headerlink" title="左右转弯！"></a>左右转弯！</h3><p>拐弯时，一定要提前减速，只有慢一些才能安全的通过，或者拐错了能及时更正。相反如果拐弯速度过快就容易出现危险。</p>
<p>右拐时尽量拐小弯(方向盘打大，甚至向右打死，等拐过弯后再慢慢回正方向)。右拐时，有时会遇到直行的会正在行驶的车辆，像十字路口，这时你要拐弯就要拐个小弯，这样不会影响直行车辆正常行驶，否则会阻碍他人的。</p>
<p>左拐时尽量拐大弯(方向盘打小，稍微向左打一点，边拐边打方向)。尽量行驶至靠路口中心点左侧转弯。因为有些车辆也会在你想拐进去的路上出来，这时为了避免发生阻碍或碰撞等其它危险，应尽量的往远一点的地方拐进去。</p>
<p>看好后视镜。在拐弯时，一定要看好后视镜，判断好车后方或侧后方没人后再拐弯。这一点很多新手往往顾及不到，容易酿成交通事故。</p>
<p>留意拐弯的死角。新手在拐弯时往往会看上不看下，看左不看右，导致忽略了拐弯死角，容易压到马路基石上或发生刮擦。一定要看好后视镜下方的障碍物，必要时应该打开车门看一看再拐。</p>
<p>控制好方向盘。拐弯时，方向盘的控制很重要。如果想拐小弯，要把方向盘尽量打死，等拐过弯后再慢慢回正方向；想拐大弯，则要慢慢的打方向即可。</p>
<p>右拐让左拐，拐弯让直行。</p>
<h3 id="两侧有障碍物，行驶空间小，如何安全通过！"><a href="#两侧有障碍物，行驶空间小，如何安全通过！" class="headerlink" title="两侧有障碍物，行驶空间小，如何安全通过！"></a>两侧有障碍物，行驶空间小，如何安全通过！</h3><h3 id="如何入库！"><a href="#如何入库！" class="headerlink" title="如何入库！"></a>如何入库！</h3><h4 id="“并联式”-停车位"><a href="#“并联式”-停车位" class="headerlink" title="“并联式” 停车位"></a>“并联式” 停车位</h4><p><img src="https://cmspic-10004025.image.myqcloud.com/b6ebb250-b4cf-11e8-89ca-738ebe777463_size_1150x658" alt="1"></p>
<p>将自己所驾车辆停在与停车位垂直的位置，且左侧与车位线保持 1.5 米左右的距离。</p>
<p>等确认好之后将车继续向前开两个停车位的距离，当自己在车内所坐的位置正好处于第二个停车位的中间时停车。</p>
<p><img src="https://cmspic-10004025.image.myqcloud.com/fbf2bf60-b4cf-11e8-89ca-738ebe777463_size_1148x652" alt="2"></p>
<p>然后往左打满轮后开始倒车，注意车头车尾与左右两车的距离，保证不要剐蹭，左小向右回，右小向左回。</p>
<p>在确认车尾已经进入要停的车位而且车头已经摆正时，立刻将车轮回正，继续倒车进入车位，把握好车尾与后方的位置以后，停车就大功告成了。</p>
<p>当然如果出现左右距离明显不一致，要稍微修正，左小向右回，右小向左回。</p>
<h4 id="“串联式”-停车位，即侧方位"><a href="#“串联式”-停车位，即侧方位" class="headerlink" title="“串联式” 停车位，即侧方位"></a>“串联式” 停车位，即侧方位</h4><p><img src="https://cmspic-10004025.image.myqcloud.com/0aa6aca0-b4d1-11e8-89ca-738ebe777463_size_1148x558" alt="3"></p>
<p>将自己所驾车辆停在与停车位平行的位置，且与前车左侧保持 0.5 米左右的距离。</p>
<p>等确认好之后将车继续向前开，当右车镜对准前车 B 柱 (驾驶员最侧后方的，安全带一段固定的柱子) 时停车。</p>
<p><img src="https://cmspic-10004025.image.myqcloud.com/edf13560-b4d2-11e8-89ca-738ebe777463_size_1146x570" alt="4"></p>
<p>然后往右打满轮，开始倒车，注意车头车尾与左右两车的距离，保证不要剐蹭，左小向右回，右小向左回。</p>
<p>当车和前车成45度角时，往左打满轮，继续倒车。</p>
<p>进位后，头正回轮。</p>
<p>当然如果出现左右距离明显不一致，要稍微修正，左小向右回，右小向左回。</p>
<h4 id="”斜线式”-停车位"><a href="#”斜线式”-停车位" class="headerlink" title="”斜线式” 停车位"></a>”斜线式” 停车位</h4><p><img src="https://cmspic-10004025.image.myqcloud.com/cdcfe360-b4d4-11e8-89ca-738ebe777463_size_1118x630" alt="5"></p>
<p>当看到自己所驾车辆的左后视镜与所要进的停车位的左侧边线对齐时停车。</p>
<p><img src="https://cmspic-10004025.image.myqcloud.com/d8d58b20-b4d4-11e8-89ca-738ebe777463_size_1124x660" alt="6"></p>
<p>向右打满轮，继续前进，注意车头车尾与左右两车的距离，保证不要剐蹭，左小向右回，右小向左回。</p>
<p>车身纵向与停车位呈一条直线时，将车停住，回正车轮，再平稳倒入停车位。</p>
<p>当然如果出现左右距离明显不一致，要稍微修正，左小向右回，右小向左回。</p>
<h3 id="如何出库！"><a href="#如何出库！" class="headerlink" title="如何出库！"></a>如何出库！</h3><hr>
<p>技术不行，就小心谨慎、缓慢移动，慢是慢点，还是能成功的！</p>
<p><audio src="http://audio-10004025.cossh.myqcloud.com/%E5%BC%80%E8%BD%A6%E6%AD%A5%E9%AA%A41.mp3" controls></audio></p>
<br>

<p><audio src="http://audio-10004025.cossh.myqcloud.com/%E5%BC%80%E8%BD%A6%E6%AD%A5%E9%AA%A42.mp3" controls></audio></p>
<br>

<p><audio src="http://audio-10004025.cossh.myqcloud.com/%E5%81%9C%E8%BD%A6%E6%AD%A5%E9%AA%A4.mp3" controls></audio></p>
]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>车</tag>
      </tags>
  </entry>
  <entry>
    <title>音乐搜索(基于vue)</title>
    <url>/zh/2018/05/02/%E9%9F%B3%E4%B9%90%E6%90%9C%E7%B4%A2(%E5%9F%BA%E4%BA%8Evue)/</url>
    <content><![CDATA[<p>一个基于 vue 的音乐搜索网页。预览<a href="https://zhouyu1993.github.io/awesome/vue-music/">vue-music</a>。</p>
<a id="more"></a>

<p>风格复制<a href="https://m.y.qq.com/#search" target="_blank" rel="noopener">qq-music</a>。</p>
<p>代码参考<a href="http://github.com/sioxas" target="_blank" rel="noopener">sioxas-music</a>。</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>前端面试题</title>
    <url>/zh/2018/08/09/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    <content><![CDATA[<p>前端面试题</p>
<a id="more"></a>

<ul>
<li>自我介绍</li>
<li>项目介绍</li>
<li>面试题目</li>
</ul>
<hr>
<p>算法题-字符串处理</p>
<p>字符串 line 是字母+数字的组合，数字代表字母重复的个数。</p>
<p>写一个函数，要求把字符串 line 按照字母重复的个数的递增排序，如重复的个数相等，按照字母大小递增排序，并输出完整的字符</p>
<p>如给 const line = ‘c2b1a2’ 输出 ‘baacc’，给 const line = ‘a11b2bac3bae3bad3abcd2’ 输出 ‘bbabcdabcdbacbacbacbadbadbadbaebaebaeaaaaaaaaaaa’</p>
<p>思路：</p>
<p>字母+数字的依次组合，将字母、数字拆分开，然后把数字转成字母（字母重复），然后排序</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span> (<span class="params">line = <span class="string">'a11b2bac3bae3bad3abcd2'</span></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 按数字正则拆分，得到所有字母数组</span></span><br><span class="line">  <span class="keyword">const</span> chars = line.split(<span class="regexp">/[0-9]/</span>).filter(<span class="function"><span class="params">item</span> =&gt;</span> item)</span><br><span class="line">  <span class="comment">// 按字母正则拆分，得到所有数字数组</span></span><br><span class="line">  <span class="keyword">const</span> numbers = line.split(<span class="regexp">/[A-Za-z]/</span>).filter(<span class="function"><span class="params">item</span> =&gt;</span> item)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把数字转成字母（字母重复）</span></span><br><span class="line">  <span class="keyword">const</span> arr = chars.map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> str = item.padStart(item.length * numbers[index], item)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> str</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 排序，按字母长度，长度相等按字母大小</span></span><br><span class="line">  arr.sort(<span class="function">(<span class="params">prev, next</span>) =&gt;</span></span><br><span class="line">    <span class="comment">// 如果不等，按字母长度</span></span><br><span class="line">    <span class="comment">// 如果相等，按字母大小</span></span><br><span class="line">    prev.length != next.length ?</span><br><span class="line">    (prev.length - next.length) :</span><br><span class="line">    (prev &gt; next ? <span class="number">1</span> : <span class="number">-1</span>)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数组转字符串</span></span><br><span class="line">  <span class="keyword">const</span> result = arr.join(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span> (<span class="params">line = <span class="string">'a11b2bac3bae3bad3abcd2'</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> lineArr = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; line.length; i ++) &#123;</span><br><span class="line">    <span class="comment">// 前一个</span></span><br><span class="line">    <span class="keyword">const</span> prev = lineArr[lineArr.length - <span class="number">1</span>]</span><br><span class="line">    <span class="comment">// 当前元素</span></span><br><span class="line">    <span class="keyword">const</span> now = line[i]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev &amp;&amp; ((+prev &amp;&amp; +now) || (!(+prev) &amp;&amp; !(+now)))) &#123;</span><br><span class="line">      <span class="comment">// 如果类型相等，都是数字或都是字母，则在前一个上递增</span></span><br><span class="line">      lineArr[lineArr.length - <span class="number">1</span>] += now</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果类型不同，则新增</span></span><br><span class="line">      lineArr.push(now)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 得到的 lineArr 是字母、数字的数组排序</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 把数字转成字母（字母重复）</span></span><br><span class="line">  <span class="keyword">const</span> arr = []</span><br><span class="line">  lineArr.forEach(<span class="function">(<span class="params">item, index</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(+item)) &#123;</span><br><span class="line">      <span class="keyword">const</span> str = !(index % <span class="number">2</span>) &amp;&amp; item.padStart(item.length * lineArr[index + <span class="number">1</span>], item)</span><br><span class="line"></span><br><span class="line">      arr.push(str)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 排序，按字母长度，长度相等按字母大小</span></span><br><span class="line">  arr.sort(<span class="function">(<span class="params">prev, next</span>) =&gt;</span></span><br><span class="line">    <span class="comment">// 如果不等，按字母长度</span></span><br><span class="line">    <span class="comment">// 如果相等，按字母大小</span></span><br><span class="line">    prev.length != next.length ?</span><br><span class="line">    (prev.length - next.length) :</span><br><span class="line">    (prev &gt; next ? <span class="number">1</span> : <span class="number">-1</span>)</span><br><span class="line">  )</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 数组转字符串</span></span><br><span class="line">  <span class="keyword">const</span> result = arr.join(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><a href="https://www.nowcoder.com/practice/5190a1db6f4f4ddb92fd9c365c944584" target="_blank" rel="noopener">https://www.nowcoder.com/practice/5190a1db6f4f4ddb92fd9c365c944584</a></p>
<p>编写一个程序，将输入字符串中的字符按如下规则排序。</p>
<p>规则 1 ：英文字母从 A 到 Z 排列，不区分大小写。</p>
<p>如，输入： Type 输出： epTy</p>
<p>规则 2 ：同一个英文字母的大小写同时存在时，按照输入顺序排列。</p>
<p>如，输入： BabA 输出： aABb</p>
<p>规则 3 ：非英文字母的其它字符保持原来的位置。</p>
<p>如，输入： By?e 输出： Be?y</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> line</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (line = readline()) &#123;</span><br><span class="line">  <span class="keyword">const</span> arr = line.split(<span class="string">''</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> _arr = line</span><br><span class="line">    .replace(<span class="regexp">/[^A-Za-z]/g</span>, <span class="string">''</span>)</span><br><span class="line">    .split(<span class="string">''</span>).map(<span class="function">(<span class="params">item, index</span>) =&gt;</span> (&#123;</span><br><span class="line">      v: item,</span><br><span class="line">      lower: item.toLowerCase(),</span><br><span class="line">      index</span><br><span class="line">    &#125;)).sort(<span class="function">(<span class="params">prev, next</span>) =&gt;</span></span><br><span class="line">      <span class="comment">// 如果相等，按索性先后</span></span><br><span class="line">      <span class="comment">// 如果不等，按字母大小</span></span><br><span class="line">      prev.lower === next.lower ?</span><br><span class="line">      (prev.index - next.index) :</span><br><span class="line">      (prev.lower &gt; next.lower ? <span class="number">1</span> : <span class="number">-1</span>)</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> __arr = _arr.map(<span class="function"><span class="params">item</span> =&gt;</span> item.v)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; arr.length; i ++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="regexp">/[A-Za-z]/g</span>.test(arr[i])) &#123;</span><br><span class="line">      arr[i] = __arr[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">      __arr.shift()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(arr.join(<span class="string">''</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p><a href="https://www.nowcoder.com/practice/fe298c55694f4ed39e256170ff2c205f" target="_blank" rel="noopener">https://www.nowcoder.com/practice/fe298c55694f4ed39e256170ff2c205f</a></p>
<p>三个空汽水瓶，可以换一瓶汽水。<br>两个空瓶子，可以先跟老板借一瓶汽水，喝掉后用三个空瓶子换一瓶满的还给老板。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 手上空瓶子的数量 count</span></span><br><span class="line"><span class="keyword">let</span> count</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可换汽水数量 n</span></span><br><span class="line"><span class="keyword">let</span> n = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (count = readline()) &#123;</span><br><span class="line">  n = <span class="built_in">parseInt</span>(count / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  n &amp;&amp; <span class="built_in">console</span>.log(n)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 可换汽水数量 m</span></span><br><span class="line"><span class="keyword">let</span> m = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (count = readline()) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">fun</span> (<span class="params">num</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt; <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (num == <span class="number">2</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> huan = <span class="built_in">parseInt</span>(num / <span class="number">3</span>)</span><br><span class="line">      <span class="keyword">const</span> shengyu = huan + num % <span class="number">3</span></span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> huan + fun(shengyu)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  m = fun(count)</span><br><span class="line"></span><br><span class="line">  m &amp;&amp; <span class="built_in">console</span>.log(m)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<p>ssr、spa</p>
<p>GraphQL</p>
<p>JS 类型：string，boolean，number，function，object，undefined，es6 的 symbol，以及最新的 bigint</p>
<p>JS 类型判断：typeof, instanceof, Object.toString.call</p>
<p>函数式编程</p>
<p>纯函数</p>
<p><a href="https://llh911001.gitbooks.io/mostly-adequate-guide-chinese/content/ch4.html" target="_blank" rel="noopener">柯里化 curry</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">curry</span> (<span class="params">fn, arr = []</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> fn.length === arr.length ? fn.apply(<span class="literal">null</span>, arr) : <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> curry (fn, arr.concat(args))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> curry = <span class="function">(<span class="params">fn, arr = []</span>) =&gt;</span> fn.length === arr.length ? fn(...arr) : <span class="function">(<span class="params">...args</span>) =&gt;</span> curry(fn, [...arr, ...args])</span><br></pre></td></tr></table></figure>

<p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017454145929440" target="_blank" rel="noopener">偏函数</a></p>
<p>es6 扩展：数值扩展，函数扩展，箭头函数，Proxy，Reflect，Promise，class，生成器函数，async/await，Promise</p>
<p>JS 异步编程进化史：callback -&gt; 发布订阅模式 -&gt; promise -&gt; generator -&gt; async + await</p>
<p><a href="https://juejin.cn/post/6844903760280420366" target="_blank" rel="noopener">JS 异步编程</a></p>
<p>Event Loop 机制</p>
<p>浏览器端的宏任务，微任务</p>
<p>nodejs 中的几个事件循环阶段</p>
<p>发布订阅模式，nodejs 中的 EventEmitter</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">EventEmitter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>._eventpool = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  on (event, callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>._eventpool[event] ? <span class="keyword">this</span>._eventpool[event].push(callback) : <span class="keyword">this</span>._eventpool[event] = [callback]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  emit (event, ...args) &#123;</span><br><span class="line">    <span class="keyword">this</span>._eventpool[event] &amp;&amp; <span class="keyword">this</span>._eventpool[event].forEach(<span class="function"><span class="params">cb</span> =&gt;</span> cb(...args))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  off (event) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>._eventpool[event]) &#123;</span><br><span class="line">      <span class="keyword">delete</span> <span class="keyword">this</span>._eventpool[event]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  once (event, callback) &#123;</span><br><span class="line">    <span class="keyword">this</span>.on(event, (...args) =&gt; &#123;</span><br><span class="line">      callback(...args);</span><br><span class="line">      <span class="keyword">this</span>.off(event)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.b = <span class="number">3</span>; <span class="comment">// window.b</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.prototype.b = <span class="number">7</span>; <span class="comment">// 原型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t = <span class="keyword">new</span> a(); <span class="comment">// 实例</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">a(); <span class="comment">// window</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(t.b); <span class="comment">// 实例上</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b); <span class="comment">// window 上</span></span><br></pre></td></tr></table></figure>

<p>PureComponent 纯组件</p>
<p>flex 布局</p>
<p>css 实现 Modal 模态窗口，上下左右弹出动画</p>
<p>跨域，JSONP 基本原理</p>
<p>网络安全 XSS、CSRF</p>
<p>节流函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span> (<span class="params">fn, time</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> canRun = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!canRun) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    canRun = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>, args = <span class="built_in">arguments</span>;</span><br><span class="line"></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      fn.apply(that, args);</span><br><span class="line"></span><br><span class="line">      canRun = <span class="literal">true</span>;</span><br><span class="line">    &#125;, time || <span class="number">500</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(throttle(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello world"</span>)</span><br><span class="line">&#125;), <span class="number">100</span>)</span><br></pre></td></tr></table></figure>

<p>用 reduce 实现 map 的功能</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.map = <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr.reduce(<span class="function">(<span class="params">acc, cur, i</span>) =&gt;</span> &#123;</span><br><span class="line">    acc.push(callback(cur, i, arr));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> acc;</span><br><span class="line">  &#125;, []);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> m = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">v, i, arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v * v;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(m);</span><br></pre></td></tr></table></figure>

<p>实现二叉树的后序遍历</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">TreeNode</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.val = val;</span><br><span class="line">  <span class="keyword">this</span>.left = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">this</span>.right = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">vist</span>(<span class="params">root</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root) &#123;</span><br><span class="line">    vist(root.left);</span><br><span class="line">    vist(root.right);</span><br><span class="line">    <span class="built_in">console</span>.log(root.val);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二叉树？判断是不是完全二叉树？</p>
<p>判断一个链表是否有环？</p>
<p>TCP 三次握手</p>
<p>https 的原理</p>
<p>缓存策略</p>
<p>原生 js 实现 bind 函数</p>
<p>输入 url 到页面渲染整个过程</p>
<p>回流和重绘</p>
<h1 id="浏览器与浏览器内核"><a href="#浏览器与浏览器内核" class="headerlink" title="浏览器与浏览器内核"></a>浏览器与浏览器内核</h1><p>浏览器内核，作用是帮助浏览器来渲染网页的内容，将页面内容和排版代码转换为用户所见的视图。</p>
<p>浏览器内核分成两部分：渲染引擎 (Layout Engine 或者 Rendering Engine) 和 JS 引擎。</p>
<p>渲染引擎，负责取得网页的内容 (HTML、XML、图像等)、整理讯息 (CSS 等)，以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。</p>
<p>JS 引擎，负责解析 JavaScript 语言、执行 JavaScript 语言，来实现网页的动态效果。</p>
<p><a href="http://browserl.ist/" target="_blank" rel="noopener">browser</a></p>
<p><a href="https://caniuse.com" target="_blank" rel="noopener">caniuse</a></p>
<p><a href="https://www.npmjs.com/package/browserslist" target="_blank" rel="noopener">browserslist</a></p>
<p>in <code>package.json</code></p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"browserslist"</span>: [</span><br><span class="line">    <span class="string">"&gt; 1%"</span>,</span><br><span class="line">    <span class="string">"last 3 versions"</span>,</span><br><span class="line">    <span class="string">"ie &gt;= 9"</span>,</span><br><span class="line">    <span class="string">"ios &gt;= 8"</span>,</span><br><span class="line">    <span class="string">"android &gt;= 4.4"</span></span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>in <code>.browserslistrc</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Browsers that we support</span></span><br><span class="line"></span><br><span class="line">&gt; 1%</span><br><span class="line">last 3 versions</span><br><span class="line">ie &gt;= 9</span><br><span class="line">ios &gt;= 8</span><br><span class="line">android &gt;= 4.4</span><br></pre></td></tr></table></figure>

<h2 id="PC端"><a href="#PC端" class="headerlink" title="PC端"></a>PC端</h2><p>Internet Explorer (IE 互联网探索者)，内核是：Trident</p>
<p>Safari (游猎)、Google Chrome (谷歌)，内核是：WebKit (极速)</p>
<p>Mozilla FireFox (FF 火狐)，内核是：Gecko</p>
<p>Opera (欧朋)，内核是：Presto</p>
<h2 id="移动端"><a href="#移动端" class="headerlink" title="移动端"></a>移动端</h2><p>移动端的浏览器内核主要说的是系统内置浏览器的内核。</p>
<p>移动设备浏览器上常用的内核有 WebKit，Blink，Trident，Gecko 等。</p>
<p>其中 iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android 4.4 系统浏览器切换到了 Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内核是 Trident。</p>
<h1 id="document-compatMode"><a href="#document-compatMode" class="headerlink" title="document.compatMode"></a>document.compatMode</h1><p>当前浏览器采用的渲染方式</p>
<p>BackCompat：标准兼容模式关闭。浏览器客户区宽度是 document.body.clientWidth。</p>
<p>CSS1Compat：标准兼容模式开启。浏览器客户区宽度是 document.documentElement.clientWidth。</p>
<h1 id="块元素、行内元素、行内块元素"><a href="#块元素、行内元素、行内块元素" class="headerlink" title="块元素、行内元素、行内块元素"></a>块元素、行内元素、行内块元素</h1><h2 id="块元素-display-block"><a href="#块元素-display-block" class="headerlink" title="块元素 display: block"></a>块元素 display: block</h2><p>div、p、nav、aside、header、footer、section、article、ul、li、address 等元素。</p>
<h2 id="行内元素-display-inline"><a href="#行内元素-display-inline" class="headerlink" title="行内元素 display: inline"></a>行内元素 display: inline</h2><p>不换行，设置 width、height 都无效，宽高由内容决定，但可以设置 line-height 来控制高度。margin 上下无效但左右有效，padding 上下左右都有效。</p>
<p>a、b、i、span 等元素。</p>
<h2 id="行内块元素-display-inline-block"><a href="#行内块元素-display-inline-block" class="headerlink" title="行内块元素 display: inline-block"></a>行内块元素 display: inline-block</h2><p>除了具有行内元素不换行的特性，其他都是块元素的特性。设置 width、height 都有效，margin 上下左右都有效。</p>
<p>img、input 等元素。</p>
<h1 id="盒模型"><a href="#盒模型" class="headerlink" title="盒模型"></a>盒模型</h1><p><a href="https://segmentfault.com/a/1190000005116275" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005116275</a></p>
<p><a href="https://segmentfault.com/a/1190000005155084" target="_blank" rel="noopener">https://segmentfault.com/a/1190000005155084</a></p>
<h2 id="block-box"><a href="#block-box" class="headerlink" title="block box"></a>block box</h2><p>content + padding + border + margin</p>
<h2 id="line-box"><a href="#line-box" class="headerlink" title="line box"></a>line box</h2><p>每一行称为一条 line Box，它又是由这一行的许多 inline box 组成，它的高度可以直接由 line-height 决定，line boxes 的高度垂直堆叠形成了 containing box 的高度，就是我们见到的 div 或是 p 标签之类的高度了。</p>
<h1 id="box-sizing"><a href="#box-sizing" class="headerlink" title="box-sizing"></a>box-sizing</h1><p>box-sizing: content-box | border-box</p>
<p>影响的其实就是内边距和边框。content-box 向外发散，border-box 向内收敛。</p>
<p>content-box: 默认值。宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框(元素默认效果。</p>
<p>如果你设置一个元素的宽为 100px，那么这个元素的内容区会有 100px 宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。</p>
<p>border-box: 元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度(推荐)。</p>
<p>如果你将一个元素的 width 设为 100px, 那么这 100px 会包含其它的 border 和 padding，内容区的实际宽度会是 width 减去 border + padding 的计算值。</p>
<p>大多数情况下 border-box 使得我们更容易的去设定一个元素的宽高。<a href="https://css-tricks.com/international-box-sizing-awareness-day/" target="_blank" rel="noopener">链接</a>。所以我们常常这样设置：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">*, *<span class="selector-pseudo">:before</span>, *<span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">  <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="BFC-边距重叠解决方案"><a href="#BFC-边距重叠解决方案" class="headerlink" title="BFC(边距重叠解决方案)"></a>BFC(边距重叠解决方案)</h1><h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h1><h2 id="传统布局"><a href="#传统布局" class="headerlink" title="传统布局"></a>传统布局</h2><p>布局的传统解决方案，基于盒状模型，依赖 display + position + float</p>
<p>这种传统布局，对于那些特殊布局非常不方便，比如 <code>水平垂直居中</code>，就不容易实现。</p>
<h2 id="flex-布局"><a href="#flex-布局" class="headerlink" title="flex 布局"></a>flex 布局</h2><p>flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。</p>
<p>采用 flex 布局的元素，称为 flex 容器(flex container)，简称”容器”。它的所有子元素自动成为容器成员，称为 flex 项目(flex item)，简称”项目”。</p>
<h2 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h2><ul>
<li>display: flex;</li>
<li>flex-direction</li>
<li>flex-wrap</li>
<li>align-items</li>
<li>justify-content</li>
</ul>
<h3 id="flex-direction-row-row-reverse-column-column-reverse"><a href="#flex-direction-row-row-reverse-column-column-reverse" class="headerlink" title="flex-direction: row | row-reverse | column | column-reverse"></a>flex-direction: row | row-reverse | column | column-reverse</h3><ul>
<li>row(默认值)：主轴为水平方向，起点在左端</li>
<li>row-reverse：主轴为水平方向，起点在右端</li>
<li>column：主轴为垂直方向，起点在上沿</li>
<li>column-reverse：主轴为垂直方向，起点在下沿</li>
</ul>
<p>其实就两种，row 横，column 纵</p>
<p>reverse 代表反转方向，排列顺序</p>
<h3 id="flex-wrap-nowrap-wrap-wrap-reverse"><a href="#flex-wrap-nowrap-wrap-wrap-reverse" class="headerlink" title="flex-wrap: nowrap | wrap | wrap-reverse"></a>flex-wrap: nowrap | wrap | wrap-reverse</h3><ul>
<li>nowrap(默认)：不换行</li>
<li>wrap：换行，第一行在上方</li>
<li>wrap-reverse：换行，第一行在下方</li>
</ul>
<h3 id="align-items-flex-start-flex-end-center-baseline-stretch"><a href="#align-items-flex-start-flex-end-center-baseline-stretch" class="headerlink" title="align-items: flex-start | flex-end | center | baseline | stretch"></a>align-items: flex-start | flex-end | center | baseline | stretch</h3><p>垂直对齐方式</p>
<ul>
<li>flex-start：交叉轴的起点对齐。居上</li>
<li>flex-end：交叉轴的终点对齐。居下</li>
<li>center：交叉轴的中点对齐。居中</li>
<li>baseline: 项目的第一行文字的基线对齐</li>
<li>stretch(默认值)：如果项目未设置高度或设为 auto，将占满整个容器的高度</li>
</ul>
<h3 id="justify-content-flex-start-flex-end-center-space-between-space-around"><a href="#justify-content-flex-start-flex-end-center-space-between-space-around" class="headerlink" title="justify-content: flex-start | flex-end | center | space-between | space-around"></a>justify-content: flex-start | flex-end | center | space-between | space-around</h3><p>水平对齐方式</p>
<ul>
<li>flex-start(默认值)：左对齐</li>
<li>flex-end：右对齐</li>
<li>center：居中</li>
<li>space-between：两端对齐，项目之间的间隔都相等</li>
<li>space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍</li>
</ul>
<h2 id="实现【水平垂直居中】"><a href="#实现【水平垂直居中】" class="headerlink" title="实现【水平垂直居中】"></a>实现【水平垂直居中】</h2><ul>
<li>display: flex; + align-items: center; + justify-content: center;</li>
<li>position + top/left + margin</li>
<li>position + top/left + transform</li>
</ul>
<h1 id="position"><a href="#position" class="headerlink" title="position"></a>position</h1><p>static、fixed、relative、absolute、sticky</p>
<p>设置 position 的值为非 static，会提升元素的垂直地位 (z-index)。</p>
<p>设置 position 的值为 absolute、fixed，元素脱离文档流。</p>
<p>如果仅仅定义 position，不定义 top/margin/transform 等尾翼值，元素仍然停留在本身正常位置。</p>
<h2 id="position-relative"><a href="#position-relative" class="headerlink" title="position: relative"></a>position: relative</h2><p>相对位置，相对元素本身正常位置。</p>
<h2 id="fixed-与-absolute-的区别"><a href="#fixed-与-absolute-的区别" class="headerlink" title="fixed 与 absolute 的区别"></a>fixed 与 absolute 的区别</h2><p>fixed 浮动定位是相对于浏览器视窗的。</p>
<p>absolute 绝对定位是相对于父级中设置 position 为 relative 或者 absolute 最近的父级元素。如果父级没有会向上查找，知道 html 根节点。</p>
<h2 id="sticky"><a href="#sticky" class="headerlink" title="sticky"></a>sticky</h2><p>sticky 英文字面意思是粘，粘贴，所以可以把它称之为粘性定位。</p>
<p>position: sticky; 基于用户的滚动位置来定位。</p>
<p>粘性定位的元素是依赖于用户的滚动，在 position: relative 与 position: fixed 之间切换。</p>
<p>它的行为就像 position: relative; 而当页面滚动超出目标区域时，它的表现就像 position: fixed;，它会固定在目标位置。</p>
<p>元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。</p>
<p>这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.sticky</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: sticky;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://caniuse.com/#search=sticky" target="_blank" rel="noopener">兼容性低</a></p>
<p>ios &gt;= 10.3</p>
<h1 id="transform"><a href="#transform" class="headerlink" title="transform"></a>transform</h1><p><a href="https://www.zhangxinxu.com/wordpress/2015/05/css3-transform-affect/" target="_blank" rel="noopener">transform 对普通元素的 N 多渲染影响</a></p>
<h2 id="transform-提升元素的垂直地位-z-index"><a href="#transform-提升元素的垂直地位-z-index" class="headerlink" title="transform 提升元素的垂直地位 (z-index)"></a>transform 提升元素的垂直地位 (z-index)</h2><p>当遭遇元素设置 margin 负值重叠的时候，如果没有 static 以外的 position 属性值的话，后面的元素是会覆盖前面的元素的。</p>
<p>但是，元素应用了 transform 属性之后，就会变得跟应用了 position: relative 一样，原本应该被覆盖的元素会雄起，变成覆盖其他元素。</p>
<p>transform 相当于给元素加了 position: relative。</p>
<h2 id="transform-限制-position-fixed-的跟随效果"><a href="#transform-限制-position-fixed-的跟随效果" class="headerlink" title="transform 限制 position: fixed 的跟随效果"></a>transform 限制 position: fixed 的跟随效果</h2><p>设置 transform 的元素，其内部元素的 position: fixed 会失效，降级变成 position: absolute。</p>
<p>transform 相当于给元素加了 position: relative。</p>
<p>内部元素 position: fixed 变成了 position: absolute。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"transform: scale(1)"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"position: fixed"</span>&gt;</span></span><br><span class="line">    fixed 失效</span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>Chrome / FireFox 有这种 bug。</p>
<p>利用 这个 bug 可以使 fixed 元素相对于父级定位。</p>
<h2 id="transform-改变-overflow-对-absolute-元素的限制"><a href="#transform-改变-overflow-对-absolute-元素的限制" class="headerlink" title="transform 改变 overflow 对 absolute 元素的限制"></a>transform 改变 overflow 对 absolute 元素的限制</h2><p>absolute 绝对定位元素，如果含有 overflow 为非 visible 的父级元素，同时，该父级元素以及到该绝对定位元素之间任何嵌套元素都没有 position 为非 static 属性或 transform 属性的声明，则 overflow 对该 absolute 元素不起作用。</p>
<p>transform 相当于给元素加了 position: relative。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 100px;height: 100px;overflow: hidden;background: red"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 200px;height: 200px;background: blue"</span>&gt;</span>被修剪，溢出部分不显示<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 100px;height: 100px;overflow: hidden;background: red"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 200px;height: 200px;background: blue;position: absolute"</span>&gt;</span>不会被修剪，溢出部分显示<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 100px;height: 100px;overflow: hidden;background: red;position: relative"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 200px;height: 200px;background: blue;position: absolute"</span>&gt;</span>被修剪，溢出部分不显示<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 100px;height: 100px;overflow: hidden;background: red;transform: scale(1)"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 200px;height: 200px;background: blue;position: absolute"</span>&gt;</span>被修剪，溢出部分不显示<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="transform-限制-absolute-的-100-宽度大小"><a href="#transform-限制-absolute-的-100-宽度大小" class="headerlink" title="transform 限制 absolute 的 100% 宽度大小"></a>transform 限制 absolute 的 100% 宽度大小</h2><p>设置 absolute 元素宽度 100%, 则都会参照第一个 非 static 值的 position 或 不具有 transform 的祖先元素计算，没有就 window。</p>
<p>transform 相当于给元素加了 position: relative。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 100px;height: 100px;background: red"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 100%;height: 200px;background: blue"</span>&gt;</span>溢出部分显示<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 100px;height: 100px;background: red;position: relative"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 100%;height: 200px;background: blue;position: absolute"</span>&gt;</span>被压缩在父级元素中显示<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 100px;height: 100px;overflow: hidden;background: red;transform: scale(1)"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"width: 100%;height: 200px;background: blue;position: absolute"</span>&gt;</span>被压缩在父级元素中显示<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h1 id="float-浮动"><a href="#float-浮动" class="headerlink" title="float 浮动"></a>float 浮动</h1><p>浮动出现的意义其实只是用来<code>让文字环绕图片</code>而已，仅此而已。</p>
<p>用浮动实现页面布局本不是浮动该干的事情。</p>
<p>浮动的本质定义为“包裹与破坏”。</p>
<p><a href="https://www.zhangxinxu.com/wordpress/2010/01/css-float%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E3%80%81%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%8B%93%E5%B1%95%E4%B8%80/" target="_blank" rel="noopener">CSS float浮动 一</a></p>
<p><a href="https://www.zhangxinxu.com/wordpress/2010/01/css-float%E6%B5%AE%E5%8A%A8%E7%9A%84%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6%E3%80%81%E8%AF%A6%E8%A7%A3%E5%8F%8A%E6%8B%93%E5%B1%95%E4%BA%8C/" target="_blank" rel="noopener">CSS float浮动 二</a></p>
<h2 id="包裹性"><a href="#包裹性" class="headerlink" title="包裹性"></a>包裹性</h2><p>浮动就是个带有方位的 display: inline-block 属性。</p>
<h2 id="破坏性"><a href="#破坏性" class="headerlink" title="破坏性"></a>破坏性</h2><p>浮动破坏了正常的 line box 模型，就没有了 inline box 该有的高度，实际占据的高度为 0。</p>
<h1 id="清除浮动造成的影响"><a href="#清除浮动造成的影响" class="headerlink" title="清除浮动造成的影响"></a>清除浮动造成的影响</h1><p>所谓清除浮动，其实应该是 float: none。</p>
<p>而我们关注的其实是清除浮动造成的影响。</p>
<ul>
<li>父级 div 设置 zoom 值，并定义伪元素 ::after</li>
<li>父级 div 定义 height，并定义 overflow: hidden/auto</li>
<li>父级 div 定义 height，并也设置浮动</li>
<li>最后一个浮动元素结尾处加 <br> 或 <div> ，设置 clear: both</div></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clear-float</span> &#123;</span><br><span class="line">  <span class="attribute">zoom</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clear-float</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">clear</span>: both;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">  <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但自从用了 display: flex，再也没写过 float</p>
<h1 id="页面导入样式的几种方式"><a href="#页面导入样式的几种方式" class="headerlink" title="页面导入样式的几种方式"></a>页面导入样式的几种方式</h1><p>行内样式 </p><p style></p><p></p>
<p>内嵌样式 <style>p{}</style></p>
<p>导入样式 <style>@import ‘style.css’;</style></p>
<p>链接样式 <link href="style.css"></p>
<h1 id="iframe"><a href="#iframe" class="headerlink" title="iframe"></a>iframe</h1><ul>
<li>iframe 会阻塞主页面的 onload 事件</li>
<li>iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载</li>
<li>iframe 页面样式调试麻烦，出现多个滚动条</li>
<li>搜索引擎的检索程序无法解读 iframe，不利于 SEO</li>
</ul>
<h2 id="动态创建和动态销毁-iframe"><a href="#动态创建和动态销毁-iframe" class="headerlink" title="动态创建和动态销毁 iframe"></a>动态创建和动态销毁 iframe</h2><p>例如在处理 App 或微信的 webview 单页面应用时，页面 title 不刷新的问题</p>
<h2 id="iframe-与父页面的-跨域-通信"><a href="#iframe-与父页面的-跨域-通信" class="headerlink" title="iframe 与父页面的(跨域)通信"></a>iframe 与父页面的(跨域)通信</h2><p>parent.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>parent<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"child"</span> <span class="attr">name</span>=<span class="string">"child"</span> <span class="attr">src</span>=<span class="string">"child.html"</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>child.html</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>child<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="父页面访问子页面"><a href="#父页面访问子页面" class="headerlink" title="父页面访问子页面"></a>父页面访问子页面</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> child = <span class="built_in">document</span>.querySelector(<span class="string">'#child'</span>) <span class="comment">// child.html</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> childWindow = child.contentWindow <span class="comment">// child.html 的 window 对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> childDocument = child.contentDocument <span class="comment">// child.html 的 document 对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child2 = <span class="built_in">window</span>.frames[<span class="string">'child'</span>] <span class="comment">// child.html</span></span><br><span class="line"></span><br><span class="line">child === child2 <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="子页面访问父页面"><a href="#子页面访问父页面" class="headerlink" title="子页面访问父页面"></a>子页面访问父页面</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.parent <span class="comment">// 获取上一级容器的 window 对象</span></span><br><span class="line"><span class="built_in">window</span>.top <span class="comment">// 获取最顶级容器的 window 对象，即是你打开页面的文档</span></span><br><span class="line"><span class="built_in">window</span>.self <span class="comment">// 返回自身 window 的引用。可以理解 window === window.self (脑残)</span></span><br></pre></td></tr></table></figure>

<h3 id="判断当前页面是否为子页面"><a href="#判断当前页面是否为子页面" class="headerlink" title="判断当前页面是否为子页面"></a>判断当前页面是否为子页面</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="built_in">window</span>.parent === <span class="built_in">window</span>) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'当前页面不是子页面'</span>)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'当前页面是子页面'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="postMessage-message-targetOrigin-方法与-监听-message-事件"><a href="#postMessage-message-targetOrigin-方法与-监听-message-事件" class="headerlink" title="postMessage(message, targetOrigin) 方法与 监听 message 事件"></a>postMessage(message, targetOrigin) 方法与 监听 message 事件</h3><p>子页面：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听 message 事件</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, (event) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (event.type === <span class="string">'message'</span>) &#123;</span><br><span class="line">    <span class="comment">//  &amp;&amp; event.origin === '指定源'</span></span><br><span class="line">    <span class="keyword">const</span> json = <span class="built_in">JSON</span>.parse(event.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (+json.code === <span class="number">1001</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(json.data.word)</span><br><span class="line"></span><br><span class="line">      <span class="built_in">window</span>.parent.postMessage(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">        code: <span class="number">1001</span>,</span><br><span class="line">        data: &#123;</span><br><span class="line">          word: <span class="string">'我是你儿子'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        message: <span class="string">'成功'</span></span><br><span class="line">      &#125;), <span class="string">'*'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br></pre></td></tr></table></figure>

<p>父页面：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 监听 message 事件</span></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, (event) =&gt; &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(event)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (event.type === <span class="string">'message'</span>) &#123;</span><br><span class="line">    <span class="comment">//  &amp;&amp; event.origin === '指定源'</span></span><br><span class="line">    <span class="keyword">const</span> json = <span class="built_in">JSON</span>.parse(event.data)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (+json.code === <span class="number">1001</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(json.data.word)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给子页面发送消息</span></span><br><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'#child'</span>).contentWindow.postMessage(<span class="built_in">JSON</span>.stringify(&#123;</span><br><span class="line">  code: <span class="number">1001</span>,</span><br><span class="line">  data: &#123;</span><br><span class="line">    word: <span class="string">'我是你爸爸'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  message: <span class="string">'成功'</span></span><br><span class="line">&#125;), <span class="string">'*'</span>)</span><br></pre></td></tr></table></figure>

<h1 id="伪类与伪元素"><a href="#伪类与伪元素" class="headerlink" title="伪类与伪元素"></a>伪类与伪元素</h1><h2 id="伪类"><a href="#伪类" class="headerlink" title="伪类"></a>伪类</h2><p>状态伪类</p>
<ul>
<li>:active</li>
<li>:focus</li>
<li>:hover</li>
<li>:link</li>
<li>:visited</li>
<li>:disabled</li>
<li>:checked</li>
<li>其他…</li>
</ul>
<p>结构性伪类</p>
<ul>
<li>:lang</li>
<li>:first-child</li>
<li>:last-child</li>
<li>:nth-child(n)</li>
<li>:only-child</li>
<li>:empty</li>
<li>:not(selector)</li>
<li>其他…</li>
</ul>
<h2 id="伪元素"><a href="#伪元素" class="headerlink" title="伪元素"></a>伪元素</h2><p>伪元素的由两个冒号::开头，然后是伪元素的名称</p>
<p>使用两个冒号::是为了区别伪类和伪元素(CSS2 中并没有区别)。当然，考虑到兼容性，CSS2中已存的伪元素仍然可以使用一个冒号:的语法，但是 CSS3 中新增的伪元素必须使用两个冒号::</p>
<p>一个选择器只能使用一个伪元素，并且伪元素必须处于选择器语句的最后</p>
<p>伪元素的本质是在不增加dom结构的基础上添加的一个元素，在用法上跟真正的dom无本质区别。普通元素能实现的效果，伪元素都可以。有些用伪元素效果更好，代码更精简</p>
<ul>
<li>::first-letter // 向<code>文本</code>的第一个字母添加特殊样式</li>
<li>::first-line // 向<code>文本</code>的首行添加特殊样式</li>
<li>::before // 在<code>元素</code>之前添加内容</li>
<li>::after // 在<code>元素</code>之后添加内容</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 可以设置 p 中文本的第一字母的样式 */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-letter</span> &#123;</span><br><span class="line">	<span class="attribute">color</span>: blue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 可以设置 p 中文本的第一行的样式 */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::first-line</span> &#123;</span><br><span class="line">	<span class="attribute">color</span>: red;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 可以在 p 之前添加内容 */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">	<span class="attribute">content</span>: <span class="string">'before'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 可以在 p 之后添加内容 */</span></span><br><span class="line"><span class="selector-tag">p</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">	<span class="attribute">content</span>: <span class="string">'after'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="css-权重"><a href="#css-权重" class="headerlink" title="css 权重"></a>css 权重</h1><p>从 0 开始，一个行内样式 +1000，一个 id +100，一个属性选择器/class 或者伪类 +10，一个元素名或者标签名或者伪元素 +1，* 是 0</p>
<p>important &gt; 内嵌样式 &gt; ID &gt; 类 &gt; 标签 | 伪类 | 属性选择 &gt; 伪对象 &gt; 继承 &gt; 通配符</p>
<p>important的权重为 1,0,0,0</p>
<p>ID的权重为 0,1,0,0</p>
<p>类的权重为 0,0,1,0</p>
<p>标签的权重为 0,0,0,1</p>
<p>伪类的权重为 0,0,1,0</p>
<p>属性的权重为 0,0,1,0</p>
<p>伪对象的权重为 0,0,0,1</p>
<p>通配符的权重为0,0,0,0</p>
<h1 id="css-优先级"><a href="#css-优先级" class="headerlink" title="css 优先级"></a>css 优先级</h1><p>!important &gt; id &gt; 属性选择器/class/伪类 &gt; tag/伪元素 &gt; *</p>
<p>出现重复样式，后面写的样式大于前面写的样式</p>
<p>以权重决定样式规则：</p>
<ul>
<li>相同的权重：以后面出现的选择器为最后规则</li>
<li>不同的权重，权重值高则生效</li>
</ul>
<h1 id="display-none-和-visibility-hidden-的区别"><a href="#display-none-和-visibility-hidden-的区别" class="headerlink" title="display: none 和 visibility: hidden 的区别"></a>display: none 和 visibility: hidden 的区别</h1><p>display: none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。</p>
<p>visibility: hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。</p>
<h1 id="lt-DOCTYPE-gt"><a href="#lt-DOCTYPE-gt" class="headerlink" title="&lt;!DOCTYPE&gt;"></a>&lt;!DOCTYPE&gt;</h1><!DOCTYPE><p> 告知浏览器的解析器用什么文档标准解析这个文档。&lt;!DOCTYPE&gt; 不存在或格式不正确会导致文档以兼容模式呈现。</p>
<p>在标准模式中，页面的排版和 JS 运作模式都是以该浏览器支持的最高标准运行。</p>
<p>在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。</p>
<h1 id="HTML5-为什么只需要写"><a href="#HTML5-为什么只需要写" class="headerlink" title="HTML5 为什么只需要写 "></a>HTML5 为什么只需要写 <!DOCTYPE html></h1><p>HTML5 不基于 SGML，因此不需要对 DTD (Document Type Definition) 进行引用，但是需要 DOCTYPE 来规范浏览器的行为(让浏览器按照它们应该的方式来运行)。</p>
<p>换言之，HTML4.01 及以下是基于 SGML，所以需要对 DTD 进行引用，这样才能告知浏览器文档所使用的文档类型。</p>
<p>SGML 是 Standard Generalized Markup language 标准通用标记语言。一种很强大但很复杂的标记语言，HTML、XML 就是从中衍生出来的。</p>
<p>DTD 是 Document Type Definition 文档类型定义，是一套为了进行程序间的数据交换而建立的关于标记符的语法规则。</p>
<h1 id="有哪些惊奇的-HTML5-特性"><a href="#有哪些惊奇的-HTML5-特性" class="headerlink" title="有哪些惊奇的 HTML5 特性"></a>有哪些惊奇的 HTML5 特性</h1><p>async 属性</p>
<p>语义化，比如 article、footer、header、nav、section</p>
<p>表单控件，比如 calendar、date、time、email、url、search</p>
<p>video/audio 更加友好</p>
<p>drag/drop 拖放</p>
<h2 id="拖放-drag-和-drop"><a href="#拖放-drag-和-drop" class="headerlink" title="拖放(drag 和 drop)"></a>拖放(drag 和 drop)</h2><p>设置可拖 draggable=”true” 属性</p>
<p>监听拖事件 ondragstart=”drag”</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">id</span>=<span class="string">"img"</span> <span class="attr">draggable</span>=<span class="string">"true"</span> <span class="attr">ondragstart</span>=<span class="string">"drag"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">drag (e) &#123;</span><br><span class="line">  <span class="keyword">const</span> data = e.target.id <span class="comment">// 设置需要拖的数据</span></span><br><span class="line">  e.dataTransfer.setData(<span class="string">'Text'</span>, data) <span class="comment">// 将数据设置到拖对象中，指定数据类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置可放 allowDrop=”allowDrop” 属性</p>
<p>监听放事件 ondrop=”drop”</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ondragover</span>=<span class="string">"allowDrop"</span> <span class="attr">ondrop</span>=<span class="string">"drop"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">allowDrop (e) &#123;</span><br><span class="line">  e.preventDefault() <span class="comment">// 阻止浏览器对数据的默认处理(drop 事件的默认行为是以链接形式打开)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">drop (e) &#123;</span><br><span class="line">  e.preventDefault() <span class="comment">// 阻止浏览器对数据的默认处理(drop 事件的默认行为是以链接形式打开)</span></span><br><span class="line">  <span class="keyword">const</span> data = e.dataTransfer.getData(<span class="string">'Text'</span>) <span class="comment">// 获取放过来的值</span></span><br><span class="line">  e.target.appendChild(<span class="built_in">document</span>.getElementById(data)) <span class="comment">// 处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="canvas"><a href="#canvas" class="headerlink" title="canvas"></a>canvas</h2><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">canvas</span> <span class="attr">width</span>=<span class="string">"200"</span> <span class="attr">height</span>=<span class="string">"100"</span>&gt;</span><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>canvas 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> canvas = <span class="built_in">document</span>.querySelect(<span class="string">'canvas'</span>)</span><br><span class="line"><span class="keyword">const</span> cxt = canvas.getContext(<span class="string">'2d'</span>)</span><br><span class="line">cxt.fillStyle = <span class="string">'#f00'</span></span><br><span class="line">cxt.fillRect(<span class="number">0</span>, <span class="number">0</span>, <span class="number">150</span>, <span class="number">75</span>)</span><br><span class="line"><span class="keyword">const</span> img = <span class="keyword">new</span> Image()</span><br><span class="line">img.src = <span class="string">'https://cmspic-10004025.image.myqcloud.com/4273a6c5-7b92-40e2-a0d0-841741f87b6e'</span></span><br><span class="line">cxt.drawImage(img, <span class="number">0</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<h2 id="svg"><a href="#svg" class="headerlink" title="svg"></a>svg</h2><h2 id="地理定位-Geolocation"><a href="#地理定位-Geolocation" class="headerlink" title="地理定位 Geolocation"></a>地理定位 Geolocation</h2><p>依赖浏览器的定位。如果是谷歌浏览器，是依赖 <a href="https://www.googleapis.com/" target="_blank" rel="noopener">googleapis</a>。目前需要 VPN 代理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">'geolocation'</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">  <span class="comment">// 地理位置服务可用</span></span><br><span class="line">  navigator.geolocation.getCurrentPosition(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  	<span class="built_in">console</span>.log(res, <span class="string">'success'</span>)</span><br><span class="line">  &#125;, error =&gt; &#123;</span><br><span class="line">  	<span class="built_in">console</span>.log(error, <span class="string">'error'</span>)</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">  	enableHighAccuracy: <span class="literal">true</span>, <span class="comment">// 是否使用其最高精度</span></span><br><span class="line">    timeout: <span class="number">10000</span>, <span class="comment">// 超时</span></span><br><span class="line">  	maximumAge: <span class="number">0</span>, <span class="comment">// 缓存时间</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="comment">// 地理位置服务不可用</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'地理位置服务不可用'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果项目中需要定位，可以引入高德地图、腾讯地图、百度地图等。</p>
<h2 id="Web-存储"><a href="#Web-存储" class="headerlink" title="Web 存储"></a>Web 存储</h2><p>HTML5 提供了两种在客户端存储数据的新方法</p>
<ul>
<li>localStorage - 没有时间限制的数据存储。本地离线存储，可长期存储数据，浏览器关闭后数据不丢失</li>
<li>sessionStorage - 针对一个 session 的数据存储，在浏览器关闭后自动删除</li>
</ul>
<p>之前，这些都是由 cookie 完成的。但是 cookie 不适合大量数据的存储，因为它们由每个对服务器的请求来传递，这使得 cookie 速度很慢而且效率也不高。</p>
<p>在 HTML5 中，数据不是由每个服务器请求传递的，而是只有在请求时使用数据。它使在不影响网站性能的情况下存储大量数据成为可能。</p>
<p>对于不同的网站，数据存储于不同的区域，并且一个网站只能访问其自身的数据。</p>
<p>localStorage 和 sessionStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到5M或更大。</p>
<p>cookie 数据大小不能超过4k。设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(localStorage) <span class="comment">// 是一个类对象</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> localStorage) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, localStorage[key])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这样重新赋值是无效的</span></span><br><span class="line">localStorage = &#123;</span><br><span class="line">  ...localStorage,</span><br><span class="line">  x: <span class="number">1</span>,</span><br><span class="line">  y: <span class="number">2</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// localStorage 只允许添加某属性，而且值会被转成字符串形式，</span></span><br><span class="line"></span><br><span class="line">localStorage[<span class="string">'x'</span>] = <span class="number">1</span></span><br><span class="line">localStorage.y = <span class="number">2</span></span><br><span class="line">localStorage.setItem(<span class="string">'z'</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">localStorage.setItem(<span class="string">'garbage'</span>, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure>

<p>用处：</p>
<ul>
<li>利用 localStorage 来记录当前页面浏览位置。</li>
<li>利用 localStorage 来记录音视控件播放的方式：单曲循环/列表循环/顺序播放/随机播放</li>
</ul>
<h2 id="Application-Cache"><a href="#Application-Cache" class="headerlink" title="Application Cache"></a>Application Cache</h2><p>应用程序缓存</p>
<ul>
<li>离线浏览 - 用户可在应用离线时使用它们</li>
<li>速度 - 已缓存资源加载得更快</li>
<li>减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源</li>
</ul>
<html manifest="demo.appcache"></html>

<h1 id="Web-Workers"><a href="#Web-Workers" class="headerlink" title="Web Workers"></a>Web Workers</h1><p>当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成<br>web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行</p>
<p>worker.js</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> i = <span class="number">0</span></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">  postMessage(++i)</span><br><span class="line">&#125;, <span class="number">1000</span>)</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span>(Worker) === <span class="string">'function'</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> w = <span class="keyword">new</span> Worker(<span class="string">'worker.js'</span>)</span><br><span class="line">  w.onmessage = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e.data)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="HTML-5-服务器发送事件"><a href="#HTML-5-服务器发送事件" class="headerlink" title="HTML 5 服务器发送事件"></a>HTML 5 服务器发送事件</h1><p>postMessage</p>
<p>onopen</p>
<p>onmessage</p>
<p>onerror</p>
<h1 id="js-基本数据类型"><a href="#js-基本数据类型" class="headerlink" title="js 基本数据类型"></a>js 基本数据类型</h1><h2 id="五种基本：Undefined、Null、Boolean、Number、String"><a href="#五种基本：Undefined、Null、Boolean、Number、String" class="headerlink" title="五种基本：Undefined、Null、Boolean、Number、String"></a>五种基本：Undefined、Null、Boolean、Number、String</h2><p>NaN 是 Number 类型</p>
<h2 id="一种特殊：Object"><a href="#一种特殊：Object" class="headerlink" title="一种特殊：Object"></a>一种特殊：Object</h2><p>Object 包含三大引用类型：</p>
<ul>
<li>Object: {}</li>
<li>Array: []</li>
<li>Function: () =&gt; {}</li>
</ul>
<p>其实还有数据封装类对象：Boolean、Number、String</p>
<p>Math、Date、RegExp、Error 等</p>
<p>类数组：NodeList、Arguments</p>
<h1 id="null-与-undefined-与-NaN"><a href="#null-与-undefined-与-NaN" class="headerlink" title="null 与 undefined 与 NaN"></a>null 与 undefined 与 NaN</h1><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// null</span></span><br><span class="line"><span class="literal">null</span> === <span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">!<span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">null</span>) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// 'object'，作为对象原型链的终点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// undefined</span></span><br><span class="line"><span class="literal">undefined</span> === <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">!<span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// 'undefined'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// NaN</span></span><br><span class="line"><span class="literal">NaN</span> == <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">!<span class="literal">NaN</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">NaN</span>) <span class="comment">// NaN</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span> <span class="comment">// 'number'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h1 id="this-关键词"><a href="#this-关键词" class="headerlink" title="this 关键词"></a>this 关键词</h1><p>其实就是作用域问题</p>
<p>ES6 后很少就关心了</p>
<p>偶尔涉及的时候，使用 <code>that</code> 管理一下</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> that = <span class="keyword">this</span></span><br></pre></td></tr></table></figure>

<h1 id="apply-与-call"><a href="#apply-与-call" class="headerlink" title="apply 与 call"></a>apply 与 call</h1><p>调用一个对象的一个方法，用另一个对象替换当前对象</p>
<p>将一个函数的对象上下文从初始的上下文改变为由 this 指定的新对象</p>
<h2 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h2><p>只接受两个参数，新 this 对象和一个参数数组 argArray</p>
<p>Function.apply(this, [1, 2, 3])</p>
<p>this 对象应用 Function 对象的方法</p>
<h2 id="call"><a href="#call" class="headerlink" title="call"></a>call</h2><p>接受多个参数，第一个参数与 apply 一样，都是新 this 对象，后面则是一串参数列表</p>
<p>Function.call(this, 1, 2, 3)</p>
<p>Function 对象调用 this 对象的方法</p>
<h2 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sub</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a1 = add.apply(sub, [<span class="number">4</span>, <span class="number">2</span>]) <span class="comment">// sub 应用 add 的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a2 = sub.call(add, <span class="number">4</span>, <span class="number">2</span>) <span class="comment">// sub 应用 add 的方法</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a1);  <span class="comment">// 6</span></span><br><span class="line"><span class="built_in">console</span>.log(a2);  <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h2 id="实现继承"><a href="#实现继承" class="headerlink" title="实现继承"></a>实现继承</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.showName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Cat</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Animal.apply(<span class="keyword">this</span>, [name])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dog</span> (<span class="params">name</span>) </span>&#123;</span><br><span class="line">  Animal.call(<span class="keyword">this</span>, name)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> cat = <span class="keyword">new</span> Cat(<span class="string">'喵喵'</span>) <span class="comment">// cat 通过 apply 继承了 Animal 的 name 属性和 showName 方法</span></span><br><span class="line">cat.showName() <span class="comment">// 喵喵</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> dog = <span class="keyword">new</span> Dog(<span class="string">'汪汪'</span>) <span class="comment">// dog 通过 call 继承了 Animal 的 name 属性和 showName 方法</span></span><br><span class="line">dog.showName() <span class="comment">// 汪汪</span></span><br></pre></td></tr></table></figure>

<h2 id="apply-和-call-的一些巧妙"><a href="#apply-和-call-的一些巧妙" class="headerlink" title="apply 和 call 的一些巧妙"></a>apply 和 call 的一些巧妙</h2><p>apply 可以将一些接受参数列表转化为接受参数数组的形式</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Math.max(param1, param2...)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>] <span class="comment">// 比较大小</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.max(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>) <span class="comment">// 6</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">max</span> (<span class="params">argArray</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, argArray)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">max(arr) <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// push(param1, param2...)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">arr1.push(<span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(arr, [<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">arr.concat(<span class="number">2</span>, <span class="number">3</span>) <span class="comment">// [1, 2, 3]</span></span><br><span class="line">arr.concat([<span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3]</span></span><br><span class="line">arr.concat([[<span class="number">2</span>, <span class="number">3</span>]]) <span class="comment">// [1, [2, 3]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.concat(arr, <span class="number">2</span>, <span class="number">3</span>) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.concat(arr, [<span class="number">2</span>, <span class="number">3</span>]) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.concat(arr, [[<span class="number">2</span>, <span class="number">3</span>]]) <span class="comment">// [1, [2, 3]]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.concat.apply(arr, [[<span class="number">2</span>, <span class="number">3</span>]]) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 看最后一个，[1] 应用 Array.prototype.concat 方法，[[2, 3]] 是参数列表，所以等价于：Array.prototype.concat([1], [2, 3])</span></span><br></pre></td></tr></table></figure>

<h1 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h1><p>navigator.userAgent</p>
<h1 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h1><p>100  Continue  继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息<br>200  OK   正常返回信息<br>201  Created  请求成功并且服务器创建了新的资源<br>202  Accepted  服务器已接受请求，但尚未处理<br>301  Moved Permanently  请求的网页已永久移动到新位置。<br>302  Found  临时性重定向。<br>303  See Other  临时性重定向，且总是使用 GET 请求新的 URI。<br>304  Not Modified  自从上次请求后，请求的网页未修改过。<br>400  Bad Request  服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。<br>401  Unauthorized  请求未授权。<br>403  Forbidden  禁止访问。<br>404  Not Found  找不到如何与 URI 相匹配的资源。<br>500  Internal Server Error  最常见的服务器端错误。<br>503  Service Unavailable 服务器端暂时无法处理请求(可能是过载或维护)。</p>
<h1 id="哪些性能优化的方法？"><a href="#哪些性能优化的方法？" class="headerlink" title="哪些性能优化的方法？"></a>哪些性能优化的方法？</h1><p>减少http请求次数：CSS Sprites, htnl、JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器</p>
<p>前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数</p>
<p>用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能</p>
<p>当需要设置的样式很多时设置className而不是直接操作style</p>
<p>少用全局变量、缓存DOM节点查找的结果，减少IO读取操作</p>
<p>避免使用CSS Expression(css表达式)又称Dynamic properties(动态属性)</p>
<p>图片预加载</p>
<p>将样式表放在顶部，将脚本放在底部</p>
<h1 id="内存泄漏"><a href="#内存泄漏" class="headerlink" title="内存泄漏"></a>内存泄漏</h1><p>内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。</p>
<p>垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0(没有其他对象引用过该对象)，或对该对象的惟一引用是循环的，那么该对象的内存即可回收。</p>
<p>setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。</p>
<p>闭包、控制台日志、循环(在两个对象彼此引用且彼此保留时，就会产生一个循环)</p>
<h1 id="线程与进程"><a href="#线程与进程" class="headerlink" title="线程与进程"></a>线程与进程</h1><p>一个程序至少有一个进程，一个进程至少有一个线程。</p>
<p>线程的划分尺度小于进程，使得多线程程序的并发性高。</p>
<p>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p>
<p>每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。</p>
<p>从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。</p>
<h1 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h1><h1 id="对象的浅拷贝和深拷贝；浅复制和深复制"><a href="#对象的浅拷贝和深拷贝；浅复制和深复制" class="headerlink" title="对象的浅拷贝和深拷贝；浅复制和深复制"></a>对象的浅拷贝和深拷贝；浅复制和深复制</h1><h1 id="js-操作获取和设置-cookie"><a href="#js-操作获取和设置-cookie" class="headerlink" title="js 操作获取和设置 cookie"></a>js 操作获取和设置 cookie</h1><h1 id="ajax-有那些优缺点"><a href="#ajax-有那些优缺点" class="headerlink" title="ajax 有那些优缺点"></a>ajax 有那些优缺点</h1><p>优点：</p>
<ul>
<li>通过异步模式，提升了用户体验.</li>
<li>优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用.</li>
<li>Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。</li>
<li>Ajax可以实现动态不刷新(局部刷新)</li>
</ul>
<p>缺点：</p>
<ul>
<li>安全问题 AJAX暴露了与服务器交互的细节。</li>
<li>对搜索引擎的支持比较弱。</li>
<li>不容易调试。</li>
</ul>
<h1 id="如何解决跨域问题？"><a href="#如何解决跨域问题？" class="headerlink" title="如何解决跨域问题？"></a>如何解决跨域问题？</h1><p>jsonp、iframe、window.name、window.postMessage、服务器上设置代理页面</p>
<h1 id="JavaScript-原型，原型链"><a href="#JavaScript-原型，原型链" class="headerlink" title="JavaScript 原型，原型链"></a>JavaScript 原型，原型链</h1><p>原型也是普通的对象，是对象一个自带隐式的 <strong>proto</strong> 属性。</p>
<p>原型也有可能有自己的原型。如果一个原型的原型为非 null 的话，我们就称之为原型链。</p>
<p>原型链是由一些用来继承和共享属性的对象组成的(有限的)对象链。</p>
<p>Array</p>
<p>Array.<strong>proto</strong></p>
<p>Array.<strong>proto</strong>.<strong>proto</strong></p>
<p>Array.<strong>proto</strong>.<strong>proto</strong>.<strong>proto</strong> —–&gt; null</p>
<h1 id="GET-和-POST-的区别"><a href="#GET-和-POST-的区别" class="headerlink" title="GET 和 POST 的区别"></a>GET 和 POST 的区别</h1><p>GET：一般用于信息获取，使用 URL 传递参数，对所发送信息的数量也有限制，一般在2000个字符</p>
<p>POST：一般用于修改服务器上的资源，对所发送的信息没有限制。</p>
<p>GET 方式需要使用 Request.QueryString 来取得变量的值，而 POST 方式通过 Request.Form 来获取变量的值，也就是说 GET 是通过地址栏来传值，而 POST 是通过提交表单来传值。</p>
<p>然而，在以下情况中，请使用 POST 请求：</p>
<p>无法使用缓存文件(更新服务器上的文件或数据库)</p>
<p>向服务器发送大量数据(POST 没有数据量限制)</p>
<p>发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠</p>
<h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><p>协议，域名，端口相同，同源策略是一种安全协议。</p>
<h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>函数可以访问函数外的变量。</p>
<p>如何在函数外使用函数内的变量呢，闭包。</p>
<p>闭包，指的是词法表示包括不被计算的变量的函数，也就是说，函数可以使用函数之外定义的变量。</p>
<p>闭包是可访问上一层函数作用域里变量的函数，即便上一层函数已经关闭。</p>
<p>闭包是子函数可以使用父函数的局部变量和参数。</p>
<p>一个拥有许多变量和绑定了这些变量的环境的表达式(通常是一个函数)，因而这些变量也是该表达式的一部分。</p>
<p>闭包就是一个函数引用另一个函数的变量，因为变量被引用着所以不会被回收，因此可以用来封装一个私有变量。这是优点也是缺点，不必要的闭包只会增加内存消耗。</p>
<p>闭包的特点：</p>
<ul>
<li>作为一个函数变量的一个引用，当函数返回时，其处于激活状态。</li>
<li>一个闭包就是当一个函数返回时，一个没有释放资源的栈区。</li>
</ul>
<h1 id="javascript-里面的继承怎么实现，如何避免原型链上面的对象共享"><a href="#javascript-里面的继承怎么实现，如何避免原型链上面的对象共享" class="headerlink" title="javascript 里面的继承怎么实现，如何避免原型链上面的对象共享"></a>javascript 里面的继承怎么实现，如何避免原型链上面的对象共享</h1><p>用构造函数和原型链的混合模式去实现继承，避免对象共享可以参考经典的 extend() 函数，很多前端框架都有封装的，就是用一个空函数当做中间变量。</p>
<h1 id="ajax-过程"><a href="#ajax-过程" class="headerlink" title="ajax 过程"></a>ajax 过程</h1><ul>
<li>创建 XHR - XMLHttpRequest 对象，也就是创建一个异步调用对象</li>
<li>创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL及验证信息</li>
<li>设置响应 HTTP 请求状态变化的函数</li>
<li>发送 HTTP 请求</li>
<li>获取异步调用返回的数据.</li>
<li>使用 JavaScript 和 DOM 实现局部刷新</li>
</ul>
<h1 id="游览器输入-URL-到页面加载显示完成，这个过程中都发生了什么？"><a href="#游览器输入-URL-到页面加载显示完成，这个过程中都发生了什么？" class="headerlink" title="游览器输入 URL 到页面加载显示完成，这个过程中都发生了什么？"></a>游览器输入 URL 到页面加载显示完成，这个过程中都发生了什么？</h1><p>(1)查找浏览器缓存-是否有缓存<br>(2)无缓存，做 DNS 解析、查找该域名对应的 IP 地址、重定向(301/302)、发出第二个 GET 请求<br>(3)进行 HTTP 协议会话<br>(4)客户端发送报头(请求报头)<br>(5)服务器回馈报头(响应报头)<br>(6)HTML 文档开始下载<br>(7)文档树建立，根据标记请求所需指定 MIME 类型的文件<br>(8)页面显示</p>
<h1 id="URL-和-URI-有什么不同"><a href="#URL-和-URI-有什么不同" class="headerlink" title="URL 和 URI 有什么不同?"></a>URL 和 URI 有什么不同?</h1><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="扩展运算符-spread-是三个点-…"><a href="#扩展运算符-spread-是三个点-…" class="headerlink" title="扩展运算符(spread)是三个点(…)"></a>扩展运算符(spread)是三个点(…)</h2><ul>
<li>替代函数的 apply 方法</li>
<li>复制数组(浅拷贝)</li>
<li>合并数组(浅拷贝)</li>
<li>与解构赋值结合</li>
<li>将字符串转为真正的数组</li>
<li>任何 Iterator 接口的对象 (Set 和 Map) 和 类似数组的对象 (arrayLike，nodeList)，都可以用扩展运算符转为真正的数组</li>
</ul>
<p>扩展运算符(…) 调用的是遍历器接口(Symbol.iterator)，如果一个对象没有部署这个接口，就无法转换。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr1 = [</span><br><span class="line">  &#123;</span><br><span class="line">    key: <span class="string">'value'</span></span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr2 = [...a1] <span class="comment">// arr2 对 arr1 的浅拷贝，克隆</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 改变 arr1 中的值，会</span></span><br></pre></td></tr></table></figure>

<h2 id="Array-from"><a href="#Array-from" class="headerlink" title="Array.from()"></a>Array.from()</h2><p>Array.from 方法用于将两类对象转为真正的数组：类似数组的对象(arrayLike，nodeList)和可遍历(iterable)的对象(包括 ES6 新增的数据结构 Set 和 Map)。</p>
<p>所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过 Array.from 方法转为数组，而此时扩展运算符 (…) 就无法转换。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(&#123; <span class="attr">length</span>: <span class="number">3</span> &#125;)</span><br><span class="line"><span class="comment">// [ undefined, undefined, undefined ]</span></span><br></pre></td></tr></table></figure>

<h2 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h2><h2 id="find-和-findIndex"><a href="#find-和-findIndex" class="headerlink" title="find() 和 findIndex()"></a>find() 和 findIndex()</h2><h2 id="entries-，keys-和values"><a href="#entries-，keys-和values" class="headerlink" title="entries()，keys()和values()"></a>entries()，keys()和values()</h2><h2 id="entries-，keys-和values-1"><a href="#entries-，keys-和values-1" class="headerlink" title="entries()，keys()和values()"></a>entries()，keys()和values()</h2><h1 id="vue"><a href="#vue" class="headerlink" title="vue"></a>vue</h1><p><a href="https://www.jianshu.com/p/b1dd80f4d542" target="_blank" rel="noopener">https://www.jianshu.com/p/b1dd80f4d542</a></p>
<h2 id="计算属性-computed-与方法-methods"><a href="#计算属性-computed-与方法-methods" class="headerlink" title="计算属性 (computed) 与方法 (methods)"></a>计算属性 (computed) 与方法 (methods)</h2><p>计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要相关依赖没有发生改变，多次访问计算属性会立即返回之前的计算结果，而不必再次执行函数。</p>
<p>相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。</p>
<h2 id="计算属性-computed-与侦听属性-watch"><a href="#计算属性-computed-与侦听属性-watch" class="headerlink" title="计算属性 (computed) 与侦听属性 (watch)"></a>计算属性 (computed) 与侦听属性 (watch)</h2><p>当需要在数据变化时执行异步或开销较大的操作时，侦听属性 (watch) 最有用。</p>
<p>使用 watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>
<h2 id="用-key-管理可复用的元素"><a href="#用-key-管理可复用的元素" class="headerlink" title="用 key 管理可复用的元素"></a>用 key 管理可复用的元素</h2><p>Vue 为你提供了一种方式来表达 “这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 key 属性即可。</p>
<p>在使用 v-for 时，key 是必须的！</p>
<p><a href="https://cn.vuejs.org/v2/guide/list.html#key" target="_blank" rel="noopener">https://cn.vuejs.org/v2/guide/list.html#key</a></p>
<p>v-for 的 in 和 of</p>
<p>v-for=”todo in todos”</p>
<p>v-for=”todo of todos”</p>
<p>v-for=”n in 10”</p>
<h2 id="v-if-和-v-show-区别"><a href="#v-if-和-v-show-区别" class="headerlink" title="v-if 和 v-show 区别"></a>v-if 和 v-show 区别</h2><p>v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。</p>
<p>v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>
<p>相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。</p>
<p>一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。</p>
<h2 id="为什么避免-v-if-和-v-for-一起使用"><a href="#为什么避免-v-if-和-v-for-一起使用" class="headerlink" title="为什么避免 v-if 和 v-for 一起使用"></a>为什么避免 v-if 和 v-for 一起使用</h2><p>当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级，这意味着 v-if 将分别重复运行于每个 v-for 循环中。[当你想为仅有的一些项渲染节点时，这种优先级的机制会十分有用]</p>
<h2 id="组件通信"><a href="#组件通信" class="headerlink" title="组件通信"></a>组件通信</h2><ul>
<li>父组件与子组件传值<ul>
<li>父组件通过标签上面定义属性传值 [v-on:property]</li>
<li>子组件通过 props 选项接受数据</li>
</ul>
</li>
<li>子组件向父组件传递数据<ul>
<li>父组件通过标签上面定义事件 [v-on:function]</li>
<li>子组件通过 $emit 触发事件，可以传递值</li>
</ul>
</li>
<li>组件上使用 v-model</li>
<li>利用 vuex</li>
</ul>
<h2 id="vue-如何实现按需加载"><a href="#vue-如何实现按需加载" class="headerlink" title="vue 如何实现按需加载"></a>vue 如何实现按需加载</h2><p>异步组件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  component: <span class="keyword">async</span> () =&gt; <span class="keyword">await</span> <span class="keyword">import</span>(<span class="string">'./wxarticles/wxarticle/index.vue'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>或者 webpack 的 require.ensure</p>
<h2 id="vue-的生命周期"><a href="#vue-的生命周期" class="headerlink" title="vue 的生命周期"></a>vue 的生命周期</h2><p>创建前/后，载入前/后，更新前/后，销毁前/销毁后</p>
<p>beforeCreate</p>
<ul>
<li>在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。</li>
</ul>
<p>created</p>
<ul>
<li>在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。</li>
</ul>
<p>beforeMount</p>
<ul>
<li>在挂载开始之前被调用：相关的 render 函数首次被调用。</li>
<li>该钩子在服务器端渲染期间不被调用。</li>
</ul>
<p>mounted</p>
<ul>
<li><p>el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。</p>
</li>
<li><p>注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">mounted: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Code that will run only after the</span></span><br><span class="line">    <span class="comment">// entire view has been rendered</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>该钩子在服务器端渲染期间不被调用。</p>
</li>
</ul>
<p>beforeUpdate</p>
<ul>
<li>数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。</li>
<li>该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。</li>
</ul>
<p>updated</p>
<ul>
<li><p>由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。</p>
</li>
<li><p>当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。</p>
</li>
<li><p>注意 updated 不会承诺所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以用 vm.$nextTick 替换掉 updated</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">updated: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.$nextTick(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Code that will run only after the</span></span><br><span class="line">    <span class="comment">// entire view has been rendered</span></span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>该钩子在服务器端渲染期间不被调用。</p>
</li>
</ul>
<p>beforeDestroy</p>
<ul>
<li>实例销毁之前调用。在这一步，实例仍然完全可用。</li>
<li>该钩子在服务器端渲染期间不被调用。</li>
</ul>
<p>destroyed</p>
<ul>
<li>Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。</li>
<li>该钩子在服务器端渲染期间不被调用。</li>
</ul>
<h2 id="节点、树以及虚拟-DOM"><a href="#节点、树以及虚拟-DOM" class="headerlink" title="节点、树以及虚拟 DOM"></a>节点、树以及虚拟 DOM</h2><p>VNode，Virtual Node 虚拟节点</p>
<p>组件树中的所有 VNodes 必须是唯一的</p>
<p>Vue 通过建立一个虚拟 DOM 对真实 DOM 发生的变化保持追踪</p>
<h2 id="什么是-MVVM"><a href="#什么是-MVVM" class="headerlink" title="什么是 MVVM"></a>什么是 MVVM</h2><p>Model-View-ViewModel，MVC 的改进版。</p>
<p>Model 层代表数据模型，在 Model 中定义数据修改和操作的业务逻辑。</p>
<p>View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来。</p>
<p>ViewModel 是一个同步 View 和 Model 的对象。</p>
<p>Model 和 View 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的，因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。</p>
<p>ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。</p>
<ol>
<li>低耦合。视图(View)可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的 View 上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。</li>
<li>可重用性。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 View 重用这段视图逻辑。</li>
<li>独立开发。开发人员可以专注于业务逻辑和数据的开发(ViewModel)，设计人员可以专注于页面设计</li>
<li>可测试。界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。</li>
</ol>
<h2 id="MVVM-和-MVC-区别"><a href="#MVVM-和-MVC-区别" class="headerlink" title="MVVM 和 MVC 区别"></a>MVVM 和 MVC 区别</h2><p>Model View Controller</p>
<p>Model(模型)表示应用程序核心(比如数据库记录列表)。<br>View(视图)显示数据(数据库记录)。<br>Controller(控制器)处理输入(写入数据库记录)。</p>
<p>区别并不大。主要就是 MVC 中 Controller 演变成 MMVVM 中的 ViewModel。</p>
<p>MVC 中改变 View 需要大量的 DOM 操作，这使页面渲染性能降低，加载速度变慢，影响用户体验。</p>
<p>MVVM 是数据驱动，通过数据来显示视图层而不是节点操作。数据操作比较多的场景，更加便捷。</p>
<h2 id="vue-的优点"><a href="#vue-的优点" class="headerlink" title="vue 的优点"></a>vue 的优点</h2><ol>
<li>低耦合。视图(View)可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的 View 上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。</li>
<li>可重用性。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 View 重用这段视图逻辑。</li>
<li>独立开发。开发人员可以专注于业务逻辑和数据的开发(ViewModel)，设计人员可以专注于页面设计</li>
<li>可测试。界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。</li>
</ol>
<h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><h3 id="路由之间跳转"><a href="#路由之间跳转" class="headerlink" title="路由之间跳转"></a>路由之间跳转</h3><p>声明式(标签跳转) 编程式( js跳转)</p>
<h3 id="navigation-guards-导航守卫"><a href="#navigation-guards-导航守卫" class="headerlink" title="navigation-guards 导航守卫"></a>navigation-guards 导航守卫</h3><p>全局守卫、路由独享的守卫、组件内的守卫</p>
<h2 id="vuex"><a href="#vuex" class="headerlink" title="vuex"></a>vuex</h2><h1 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h1><p>wepy</p>
<p>mpvue</p>
<ul>
<li><p>请勿在 scroll-view 中使用 textarea、map、canvas、video 组件。在 <scroll-view> 中滚动时，<textarea> 的 placeholder 和内容会固定不动，好像 fixed 了</textarea></scroll-view></p>
</li>
<li><p>wx.showShareMenu 与 wx.updateShareMenu 的区别</p>
</li>
<li><p><navigator hover-class="none"> 去除点击态效果</navigator></p>
</li>
<li><p><input> 微信版本 6.3.30, focus 属性设置无效；placeholder 在聚焦时出现重影问题；字体是系统字体，所以无法设置 font-family；在 input 聚焦期间，避免使用 css 动画</p>
</li>
<li><p><code>hidden</code> 属性的作用，其实是 <code>*[hidden]{display:none}</code>，存在被覆盖从而失效的可能</p>
</li>
<li><p>前端 wx.login 换取 code (后端通过 code 换取 session_key)，前端 shareTicket 解析 encryptedData、iv，后端拿 session_key、encryptedData、iv 解析群信息如 openGId 存在失败的可能。<code>执行顺序很关键！得先解析 wx.login 换取 code，再用 shareTicket 解析 encryptedData、iv</code></p>
</li>
<li><p>开发版二维码可以在微信开发者工具中生成，可带参数；体验版二维码可以在微信公众平台中[开发管理-&gt;开发版本-&gt;修改页面路径带参数]</p>
</li>
<li><p>并发请求限制</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">每次切换后，同时请求三条接口(并发)，会导致手机卡顿，所有改成请求一条接口后，再请求其他接口。</span><br><span class="line"></span><br><span class="line">当前tab下请求发出，打一个loading=<span class="literal">true</span>，只要当前tab下请求不结束，不再触发同一请求。</span><br><span class="line"></span><br><span class="line">tab有5个item。点击每个item，需要请求对应的数据。当用户点击第1个item，请求第1类数据时，因为接口异步，无法及时返回；而用户迅速点击第2个item，会去请求第2类数据；类似操作，用户在5个item之间来回切换，网速慢，会导致有很多接口在同时请求(请求发出但迟迟不返回视为请求中)，超出了小程序的限制，导致页面操作卡顿！</span><br><span class="line"></span><br><span class="line">所以需要对请求加以限制(节流)。当用户点击第1个item请求第1类接口，然后来回切换，切换回第1个item时，如果第1类接口不结束那就不应该再次发起。</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> apiLoading1 = <span class="literal">false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> requestApi1 = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (apiLoading1) <span class="keyword">return</span></span><br><span class="line">  apiLoading1 = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">await</span> request(api1)</span><br><span class="line"></span><br><span class="line">  apiLoading1 = <span class="literal">false</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">clickItem1 () &#123;</span><br><span class="line">  <span class="comment">// 点击事件</span></span><br><span class="line">  requestApi()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>cover-view 覆盖在原生组件之上的文本视图，可覆盖的原生组件包括 map、video、canvas、camera、live-player、live-pusher</p>
</li>
<li><p>cover-view 内只能嵌套 cover-view、cover-image、button。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>职业</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript算法</title>
    <url>/zh/2018/10/08/JavaScript%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<p>算法 (Algorithm) 是解决特定问题求解步骤的描述，在计算机中表现为指令的有序序列，并且每条指令表示一个或多个操作。对于给定的问题是可以有多种算法进行解决的。</p>
<a id="more"></a>

<p>没有通用的算法。就跟没有包治百病的药一样。现实世界的问题千奇百怪，解决问题的算法当然也是千变万化的。</p>
<h1 id="时间复杂度和空间复杂度"><a href="#时间复杂度和空间复杂度" class="headerlink" title="时间复杂度和空间复杂度"></a>时间复杂度和空间复杂度</h1><p><a href="https://mp.weixin.qq.com/s/rsqwcEb8cQ3by3mvpHrtzg" target="_blank" rel="noopener">参考</a></p>
<p>为什么需要复杂度分析？</p>
<ul>
<li>学习数据和算法就是为了解“快”和“省”的问题，也就是如何设计你的代码才能使运算效率更快，占用空间更小。那如何来计算代码执行效率呢？这里就会用到复杂度分析。</li>
<li>虽然我们可以用代码准确的计算出执行时间，但是这也会有很多局限性。</li>
<li>数据规模的不同会直接影响到测试结果。比如说同一个排序算法，排序顺序不一样，那么最后的计算效率的结果也会不一样；如果恰好已经是排序好的了数组，那么执行时间就会更短。又比如说如果数据规模比较小的话，测试结果可能也无法反应算法的性能。</li>
<li>测试的环境不同也会影响到测试结果。比如说同一套代码分别在 i3 和 i7 处理器上进行测试，那么 i7 上的测试时间肯定会比 i3 上的短。</li>
</ul>
<p>所以需要一个不用准确的测试结果来衡量，就可以粗略地估计代码执行时间的方法。这就是<code>复杂度分析</code>。</p>
<h2 id="大-O-复杂度表示法"><a href="#大-O-复杂度表示法" class="headerlink" title="大 O 复杂度表示法"></a>大 O 复杂度表示法</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">total</span> (<span class="params">n</span>) </span>&#123; <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>; <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123; <span class="comment">// 3</span></span><br><span class="line">    sum += i + <span class="number">1</span>; <span class="comment">// 4</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们假设每行代码执行的时间都一样，记做 t，那么上面的函数中的第 2 行需要 1 个 t 的时间，第 3 行 和 第 4 行分别需要 n 个 t 的时间，那么这段代码总的执行时间为 <code>(2n+1)*t</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">total</span> (<span class="params">n</span>) </span>&#123; <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>; <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123; <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123; <span class="comment">// 4</span></span><br><span class="line">      sum += i + j + <span class="number">1</span>; <span class="comment">// 5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>第 2 行需要一个 t 的时间，第 3 行需要 n 个 t 的时间，第 4 行和第 5 行分别需要 n^2 个的时间，那么这段代码总的执行时间为 <code>(2n^2+n+1)*t</code> 的时间。</p>
<p>从数学角度来看，我们可以得出个规律：代码的总执行时间 T(n) 与每行代码的执行次数成正比：</p>
<p><code>T(n) = O(f(n))</code></p>
<p>在这个公式中，<code>T(n)</code> 表示代码的执行时间；<code>n</code> 表示数据规模的大小；<code>f(n)</code> 表示每行代码执行的次数总和；<code>O</code> 表示代码的执行时间 <code>T(n)</code> 与 <code>f(n)</code> 表达式成正比。</p>
<p>所以上边两个函数的执行时间可以标记为 <code>T(n) = O(2n+1</code>) 和 <code>T(n) = O(2n^2+n+1)</code>。这就是<code>大 O 时间复杂度表示法</code>，它不代表代码真正的执行时间，而是表示代码随数据规模增长的变化趋势，简称<code>时间复杂度</code>。</p>
<p>而且<code>当 n 很大</code>时，我们可以<code>忽略常数项</code>，只<code>保留一个最大量级</code>即可。所以上边的代码执行时间可以简单标记为 <code>T(n) = O(n)</code> 和 <code>T(n) = O(n^2)</code>。</p>
<h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><ol>
<li>只关注循环执行次数最多的一段代码</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">total</span> (<span class="params">n</span>) </span>&#123; <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>; <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123; <span class="comment">// 3</span></span><br><span class="line">    sum += i + <span class="number">1</span>; <span class="comment">// 4</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>只有第 3 行和第 4 行是执行次数最多的，分别执行了 n 次，那么忽略常数项，所以此段代码的时间复杂度就是 O(n)。</p>
<ol start="2">
<li>加法法则：总复杂度等于量级最大的那段代码的复杂度</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">total</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; n; j ++) &#123;</span><br><span class="line">      sum += i + j + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> sum2 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i ++) &#123;</span><br><span class="line">    sum2 += i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> sum3 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">    sum3 += i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们先分别分析每段 for 循环的时间复杂度，再取他们中最大的量级来作为整段代码的时间复杂度。</p>
<p>第一段 for 循环的时间复杂度为 O(n^2)。</p>
<p>第二段 for 循环执行了 1000 次，是个常数量级，尽管对代码的执行时间会有影响，但是当 n 无限大的时候，就可以忽略。因为它本身对增长趋势没有影响，所以这段代码的时间复杂度可以忽略。</p>
<p>第三段 for 循环的时间复杂度为 O(n)。</p>
<p>总上，取最大量级，所以整段代码的时间复杂度为 O(n^2)。</p>
<ol start="3">
<li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fun</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">total</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">    sum += fun(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单独看 total 函数的时间复杂度就是为 <code>T1(n) = O(n)</code>，但是考虑到 fun 函数的时间复杂度也为 <code>T2(n) = O(n)</code>。 所以整段代码的时间复杂度为 <code>T(n) = T1(n) * T2(n) = O(n) * O(n) = O(n^2)</code>。</p>
<h3 id="几种常见的时间复杂度分析"><a href="#几种常见的时间复杂度分析" class="headerlink" title="几种常见的时间复杂度分析"></a>几种常见的时间复杂度分析</h3><p>只看最高量级的复杂度，效率是递减的</p>
<p>O(1) 常数阶</p>
<p>O(logn) 对数阶</p>
<p>O(n) 线性阶</p>
<p>O(n^2) 平方阶</p>
<p>O(n^3) 立方阶</p>
<p>O(2^n) 指数阶</p>
<p>O(n!) 阶乘阶</p>
<p>粗略的分为两类，<code>多项式量级</code>和<code>非多项式量级</code>。其中，非多项式量级只有两个：O(2^n) 和 O(n!)</p>
<p>增长率:</p>
<p><img src="https://cmspic-10004025.image.myqcloud.com/3700160e-b78d-4094-9630-dc77f3c2ec27" alt="增长率"></p>
<p>当数据规模 n 增长时，非多项式量级的执行时间就会急剧增加，所以，非多项式量级的代码算法是非常低效的算法。</p>
<h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p><code>题目：sum = 1+2+3+...+n ，计算 sum 的值。</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">total</span> (<span class="params">n</span>) </span>&#123; <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">var</span> sum = <span class="number">0</span>; <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123; <span class="comment">// 3</span></span><br><span class="line">    sum += i + <span class="number">1</span>; <span class="comment">// 4</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度是 O(n)，能不能优化呢？</p>
<p>利用【等差数列求和公式】：Sn = n(a1 + an)/2</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">total</span> (<span class="params">n</span>) </span>&#123; <span class="comment">// 1</span></span><br><span class="line">  <span class="keyword">var</span> sum = n * (<span class="number">1</span> + n) / <span class="number">2</span>; <span class="comment">// 2</span></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度仅仅为 O(1)，在数据规模比较庞大的时候，是不是明显效率更高!</p>
<h2 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><p>空间复杂度的话和时间复杂度类似推算即可。</p>
<p>所谓空间复杂度就是<code>表示算法的存储空间和数据规模之间的关系</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">initArr</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> arr = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; n; i ++) &#123;</span><br><span class="line">    arr[i] = i</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>根据时间复杂度的推算，忽略掉常数量级，每次数组赋值都会申请一个空间存储变量，所以此函数会申请 n 个的空间，复杂度为 O(n)。</p>
<p>常见的空间复杂度只有 O(1)、O(n)、O(n2)。其他的话很少会用到。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，一个表示执行的快慢，一个表示内存的消耗，用来分析算法执行效率与数据规模之间的增长关系，可以粗略的表示，越高阶复杂度的算法，执行效率越低。</p>
<h1 id="数据结构和算法动态可视化"><a href="#数据结构和算法动态可视化" class="headerlink" title="数据结构和算法动态可视化"></a>数据结构和算法动态可视化</h1><p><a href="https://visualgo.net/zh" target="_blank" rel="noopener">数据结构和算法动态可视化</a></p>
<h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>排序是一个非常经典的问题，它以一定的顺序对一个数组（或一个列表）中的项进行重新排序（可以进行比较，例如整数，浮点数，字符串等）（增加，非递减，递减， 增加，词典等）。</p>
<p>有许多不同的排序算法，每个都有其自身的优点和局限性。</p>
<p>排序通常被用作各种计算机科学课程中的介绍性问题，以展示一系列算法思想。</p>
<h2 id="Array-prototype-sort"><a href="#Array-prototype-sort" class="headerlink" title="Array.prototype.sort()"></a>Array.prototype.sort()</h2><p>The <code>sort()</code> method sorts the elements of an array <a href="https://en.wikipedia.org/wiki/In-place_algorithm" target="_blank" rel="noopener">in place</a> and returns the array. The default sort order is built upon converting the elements into strings, then comparing their sequences of UTF-16 code units values.</p>
<p>The time and space complexity of the sort cannot be guaranteed as it is implementation dependent.</p>
<p><code>sort()</code> 方法用<a href="https://zh.wikipedia.org/wiki/原地算法" target="_blank" rel="noopener">原地算法</a>对数组的元素进行排序，并返回数组。排序算法现在是稳定的。默认排序顺序是根据字符串Unicode码点。</p>
<p>由于它取决于具体实现，因此无法保证排序的时间和空间复杂性。</p>
<p><code>sort(compareFunction)</code></p>
<ul>
<li>如果没有指明 compareFunction，那么元素会按照转换为的字符串的诸个字符的Unicode位点进行排序。</li>
<li>如果指明了 compareFunction，那么数组会按照调用该函数的返回值排序。即 a 和 b 是两个将要被比较的元素：<ul>
<li>如果 compareFunction(a, b) 小于 0，那么 a 会被排列到 b 之前</li>
<li>如果 compareFunction(a, b) 等于 0， a 和 b 的相对位置不变（CMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守,例如 Mozilla 在 2003 年之前的版本）</li>
<li>如果 compareFunction(a, b) 大于 0，那么 b 会被排列到 a 之前</li>
<li>compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的（利用这一特性，可实现随机排序）</li>
</ul>
</li>
</ul>
<p><code>compareFunction</code> 可能需要对元素做多次映射以实现排序，尤其当 <code>compareFunction</code> 较为复杂，且元素较多的时候，某些 <code>compareFunction</code> 可能会导致很高的负载。使用 <code>map</code> 辅助排序将会是一个好主意。基本思想是首先将数组中的每个元素比较的实际值取出来，排序后再将数组恢复。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>].sort() <span class="comment">// [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">11</span>].sort() <span class="comment">// [11, 2, 3] 这里说明如果没有指明 compareFunction，那么元素会按照转换为的字符串的诸个字符的Unicode位点进行排序。['3', '2', '11'].sort()。'11' &lt; '2' &lt; '3'</span></span><br><span class="line"></span><br><span class="line">[<span class="number">3</span>, <span class="number">2</span>, <span class="number">11</span>].sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> a - b</span><br><span class="line">&#125;) <span class="comment">// [2, 3, 11]</span></span><br><span class="line"></span><br><span class="line">[<span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'a'</span>].sort()</span><br></pre></td></tr></table></figure>

<p><code>sort()</code> 方法如何实现排序？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">arr.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(arr, a, b)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> a - b</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** 控制台输出</span></span><br><span class="line"><span class="comment">  [3, 1, 2] 1 3</span></span><br><span class="line"><span class="comment">  [3, 1, 2] 2 1</span></span><br><span class="line"><span class="comment">  [1, 3, 2] 2 3</span></span><br><span class="line"><span class="comment">  [1, 3, 2] 2 1</span></span><br><span class="line"><span class="comment">  [1, 2, 3]</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>a 相当于 next，b 相当于 prev。</p>
<p>第一次，数组 [3, 1, 2]，初始数组。1 和 3 比较，1 - 3 &lt; 0，1 要排列到 3 之前，需要调整。</p>
<p>第二次，数组 [3, 1, 2]，数组没变。2 和 1 比较，2 - 1 &gt; 0，1 要排列到 2 之前，不需要调整。</p>
<p>第三次，数组 [1, 3, 2]，数组变了，说明在上一轮比较结束后调整了位置。3 和 1 不用比较，直接跳过。2 和 3 比较，3 - 2 &gt; 0，2 要排列到 3 之前，需要调整。</p>
<p>第四次，数组 [1, 3, 2]，数组没变。2 和 1 比较，2 - 1 &gt; 0，1 要排列到 2 之前，不需要调整。</p>
<p>比较结束，数组 [1, 2, 3]。</p>
<p><code>sort()</code> 好像是冒泡和插入两种方式结合进行排序的！</p>
<h2 id="十大经典排序算法"><a href="#十大经典排序算法" class="headerlink" title="十大经典排序算法"></a>十大经典排序算法</h2><p><a href="https://github.com/hustcc/JS-Sorting-Algorithm" target="_blank" rel="noopener">https://github.com/hustcc/JS-Sorting-Algorithm</a></p>
<p><a href="https://github.com/Wscats/CV/issues/13" target="_blank" rel="noopener">https://github.com/Wscats/CV/issues/13</a></p>
<p><a href="http://bubkoo.com/tags/algorithm/" target="_blank" rel="noopener">http://bubkoo.com/tags/algorithm/</a></p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><p>算法步骤：</p>
<ol>
<li><p>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</p>
</li>
<li><p>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</p>
</li>
<li><p>针对所有的元素重复以上的步骤，除了最后一个。</p>
</li>
<li><p>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bubbleSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = arr.length</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i ++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = <span class="number">0</span>; j &lt; len - <span class="number">1</span> - i; j ++) &#123;</span><br><span class="line">      <span class="comment">// 内循环，相邻元素，两两对比</span></span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123;</span><br><span class="line">        <span class="comment">// 元素交换，左小右大</span></span><br><span class="line">        <span class="keyword">const</span> temp = arr[j]</span><br><span class="line">        arr[j] = arr[j + <span class="number">1</span>]</span><br><span class="line">        arr[j + <span class="number">1</span>] = temp</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：冒泡排序，可以看成三个规则的组合：</p>
<ol>
<li>外层 for 循环</li>
<li>内层 for 循环</li>
<li>最内层的 swap</li>
</ol>
<p>时间复杂度为：O(n) * O(n) * O(1) = O(n^2)</p>
<p>最快：当输入的数据已经是正序时(都已经是正序了，我还要你冒泡排序有何用啊)。</p>
<p>最慢：当输入的数据是反序时(写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗)。</p>
<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>算法步骤：</p>
<ol>
<li><p>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</p>
</li>
<li><p>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</p>
</li>
<li><p>重复第二步，直到所有元素均排序完毕。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">selectionSort</span>(<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = arr.length</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; i ++) &#123;</span><br><span class="line">    <span class="keyword">let</span> minIndex = i <span class="comment">// 最小数的索引，每次初始化为 i</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> j = i + <span class="number">1</span>; j &lt; len; j ++) &#123;</span><br><span class="line">      <span class="comment">// 内循环，寻找最小数</span></span><br><span class="line">      <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;</span><br><span class="line">        <span class="comment">// 将最小数的索引保存</span></span><br><span class="line">        minIndex = j</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 元素交换，修正本轮寻找到的最小数</span></span><br><span class="line">    <span class="keyword">const</span> temp = arr[i]</span><br><span class="line">    arr[i] = arr[minIndex]</span><br><span class="line">    arr[minIndex] = temp</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析：选择排序，可以看成两个规则的组合：</p>
<ol>
<li>外层 for 循环</li>
<li>内层 for 循环</li>
</ol>
<p>每次挑选出最小的数，不停往前堆放</p>
<p>时间复杂度为：O(n) * O(n) = O(n^2)</p>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><p>算法步骤：</p>
<ol>
<li><p>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</p>
</li>
<li><p>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insertionSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = arr.length</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> prevIndex, current</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 将第一(0)个数看做一个有序序列，把第二(1)个元素到最后一个元素当成是未排序序列</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; len; i ++) &#123;</span><br><span class="line">    prevIndex = i - <span class="number">1</span> <span class="comment">// 有序序列的最后一个数的索引</span></span><br><span class="line">    current = arr[i] <span class="comment">// 未排序序列的第一个元素</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 用未排序序列的第一个元素，与有序序列比较，从右到左</span></span><br><span class="line">    <span class="keyword">while</span> (prevIndex &gt;= <span class="number">0</span> &amp;&amp; arr[prevIndex] &gt; current) &#123;</span><br><span class="line">      <span class="comment">// 向右移位，留出待插入的位置</span></span><br><span class="line">      arr[preIndex + <span class="number">1</span>] = arr[prevIndex]</span><br><span class="line"></span><br><span class="line">      prevIndex --</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到最终待插入的位置，插入元素</span></span><br><span class="line">    arr[preIndex + <span class="number">1</span>] = current</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为：O(n) * O(n) = O(n^2)</p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><p>也称递减增量排序算法，是插入排序的一种更高效的改进版本。</p>
<p>算法步骤：</p>
<ol>
<li><p>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</p>
</li>
<li><p>按增量序列个数 k，对序列进行 k 趟排序；</p>
</li>
<li><p>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">shellSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = arr.length</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> gap = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (gap &lt; len / <span class="number">3</span>) &#123;</span><br><span class="line">    <span class="comment">// 动态定义间隔序列</span></span><br><span class="line">    gap = gap * <span class="number">3</span> + <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (gap; gap &gt; <span class="number">0</span>; gap = <span class="built_in">Math</span>.floor(gap / <span class="number">3</span>)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">      <span class="keyword">const</span> temp = arr[i]</span><br><span class="line"></span><br><span class="line">      <span class="keyword">let</span> j = i - gap</span><br><span class="line"></span><br><span class="line">      <span class="keyword">for</span>(j; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; temp; j -= gap) &#123;</span><br><span class="line">        arr[j + gap] = arr[j]</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      arr[j + gap] = temp</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>采用分治法(Divide and conquer)</p>
<p>分而治之。</p>
<p>两种方法：</p>
<ul>
<li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li>
<li>自下而上的迭代；</li>
</ul>
<p>算法步骤：</p>
<ol>
<li><p>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</p>
</li>
<li><p>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</p>
</li>
<li><p>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</p>
</li>
<li><p>重复步骤 3 直到某一指针达到序列尾；</p>
</li>
<li><p>将另一序列剩下的所有元素直接复制到合并序列尾。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">merge</span> (<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (left.length &amp;&amp; right.length) &#123;</span><br><span class="line">    <span class="keyword">if</span> (left[<span class="number">0</span>] &lt;= right[<span class="number">0</span>]) &#123;</span><br><span class="line">      result.push(left.shift())</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      result.push(right.shift())</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (left.length)</span><br><span class="line">    result.push(left.shift())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (right.length)</span><br><span class="line">    result.push(right.shift())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mergeSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 采用自上而下的递归方法</span></span><br><span class="line">  <span class="keyword">const</span> len = arr.length</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (len &lt; <span class="number">2</span>) <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> middle = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> left = arr.slice(<span class="number">0</span>, middle)</span><br><span class="line">  <span class="keyword">const</span> right = arr.slice(middle)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> merge(mergeSort(left), mergeSort(right))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度为：O(nlogn)</p>
<p><a href="https://mp.weixin.qq.com/s/nXnvirzfMEtBuKkU1vXu3w" target="_blank" rel="noopener">从分治算法到 MapReduce</a></p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>使用分治法(Divide and conquer)策略来把一个串行(list)分为两个子串行(sub-lists)。</p>
<p>分而治之。</p>
<p>本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p>
<p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(nlogn) 的排序算法表现要更好。</p>
<p>算法步骤：</p>
<ol>
<li><p>从数列中挑出一个元素，称为 “基准”(pivot);</p>
</li>
<li><p>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面(相同的数可以到任一边)。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区(partition)操作；</p>
</li>
<li><p>递归地(recursive)把小于基准值元素的子数列和大于基准值元素的子数列排序；</p>
<p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代(iteration)中，它至少会把一个元素摆到它最后的位置去。</p>
</li>
</ol>
<h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span> (<span class="params">arr, i, j</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> temp = arr[i]</span><br><span class="line">  arr[i] = arr[j]</span><br><span class="line">  arr[j] = temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">partition</span> (<span class="params">arr, left ,right</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 分区操作</span></span><br><span class="line">  <span class="comment">// 设定基准值(pivot)</span></span><br><span class="line">  <span class="keyword">const</span> pivot = left</span><br><span class="line">  <span class="keyword">let</span> index = pivot + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = index; i &lt;= right; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">      swap(arr, i, index)</span><br><span class="line"></span><br><span class="line">      index ++;</span><br><span class="line">    &#125;        </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  swap(arr, pivot, index - <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> index - <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">quickSort</span> (<span class="params">arr, left, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> len = arr.length</span><br><span class="line"></span><br><span class="line">  left = <span class="keyword">typeof</span> left != <span class="string">'number'</span> ? <span class="number">0</span> : left,</span><br><span class="line">  right = <span class="keyword">typeof</span> right != <span class="string">'number'</span> ? len - <span class="number">1</span> : right</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">    <span class="keyword">const</span> partitionIndex = partition(arr, left, right)</span><br><span class="line"></span><br><span class="line">    quickSort(arr, left, partitionIndex - <span class="number">1</span>)</span><br><span class="line">    quickSort(arr, partitionIndex + <span class="number">1</span>, right)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>[left, right) 代表区间，从 left 到 right 之间进行排序！</p>
<h3 id="堆排序-没搞懂"><a href="#堆排序-没搞懂" class="headerlink" title="堆排序 {没搞懂}"></a>堆排序 {没搞懂}</h3><p>利用堆这种数据结构所设计的一种排序算法。</p>
<p>堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。</p>
<p>堆排序可以说是一种利用堆的概念来排序的选择排序。</p>
<p>分为两种方法：</p>
<ul>
<li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</li>
<li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</li>
</ul>
<p>堆排序的平均时间复杂度为 Ο(nlogn)。</p>
<p>算法步骤：</p>
<ol>
<li><p>创建一个堆 H[0……n-1]；</p>
</li>
<li><p>把堆首（最大值）和堆尾互换；</p>
</li>
<li><p>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</p>
</li>
<li><p>重复步骤 2，直到堆的尺寸为 1。</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> len <span class="comment">// 因为声明的多个函数都需要数据长度，所以把 len 设置成为全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span> (<span class="params">arr, i, j</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> temp = arr[i]</span><br><span class="line">  arr[i] = arr[j]</span><br><span class="line">  arr[j] = temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapify</span> (<span class="params">arr, i</span>) </span>&#123; <span class="comment">// 堆调整</span></span><br><span class="line">  <span class="keyword">var</span> left = <span class="number">2</span> * i + <span class="number">1</span>,</span><br><span class="line">    right = <span class="number">2</span> * i + <span class="number">2</span>,</span><br><span class="line">    largest = i</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123;</span><br><span class="line">    largest = left</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123;</span><br><span class="line">    largest = right</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (largest != i) &#123;</span><br><span class="line">    swap(arr, i, largest)</span><br><span class="line">    heapify(arr, largest)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildMaxHeap</span> (<span class="params">arr</span>) </span>&#123; <span class="comment">// 建立大顶堆</span></span><br><span class="line">  len = arr.length;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="built_in">Math</span>.floor(len / <span class="number">2</span>); i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">    heapify(arr, i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">heapSort</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  buildMaxHeap(arr)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = arr.length - <span class="number">1</span>; i &gt; <span class="number">0</span>; i --) &#123;</span><br><span class="line">    swap(arr, <span class="number">0</span>, i);</span><br><span class="line"></span><br><span class="line">    len --;</span><br><span class="line"></span><br><span class="line">    heapify(arr, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="计数排序-没搞懂"><a href="#计数排序-没搞懂" class="headerlink" title="计数排序 {没搞懂}"></a>计数排序 {没搞懂}</h3><p>核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p>
<p>必须知道最大值。。。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countingSort</span> (<span class="params">arr, maxValue</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> bucket = <span class="keyword">new</span> <span class="built_in">Array</span>(maxValue + <span class="number">1</span>),</span><br><span class="line">    sortedIndex = <span class="number">0</span>,</span><br><span class="line">    arrLen = arr.length,</span><br><span class="line">    bucketLen = maxValue + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; arrLen; i ++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!bucket[arr[i]]) &#123;</span><br><span class="line">      bucket[arr[i]] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    bucket[arr[i]] ++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; bucketLen; j ++) &#123;</span><br><span class="line">    <span class="keyword">while</span> (bucket[j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      arr[sortedIndex++] = j;</span><br><span class="line"></span><br><span class="line">      bucket[j] --;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="桶排序-没搞懂"><a href="#桶排序-没搞懂" class="headerlink" title="桶排序 {没搞懂}"></a>桶排序 {没搞懂}</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p>
<p>为了使桶排序更加高效，我们需要做到这两点：</p>
<ol>
<li><p>在额外空间充足的情况下，尽量增大桶的数量</p>
</li>
<li><p>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</p>
</li>
</ol>
<p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p>
<p>最快：当输入的数据可以均匀的分配到每一个桶中。</p>
<p>最慢：当输入的数据被分配到了同一个桶中。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bucketSort</span> (<span class="params">arr, bucketSize</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (arr.length === <span class="number">0</span>) <span class="keyword">return</span> arr</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> i</span><br><span class="line">  <span class="keyword">var</span> minValue = arr[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">var</span> maxValue = arr[<span class="number">0</span>]</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; arr.length; i ++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; minValue) &#123;</span><br><span class="line">      minValue = arr[i] <span class="comment">// 输入数据的最小值</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; maxValue) &#123;</span><br><span class="line">      maxValue = arr[i] <span class="comment">// 输入数据的最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 桶的初始化</span></span><br><span class="line">  <span class="keyword">var</span> DEFAULT_BUCKET_SIZE = <span class="number">5</span> <span class="comment">// 设置桶的默认数量为 5</span></span><br><span class="line">  bucketSize = bucketSize || DEFAULT_BUCKET_SIZE</span><br><span class="line">  <span class="keyword">var</span> bucketCount = <span class="built_in">Math</span>.floor((maxValue - minValue) / bucketSize) + <span class="number">1</span></span><br><span class="line">  <span class="keyword">var</span> buckets = <span class="keyword">new</span> <span class="built_in">Array</span>(bucketCount)</span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; buckets.length; i ++) &#123;</span><br><span class="line">    buckets[i] = []</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 利用映射函数将数据分配到各个桶中</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; arr.length; i ++) &#123;</span><br><span class="line">    buckets[<span class="built_in">Math</span>.floor((arr[i] - minValue) / bucketSize)].push(arr[i])</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  arr.length = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; buckets.length; i ++) &#123;</span><br><span class="line">    insertionSort(buckets[i]) <span class="comment">// 对每个桶进行排序，这里使用了插入排序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; buckets[i].length; j++) &#123;</span><br><span class="line">      arr.push(buckets[i][j])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基数排序-没搞懂"><a href="#基数排序-没搞懂" class="headerlink" title="基数排序 {没搞懂}"></a>基数排序 {没搞懂}</h3><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LSD Radix Sort</span></span><br><span class="line"><span class="keyword">var</span> counter = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">radixSort</span> (<span class="params">arr, maxDigit</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> mod = <span class="number">10</span></span><br><span class="line">  <span class="keyword">var</span> dev = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; maxDigit; i ++, dev *= <span class="number">10</span>, mod *= <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; arr.length; j ++) &#123;</span><br><span class="line">      <span class="keyword">var</span> bucket = <span class="built_in">parseInt</span>((arr[j] % mod) / dev)</span><br><span class="line">      <span class="keyword">if</span> (counter[bucket] == <span class="literal">null</span>) &#123;</span><br><span class="line">        counter[bucket] = []</span><br><span class="line">      &#125;</span><br><span class="line">      counter[bucket].push(arr[j])</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> pos = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; counter.length; j ++) &#123;</span><br><span class="line">      <span class="keyword">var</span> value = <span class="literal">null</span></span><br><span class="line">      <span class="keyword">if</span> (counter[j] != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> ((value = counter[j].shift()) != <span class="literal">null</span>) &#123;</span><br><span class="line">          arr[pos ++] = value</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="基数排序-vs-计数排序-vs-桶排序"><a href="#基数排序-vs-计数排序-vs-桶排序" class="headerlink" title="基数排序 vs 计数排序 vs 桶排序"></a>基数排序 vs 计数排序 vs 桶排序</h3><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p>
<ul>
<li>基数排序：根据键值的每位数字来分配桶；</li>
<li>计数排序：每个桶只存储单一键值；</li>
<li>桶排序：每个桶存储一定范围的数值；</li>
</ul>
<h2 id="时间换空间以及空间换时间"><a href="#时间换空间以及空间换时间" class="headerlink" title="时间换空间以及空间换时间"></a>时间换空间以及空间换时间</h2><p>两个数字进行交换</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 时优 运用空间而减少了时间的使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> temp = a</span><br><span class="line">	a = b</span><br><span class="line">	b = temp</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 空优 运用时间而减少了空间的使用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">	a = a + b</span><br><span class="line">	b = a - b</span><br><span class="line">	a = a - b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>数组去重，也是一个典型的用空间换时间的例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line">	<span class="keyword">var</span> result = []</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i <span class="keyword">in</span> arr) &#123;</span><br><span class="line">		<span class="keyword">if</span>(!obj[arr[i]]) &#123;</span><br><span class="line">			obj[arr[i]] = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">			result.push(arr[i])</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> result</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>未完</p>
<h1 id="判断一个单词是否是回文？"><a href="#判断一个单词是否是回文？" class="headerlink" title="判断一个单词是否是回文？"></a>判断一个单词是否是回文？</h1><p>回文是指把相同的词汇或句子，在下文中调换位置或颠倒过来，产生首尾回环的情趣，叫回文，也叫回环。比如 <code>mamam</code> <code>redivider</code>。</p>
<p>其实考的是，如何将字符串逆向排序，反转/颠倒？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isPalindrome</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> str === reverse(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="利用数组-reverse-方法"><a href="#利用数组-reverse-方法" class="headerlink" title="利用数组 reverse 方法"></a>利用数组 <code>reverse</code> 方法</h2><p>字符串转数组 -&gt; 数组 <code>reverse</code> -&gt; 数组转字符串</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'开始'</span>, +<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> reverseStr = [...str].reverse().join(<span class="string">''</span>) <span class="comment">// str.split('').reverse().join('')</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'结束'</span>, +<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> reverseStr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="利用数组-reduceRight-方法"><a href="#利用数组-reduceRight-方法" class="headerlink" title="利用数组 reduceRight 方法"></a>利用数组 <code>reduceRight</code> 方法</h2><p>字符串转数组 -&gt; 数组 <code>reduceRight</code></p>
<p>数组 <code>reduce(function(accumulator, currentValue, currentIndex, array), initValue)</code> 、<code>reduceRight(function(accumulator, currentValue, currentIndex, array), initValue)</code> 接收 2 个参数。对于空数组是不会执行回调函数的。</p>
<p><code>function(accumulator, currentValue, currentIndex, array)</code> 是必须。数组遍历执行的回调函数。</p>
<p><code>initValue</code> 是可选。传递给函数的初始值。如果有这个参数，那么第一个 <code>accumulator</code> 等于 <code>initialValue</code>，并且 <code>currentValue</code> 等于数组中的第一个值；如果没有这个参数，那么第一个 <code>accumulator</code> 等于数组中的第一个值，并且 <code>currentValue</code> 等于数组中的第二个值。如果是是数组累加器，不要写 <code>initValue</code> 为 <code>0</code>，这样可以减少一次遍历，<code>0</code> 的累加也没有意义。</p>
<p><code>reduce</code> 是顺序，<code>reduceRight</code> 是逆序。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'开始'</span>, +<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> reverseStr = [...str].reduceRight(<span class="function">(<span class="params">prev, curr</span>) =&gt;</span> prev + curr)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'结束'</span>, +<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> reverseStr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="利用-for-循环"><a href="#利用-for-循环" class="headerlink" title="利用 for 循环"></a>利用 <code>for</code> 循环</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'开始'</span>, +<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> reverseStr = <span class="string">''</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = str.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i --) &#123;</span><br><span class="line">    reverseStr += str[i]</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'结束'</span>, +<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> reverseStr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="利用字符串-slice-加递归"><a href="#利用字符串-slice-加递归" class="headerlink" title="利用字符串 slice 加递归"></a>利用字符串 <code>slice</code> 加递归</h2><p>复杂且耗时</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">reverse</span> (<span class="params">str</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'开始'</span>, +<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> reverseStr = str &amp;&amp; (reverse(str.slice(<span class="number">1</span>)) + str[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'结束'</span>, +<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> reverseStr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h1><h2 id="利用-Set"><a href="#利用-Set" class="headerlink" title="利用 Set"></a>利用 <code>Set</code></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'开始'</span>, +<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> uniqueArr = [...new <span class="built_in">Set</span>(arr)]</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'结束'</span>, +<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> uniqueArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="利用-Object-的-key-唯一性"><a href="#利用-Object-的-key-唯一性" class="headerlink" title="利用 Object 的 key 唯一性"></a>利用 <code>Object</code> 的 <code>key</code> 唯一性</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'开始'</span>, +<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">const</span> uniqueArr = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj[key]) &#123;</span><br><span class="line">      obj[key] = <span class="literal">true</span></span><br><span class="line">      uniqueArr.push(key)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'结束'</span>, +<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> uniqueArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'开始'</span>, +<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj[key]) obj[key] = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">const</span> uniqueArr = <span class="built_in">Object</span>.keys(obj)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'结束'</span>, +<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> uniqueArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="利用数组的-indexOf"><a href="#利用数组的-indexOf" class="headerlink" title="利用数组的 indexOf"></a>利用数组的 <code>indexOf</code></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">unique</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'开始'</span>, +<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> uniqueArr = []</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (uniqueArr.indexOf(key) === <span class="number">-1</span>) uniqueArr.push(key)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'结束'</span>, +<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> uniqueArr</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="统计一个字符串出现最多的字母"><a href="#统计一个字符串出现最多的字母" class="headerlink" title="统计一个字符串出现最多的字母"></a>统计一个字符串出现最多的字母</h1><p>这里需要统计重复次数，并求最大值。类似的求最小值。</p>
<h2 id="利用-Object-的-key-唯一性-1"><a href="#利用-Object-的-key-唯一性-1" class="headerlink" title="利用 Object 的 key 唯一性"></a>利用 <code>Object</code> 的 <code>key</code> 唯一性</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">findMaxDuplicateChar</span> (<span class="params">arr</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'开始'</span>, +<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> arr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!obj[key]) &#123;</span><br><span class="line">      obj[key] = <span class="number">1</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      obj[key] ++</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">let</span> maxChar = <span class="string">''</span>, maxValue = <span class="number">1</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="keyword">const</span> value = obj[key]</span><br><span class="line">    <span class="keyword">if</span> (value &gt; maxValue) &#123;</span><br><span class="line">      maxChar = key</span><br><span class="line">      maxValue = value</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'结束'</span>, +<span class="keyword">new</span> <span class="built_in">Date</span>())</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> maxChar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="不借助临时变量，进行两个整数的交换"><a href="#不借助临时变量，进行两个整数的交换" class="headerlink" title="不借助临时变量，进行两个整数的交换"></a>不借助临时变量，进行两个整数的交换</h1><p>这种问题非常巧妙，需要大家跳出惯有的思维，利用 a , b进行置换。</p>
<p>主要是利用 + - 去进行运算，类似 a = a + (b - a) 实际上等同于最后的 a = b</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">swap</span> (<span class="params">a, b</span>) </span>&#123;  </span><br><span class="line">  a = a + b</span><br><span class="line">	b = a - b</span><br><span class="line">	a = a - b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="未完"><a href="#未完" class="headerlink" title="未完"></a>未完</h1>]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript数据类型</title>
    <url>/zh/2018/08/14/JavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>JavaScript 中七种数据类型(内置类型)，分为两大类型：基本类型和对象(object)可分为两大类，即原始类型和引用类型。</p>
<p>六种原始类型：null，undefined，boolean，number，string，symbol</p>
<p>一种引用类型：对象(object)。这里的 object 是广泛上的一切对像，即一切引用类型。</p>
<a id="more"></a>

<h1 id="JavaScript-变量"><a href="#JavaScript-变量" class="headerlink" title="JavaScript 变量"></a>JavaScript 变量</h1><p>JavaScript 中变量、函数名、运算符以及其他一切东西都是区分大小写的。</p>
<p>变量是弱类型的。</p>
<p>变量名需要遵守两条简单的规则：</p>
<ul>
<li>第一个字符必须是字母、下划线(<code>_</code>)或美元符号(<code>$</code>)</li>
<li>余下的字符可以是下划线、美元符号或任何字母或数字字符</li>
</ul>
<p>著名的变量命名规则：</p>
<ul>
<li>Camel 标记法，首字母是小写的，接下来的字母都以大写字符开头：var myTestValue = 0</li>
<li>Pascal 标记法，首字母是大写的，接下来的字母都以大写字符开头：var MyTestValue = 0</li>
<li>匈牙利类型标记法，在以 Pascal 标记法命名的变量前附加一个小写字母(或小写字母序列)，说明该变量的类型：var iMyTestValue = 0</li>
</ul>
<h1 id="JavaScript-数据类型"><a href="#JavaScript-数据类型" class="headerlink" title="JavaScript 数据类型"></a>JavaScript 数据类型</h1><ul>
<li>JavaScript 数据类型(内置类型)<ul>
<li>原始类型(primitive type, 基本类型)<ul>
<li>null</li>
<li>undefined</li>
<li>boolean</li>
<li>number<ul>
<li>NaN</li>
</ul>
</li>
<li>string</li>
<li>symbol</li>
</ul>
</li>
<li>引用类型，类(class)，对象<ul>
<li>本地对象(native object)<ul>
<li>Object</li>
<li>Array</li>
<li>Boolean</li>
<li>Number</li>
<li>String</li>
<li>Function</li>
<li>Date</li>
<li>RegExp</li>
<li>Error<ul>
<li>EvalError</li>
<li>RangeError</li>
<li>ReferenceError</li>
<li>SyntaxError</li>
<li>TypeError</li>
<li>URIError</li>
</ul>
</li>
</ul>
</li>
<li>内置对象(built-in object)<ul>
<li>Global 对象</li>
<li>Math 对象</li>
</ul>
</li>
<li>宿主对象(host objec)<ul>
<li>BOM</li>
<li>DOM</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><p>js 的数字类型是浮点类型的，没有整型。并且浮点类型基于 <code>IEEE 754</code> 双精度标准(64位)实现，在使用中会遇到某些 Bug。</p>
<h3 id="最大数、最小数、正负无穷"><a href="#最大数、最小数、正负无穷" class="headerlink" title="最大数、最小数、正负无穷"></a>最大数、最小数、正负无穷</h3><p>js 中可表示的最大的数为 <code>Number.MAX_VALUE</code>，近似值为 <code>1.7976931348623157e+308</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MAX_VALUE <span class="comment">// 1.7976931348623157e+308</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.MAX_VALUE + <span class="number">1</span> <span class="comment">// 1.7976931348623157e+308</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.MAX_VALUE === <span class="built_in">Number</span>.MAX_VALUE + <span class="number">1</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>js 中可表示的最大的数为 <code>Number.MIN_VALUE</code>，接近 0，但不是负数，近似值为 <code>5e-324</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MIN_VALUE <span class="comment">// 5e-324</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.MIN_VALUE === <span class="number">1</span> - <span class="built_in">Number</span>.MIN_VALUE <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>正无穷 <code>Infinity</code>，负无穷 <code>-Infinity</code>。溢出时返回。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MAX_VALUE * (<span class="number">1</span> + <span class="built_in">Number</span>.MIN_VALUE) === <span class="built_in">Number</span>.MAX_VALUE <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.MAX_VALUE * <span class="number">1.1</span> <span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.MAX_VALUE * <span class="number">-1.1</span> <span class="comment">// -Infinity</span></span><br></pre></td></tr></table></figure>

<h3 id="最大安全整数、最小安全整数"><a href="#最大安全整数、最小安全整数" class="headerlink" title="最大安全整数、最小安全整数"></a>最大安全整数、最小安全整数</h3><p>js 最大安全整数是 <code>Number.MAX_SAFE_INTEGER</code>，最小安全整数是 <code>Number.MIN_SAFE_INTEGER</code>，</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER <span class="comment">// 9007199254740991</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER <span class="comment">// -9007199254740991</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER === <span class="number">1</span> - <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="2-的-53-次方"><a href="#2-的-53-次方" class="headerlink" title="2 的 53 次方"></a>2 的 53 次方</h3><p>js 安全整数的范围是 (Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER) 即 -2^53~2^53 (不包含边界) 。</p>
<p>安全整数，意思是说能够 one-by-one 表示的整数，也就是说在(-2^53, 2^53)范围内，双精度数表示和整数是一对一的，反过来说，在这个范围以内，所有的整数都有唯一的浮点数表示，这叫做安全整数。超过这个范围，会有两个或更多整数的双精度表示是相同的；反过来说，超过这个范围，有的整数是无法精确表示的，只能round到与它相近的浮点数(说到底就是科学计数法)表示，这种情况下叫做不安全整数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) <span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span> <span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">2</span> <span class="comment">// 9007199254740994</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">3</span> <span class="comment">// 9007199254740996</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">4</span> <span class="comment">// 9007199254740996</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.pow(<span class="number">2</span>,<span class="number">53</span>)+ <span class="number">5</span> <span class="comment">// 9007199254740996</span></span><br></pre></td></tr></table></figure>

<p>当运算数与运算结果都处于安全整数的范围内时，才能保证 js 运算结果正确。</p>
<p>请求接口中返回一个整数，例如订单号，是个不安全整数，就会导致前端处理异常！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">201808221019001777</span> <span class="comment">// 被处理成 201808221019001800</span></span><br></pre></td></tr></table></figure>

<p>js 安全整数的范围为啥是 (Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER) 即 -2^53~2^53 (不包含边界) ？</p>
<p>js 里数字类型只有一种，Number 类型，是双精度浮点型，都是 64-bit (1bit 的符号位，11bits 的指数部分，以及 52bits 的小数部分) 的双精度浮点数(double)！</p>
<p>js 里的整型 int 是 双精度浮点型 double 的一个子集，而不是一个独立的数据类型。</p>
<p>由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心！引申问题<a href="https://u3xyz.com/detail/28" target="_blank" rel="noopener">0.1 + 0.2 为什么不等于 0.3</a>。</p>
<p><a href="https://en.wikipedia.org/wiki/IEEE_754" target="_blank" rel="noopener">IEEE 754 双精度浮点数</a>。</p>
<p><a href="https://www.zhihu.com/question/29010688" target="_blank" rel="noopener">参考1</a></p>
<p><a href="http://2ality.com/2013/10/safe-integers.html" target="_blank" rel="noopener">参考3</a></p>
<p><a href="http://steve.hollasch.net/cgindex/coding/ieeefloat.html" target="_blank" rel="noopener">参考2</a></p>
<h3 id="0-1-0-2-为什么不等于-0-3"><a href="#0-1-0-2-为什么不等于-0-3" class="headerlink" title="0.1 + 0.2 为什么不等于 0.3"></a><a href="https://yuchengkai.cn/docs/zh/frontend/#%E4%B8%BA%E4%BB%80%E4%B9%88-0-1-0-2-0-3" target="_blank" rel="noopener">0.1 + 0.2 为什么不等于 0.3</a></h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> != <span class="number">0.3</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseFloat</span>((<span class="number">0.1</span> + <span class="number">0.2</span>).toFixed(<span class="number">10</span>)) === <span class="number">0.3</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><code>toFixed(num)</code> 可把 <code>Number</code> 四舍五入为指定小数位数的数字。有效数字姑且看作最多有 10 位小数。<code>num</code> 是小数位数，规定是 <code>0-20</code>，有些实现可以支持更大的数值范围，例如 <code>chrome</code> 可以是 <code>0-100</code>。</p>
<h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><p><code>NaN</code> 也属于 <code>number</code> 类型，并且 <code>NaN</code> 不等于自身。<code>NaN</code> 是除对象外，唯一一个不等于自身的值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span> <span class="comment">// 'number'</span></span><br><span class="line"></span><br><span class="line">!<span class="literal">NaN</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">NaN</span> != <span class="literal">NaN</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<ul>
<li>一个表达式中如果有减号 <code>-</code>、乘号 <code>*</code> 或 除号 <code>/</code> 等运算符时，js 引擎会在计算之前试图将运算符两边的变量转化为 number 类型，如果转化失败，表达式将返回 NaN。</li>
<li>直接使用 Number, parseInt 或 parseFloat 将一个非数字的值转化为数字时，表达式返回 NaN。</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'abc'</span> - <span class="number">1</span> <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="string">'abc'</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="string">'abc'</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="string">'abc'</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>如何判断 <code>NaN</code>？必须是 <code>Number.isNaN()</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isNaN</span>(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">'abc'</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="string">'abc'</span> - <span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">isNaN</span>(<span class="literal">true</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'abc'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'abc'</span> - <span class="number">1</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">true</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>我们注意看 <code>isNaN(&#39;abc&#39;)</code> 返回 <code>true</code>，而 <code>Number.isNaN(&#39;abc&#39;)</code> 返回 <code>false</code>。显然 <code>Number.isNaN</code> 更符合我们的要求。</p>
<p><code>isNaN()</code> 函数用于检查其参数是否是非数字值。如果参数值为 NaN 或字符串、对象、undefined 等非数字值，则返回 true, 否则返回 false。会先强制转化为数字形式。也就是说：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">isNaN(param) -&gt; isNaN(Number(param))</span><br></pre></td></tr></table></figure>

<p><code>Number.isNaN()</code> 和全局函数 <code>isNaN()</code> 相比，该方法不会强制将参数转换成数字，只有在参数是真正的数字类型，且值为 NaN 的时候才会返回 true。</p>
<p>Polyfill</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isNaN = <span class="built_in">Number</span>.isNaN || <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">"number"</span> &amp;&amp; <span class="built_in">isNaN</span>(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在数字计算或转化中，true 就是 1，false 就是 0。</p>
<p><code>NaN</code> 为啥不等于自身？<code>NaN</code> 即 Not a Number , 不是一个数字。我们可以看到 ‘abc’ - 1 的结果是 NaN，’abc’ + 1 的结果也是 NaN，显然 ‘abc’ - 1 不等于 ‘abc’ + 1。NaN 可以代表一切 Not a Number 的数。</p>
<h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>NaN 不等于任何一个变量，包括它自己！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">0</span> == <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> == <span class="literal">true</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>在数字计算中，true 就是 1，false 就是 0。</p>
<h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">true</span> - <span class="number">1</span> <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="literal">true</span>) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">parseInt</span>(<span class="literal">true</span>) <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">parseFloat</span>(<span class="literal">true</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>

<p>在数字计算中，true 就是 1，false 就是 0。</p>
<p>parseInt 和 parseFloat 接受参数是 string 类型，非 string 类型的需要先转化为 string 类型。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">parseInt(<span class="literal">true</span>) -&gt; parseInt(String(<span class="literal">true</span>)) -&gt; parseInt(<span class="string">'true'</span>) -&gt; NaN</span><br></pre></td></tr></table></figure>

<h2 id="null"><a href="#null" class="headerlink" title="null"></a>null</h2><p>null 可以等于 null 或者 undefined。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>null 是变量值为 null，undefined 是变量本身 undefined。</p>
<p>null 和 undefined 都表示“值的空缺”，你可以认为 undefined 是表示系统级的、出乎意料的或类似错误的值的空缺，而 null 是表示程序级的、正常的或在意料之中的值的空缺。</p>
<p>undefined 是访问一个未初始化的变量时返回的值，而 null是访问一个尚未存在的对象时所返回的值。因此，可以把 undefined 看作是空的变量，而 null 看作是空的对象。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foo现在已经是知存在的，但是它没有类型或者是值：</span></span><br><span class="line"><span class="keyword">var</span> foo = <span class="literal">null</span>;</span><br><span class="line">foo;</span><br><span class="line"><span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// foo不存在，它从来没有被定义过或者是初始化过：</span></span><br><span class="line">foo;</span><br><span class="line"><span class="comment">// "ReferenceError: foo is not defined"</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// 'object'</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<h1 id="Typeof"><a href="#Typeof" class="headerlink" title="Typeof"></a>Typeof</h1><p><code>typeof</code> 对于基本类型，除了 <code>null</code> 都可以显示正确的类型！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">undefined</span> <span class="comment">// 'undefined'</span></span><br><span class="line"><span class="keyword">typeof</span> bbbbbb <span class="comment">// bbbbbb 没有声明，但是还会显示 undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">true</span> <span class="comment">// 'boolean'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="number">1</span> <span class="comment">// 'number'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">NaN</span> <span class="comment">// 'number'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="string">'1'</span> <span class="comment">// 'string'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Symbol</span>() <span class="comment">// 'symbol'</span></span><br></pre></td></tr></table></figure>

<p><code>typeof</code> 对于对象，除了函数都会显示 <code>object</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> [] <span class="comment">// 'object'</span></span><br><span class="line"><span class="keyword">typeof</span> &#123;&#125; <span class="comment">// 'object'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Array</span> <span class="comment">// 'function'</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="built_in">Object</span> <span class="comment">// 'function'</span></span><br><span class="line"><span class="keyword">typeof</span> setTimeout <span class="comment">// 'function'</span></span><br></pre></td></tr></table></figure>

<p>对于 <code>null</code> 来说，虽然它是基本类型，但是会显示 <code>object</code>，这是一个存在很久了的 Bug。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> <span class="comment">// 'object'</span></span><br></pre></td></tr></table></figure>

<p>PS：为什么会出现这种情况呢？因为在 js 的最初版本中，使用的是 32 位系统，为了性能考虑使用低位存储了变量的类型信息，<code>000</code> 开头代表是对象，然而 <code>null</code> 表示为全零，所以将它错误的判断为 <code>object</code>。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。</p>
<p>如何判断 <code>null</code> ？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span> === <span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h1 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h1><p><code>instanceof</code> 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 <code>prototype</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">b <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br><span class="line">c <span class="keyword">instanceof</span> <span class="built_in">Function</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>试着实现一下 <code>instanceof</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_instanceof</span> (<span class="params">left, right</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 获得类型的原型</span></span><br><span class="line">  <span class="keyword">let</span> prototype = right.prototype</span><br><span class="line">  <span class="comment">// 获得对象的原型</span></span><br><span class="line">  left = left.__proto__</span><br><span class="line">  <span class="comment">// 判断对象的类型是否等于类型的原型</span></span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  	<span class="keyword">if</span> (left === <span class="literal">null</span>)</span><br><span class="line">  		<span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">  	<span class="keyword">if</span> (prototype === left)</span><br><span class="line">  		<span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">  	left = left.__proto__</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">_instanceof(a, <span class="built_in">Object</span>)</span><br><span class="line"></span><br><span class="line">_instanceof(b, <span class="built_in">Array</span>)</span><br><span class="line"></span><br><span class="line">_instanceof(c, <span class="built_in">Function</span>)</span><br></pre></td></tr></table></figure>

<h1 id="Object-prototype-toString-call-value"><a href="#Object-prototype-toString-call-value" class="headerlink" title="Object.prototype.toString.call(value)"></a>Object.prototype.toString.call(value)</h1><p>想获得一个变量的正确类型，可以通过 <code>Object.prototype.toString.call(value)</code>，可以获得类似 [Object Type] 的字符串。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> d = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">E</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> e = <span class="keyword">new</span> E()</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(a) <span class="comment">// [object Object]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(b) <span class="comment">// [object Array]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(c) <span class="comment">// [object Function]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(d) <span class="comment">// [object Date]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(e) <span class="comment">// [object Object]</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">null</span>) <span class="comment">// [object Null]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">undefined</span>) <span class="comment">// [object Undefined]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">true</span>) <span class="comment">// [object Boolean]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">1</span>) <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="literal">NaN</span>) <span class="comment">// [object Number]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="string">'a'</span>) <span class="comment">// [object String]</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="built_in">Symbol</span>()) <span class="comment">// [object Symbol]</span></span><br></pre></td></tr></table></figure>

<p>Polyfill</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isNaN = <span class="built_in">Number</span>.isNaN || <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> value === <span class="string">"number"</span> &amp;&amp; <span class="built_in">isNaN</span>(value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="变量的值"><a href="#变量的值" class="headerlink" title="变量的值"></a>变量的值</h1><p>变量可以存在两种类型的值，即原始值和引用值。</p>
<p>原始类型的值，就是原始值。</p>
<p>引用类型的值，就是引用值。</p>
<p>原始值，存储在栈(stack)中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。栈区包括了变量的标识符和变量的值。</p>
<p>引用值，存储在堆(heap)中的对象，也就是说，存储在变量处的值是一个指针(point)，指向存储对象的内存处。</p>
<h2 id="原始类型"><a href="#原始类型" class="headerlink" title="原始类型"></a>原始类型</h2><p>原始值，存储在栈(stack)中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。栈区包括了变量的标识符和变量的值。</p>
<h3 id="按值传递-call-by-value"><a href="#按值传递-call-by-value" class="headerlink" title="按值传递(call by value)"></a>按值传递(call by value)</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a, b <span class="comment">// undefined, undefined</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">0</span> <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">b = a <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">a = <span class="string">'1'</span> <span class="comment">// '1'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a, b, <span class="keyword">typeof</span> a, <span class="keyword">typeof</span> b) <span class="comment">// '1' 0 string number</span></span><br></pre></td></tr></table></figure>

<p>上面 a 的改变没有改变 b，说明原始类型是按值传递的。赋值时创建了一块新的内存空间。</p>
<p>按值传递是最常用的求值策略，传递的是值的拷贝，也就是说传递后就互不相关了。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params">param</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// b 是形参</span></span><br><span class="line">  param += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(num, param) <span class="comment">// 0, 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(num) <span class="comment">// a 是实参</span></span><br></pre></td></tr></table></figure>

<p>函数的形参是被调用时所传实参的副本。修改形参的值并不会影响实参。</p>
<h3 id="不可变-immutable-性质"><a href="#不可变-immutable-性质" class="headerlink" title="不可变(immutable)性质"></a>不可变(immutable)性质</h3><p>基本类型，其值是不可修改的，也不能为其添加属性和方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'abc'</span></span><br><span class="line">str[<span class="number">0</span>] <span class="comment">// 'a'</span></span><br><span class="line">str[<span class="number">0</span>] = <span class="string">'d'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str[<span class="number">0</span>], str) <span class="comment">// 'a', 'abc'</span></span><br><span class="line"></span><br><span class="line">str.age = <span class="number">24</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.age, str) <span class="comment">// undefined, 'abc</span></span><br><span class="line"></span><br><span class="line">str.method = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(str.method, str) <span class="comment">// undefined, 'abc</span></span><br></pre></td></tr></table></figure>

<h2 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h2><p>引用值，存储在堆(heap)中的对象，也就是说，存储在变量处的值是一个指针(point)，指向存储对象的内存处。</p>
<p>引用类型的存储空间将从堆(heap)中分配。由于引用值的大小会改变，所以不能把它放在栈(stack)中，否则会降低变量查寻的速度。</p>
<p>相反，放在变量的栈(stack)空间中的值是该对象存储在堆(heap)中的地址。</p>
<p>地址的大小是固定的，所以把它存储在栈(stack)中对变量性能无任何负面影响。</p>
<h3 id="对象的属性"><a href="#对象的属性" class="headerlink" title="对象的属性"></a>对象的属性</h3><p><code>constructor</code>，对创建对象的函数的引用(指针)，指回原构造函数。对于 object 对象，该指针指向原始的 Object() 函数。</p>
<p><code>__proto__</code>，隐式原型，是每个对象都有的一个属性。一个对象的隐式原型指向构造该对象的构造函数的原型，这也保证了实例能够访问在构造函数原型中定义的属性和方法。</p>
<p><code>prototype</code>，原型属性，是 Function 函数对象(除了内置函数对象)才具有的属性，是通过调用构造函数而创建的那个对象实例的原型对象，是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法(我们把这个对象叫做原型对象)。在原型对象里有共有的方法，所有构造函数声明的实例都可以共享这个方法。</p>
<p><img src="https://cmspic-10004025.image.myqcloud.com/3c3eae80-a4ef-11e8-9774-f1d87802945e_size_520x586" alt="__proto__ 与 prototype"></p>
<p>每个函数都有 <code>prototype</code> 属性，除了 <code>Function.prototype.bind()</code>，该属性指向原型。</p>
<p>每个对象都有 <code>__proto__</code> 属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 <code>[[prototype]]</code>，但是 <code>[[prototype]]</code> 是内部属性，我们并不能访问到，所以使用 <code>_proto_</code> 来访问。</p>
<p>对象可以通过 <code>__proto__</code> 来寻找不属于该对象的属性，<code>__proto__</code> 将对象连接起来组成了原型链。</p>
<p>如果你想更进一步的了解原型，可以仔细阅读<a href="https://github.com/KieSun/Blog/issues/2" target="_blank" rel="noopener">深度解析原型中的各个难点</a>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line">func.constructor <span class="comment">// ƒ Function() &#123; [native code] &#125; Function 构造函数</span></span><br><span class="line">func.constructor === <span class="built_in">Function</span> <span class="comment">// true</span></span><br><span class="line">obj.constructor <span class="comment">// ƒ Object() &#123; [native code] &#125; Object 构造函数</span></span><br><span class="line">obj.constructor === <span class="built_in">Object</span></span><br><span class="line"></span><br><span class="line">func.__proto__ <span class="comment">// ƒ () &#123; [native code] &#125; Function 构造函数的原型</span></span><br><span class="line">obj.__proto__ <span class="comment">// &#123; constructor: f Object(), ... &#125; Object 构造函数的原型</span></span><br><span class="line"></span><br><span class="line">func.prototype <span class="comment">// &#123; constructor: func (), ... &#125;</span></span><br><span class="line"></span><br><span class="line">func.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line">obj.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">func.__proto__.__proto__ === obj.__proto__ <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.constructor <span class="comment">// ƒ Function() &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">Object</span>.constructor <span class="comment">// ƒ Function() &#123; [native code] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.__proto__ <span class="comment">// ƒ () &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">Object</span>.__proto__ <span class="comment">// ƒ () &#123; [native code] &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype <span class="comment">// ƒ () &#123; [native code] &#125;</span></span><br><span class="line"><span class="built_in">Object</span>.prototype <span class="comment">// &#123; constructor: f Object(), ... &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span>.prototype === <span class="built_in">Object</span>.__proto__ <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Object</span>.__proto__ <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.__proto__.__proto__ === <span class="built_in">Object</span>.__proto__.__proto__ <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Function</span>.__proto__.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>函数不是对象吗？为什么 func 和 obj 的 constructor 和 <code>_proto_</code> 不一样？</p>
<p>func 是函数对象，是特殊的对象，<code>func._proto_</code> 指向了构造该函数对象的构造函数的原型！构造该函数对象的构造函数是 func.constructor，即 Function，其原型是 <code>Function.prototype</code>！所以 <code>func.__proto__ === func.constructor.prototype === Function.prototype</code> 成立！</p>
<p>obj 是一般对象，<code>obj._proto_</code> 指向了构造该函数对象的构造函数的原型！构造该函数对象的构造函数是 obj.constructor，即 Object，其原型是 <code>Object.prototype</code>！所以 <code>obj.__proto__ === obj.constructor.prototype === Object.prototype</code> 成立！</p>
<ul>
<li><code>Object</code> 是所有对象的爸爸，所有对象都可以通过 <code>__proto__</code> 找到它</li>
<li><code>Function</code> 是所有函数的爸爸，所有函数都可以通过 <code>__proto__</code> 找到它</li>
<li><code>Function.prototype</code> 和 <code>Object.prototype</code> 是两个特殊的对象，他们由引擎来创建</li>
<li>除了以上两个特殊对象，其他对象都是通过构造器 new 出来的</li>
<li>函数的 <code>prototype</code> 是一个对象，也就是原型</li>
<li>对象的 <code>__proto__</code> 指向原型， <code>__proto__</code> 将对象和原型连接起来组成了原型链</li>
</ul>
<p>一脸懵逼！！！！！</p>
<p>调用对象的 <code>Object.getPrototypeOf()</code> 方法读取 <code>[[Prototype]]</code> 属性的值，代替 <code>__proto__</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(func) === func.__proto__ <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(obj) === obj.__proto__ <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h3 id="对象的方法"><a href="#对象的方法" class="headerlink" title="对象的方法"></a>对象的方法</h3><h4 id="hasOwnProperty-property-判断指定属性是否为自有属性。"><a href="#hasOwnProperty-property-判断指定属性是否为自有属性。" class="headerlink" title="hasOwnProperty(property) 判断指定属性是否为自有属性。"></a>hasOwnProperty(property) 判断指定属性是否为自有属性。</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.hasOwnProperty(<span class="string">'a'</span>) <span class="comment">// true，a 是自有属性</span></span><br><span class="line">obj.hasOwnProperty(<span class="string">'toString'</span>) <span class="comment">// false，toString 不是自有属性，是原型属性</span></span><br><span class="line"></span><br><span class="line"><span class="string">'a'</span> <span class="keyword">in</span> obj <span class="comment">// true</span></span><br><span class="line"><span class="string">'toString'</span> <span class="keyword">in</span> obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasPrototypeProperty</span> (<span class="params">obj, property</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !obj.hasOwnProperty(property) &amp;&amp; property <span class="keyword">in</span> obj</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="isPrototypeOf-object-判断该对象是否为另一个对象的原型。"><a href="#isPrototypeOf-object-判断该对象是否为另一个对象的原型。" class="headerlink" title="isPrototypeOf(object) 判断该对象是否为另一个对象的原型。"></a>isPrototypeOf(object) 判断该对象是否为另一个对象的原型。</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  a: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.isPrototypeOf(obj) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">obj.__proto__.isPrototypeOf(obj) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.isPrototypeOf(obj) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.__proto__.isPrototypeOf(obj)  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.isPrototypeOf(obj) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h1 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h1><p>对象、类、实例</p>
<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>ECMA-262 把对象(object)定义为“属性的无序集合，每个属性存放一个原始值、对象或函数”。严格来说，这意味着对象是无特定顺序的值的数组。</p>
<p>对象是无特定顺序的值的数组，这就是为什么 <code>for...in</code> 不能保证顺序的原因吧。</p>
<p>尽管 ECMAScript 如此定义对象，但它更通用的定义是基于代码的名词(人、地点或事物)的表示。</p>
<p>对象由特性(attribute)构成，特性可以是原始值，也可以是引用值。如果特性存放的是函数，它将被看作对象的方法(method)，否则该特性被看作对象的属性(property)。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p>每个对象都由类定义，可以把类看做对象的配方。</p>
<p>类不仅要定义对象的接口(interface)(开发者访问的属性和方法)，还要定义对象的内部工作(使属性和方法发挥作用的代码)。编译器和解释程序都根据类的说明构建对象。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>程序使用类创建对象时，生成的对象叫作类的实例(instance)。</p>
<p>对类生成的对象的个数的唯一限制来自于运行代码的机器的物理内存。每个实例的行为相同，但实例处理一组独立的数据。</p>
<p>由类创建对象实例的过程叫做实例化(instantiation)。</p>
<h2 id="四种基本能力"><a href="#四种基本能力" class="headerlink" title="四种基本能力"></a>四种基本能力</h2><ul>
<li>封装 - 把相关的信息(无论数据或方法)存储在对象中的能力</li>
<li>聚集 - 把一个对象存储在另一个对象内的能力</li>
<li>继承 - 由另一个类(或多个类)得来类的属性和方法的能力</li>
<li>多态 - 编写能以多种方法运行的函数或方法的能力</li>
</ul>
<h2 id="对象作用域"><a href="#对象作用域" class="headerlink" title="对象作用域"></a>对象作用域</h2><p>作用域指的是变量的适用范围。</p>
<h3 id="公用、私有和受保护作用域"><a href="#公用、私有和受保护作用域" class="headerlink" title="公用、私有和受保护作用域"></a>公用、私有和受保护作用域</h3><p>在传统的面向对象程序设计中，主要关注于公用和私有作用域。公用作用域中的对象属性可以从对象外部访问，即开发者创建对象的实例后，就可使用它的公用属性。而私有作用域中的属性只能在对象内部访问，即对于外部世界来说，这些属性并不存在。这意味着如果类定义了私有属性和方法，则它的子类也不能访问这些属性和方法。</p>
<p>受保护作用域也是用于定义私有的属性和方法，只是这些属性和方法还能被其子类访问。</p>
<h4 id="ECMAScript-只有公用作用域"><a href="#ECMAScript-只有公用作用域" class="headerlink" title="ECMAScript 只有公用作用域"></a>ECMAScript 只有公用作用域</h4><p>对 ECMAScript 讨论上面这些作用域几乎毫无意义，因为 ECMAScript 中只存在一种作用域 - 公用作用域。ECMAScript 中的所有对象的所有属性和方法都是公用的。因此，定义自己的类和对象时，必须格外小心。记住，所有属性和方法默认都是公用的！</p>
<p>由于缺少私有作用域，开发者确定了一个规约，说明哪些属性和方法应该被看做私有的。这种规约规定在属性前后加下划线：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">obj._color_ = <span class="string">'blue'</span> <span class="comment">// 属性 color 被看作是私有的。注意，下划线并不改变属性是公用属性的事实，只是作为提示</span></span><br></pre></td></tr></table></figure>

<h3 id="静态作用域"><a href="#静态作用域" class="headerlink" title="静态作用域"></a>静态作用域</h3><p>静态作用域定义的属性和方法任何时候都能从同一位置访问。</p>
<p>在 Java 中，类可具有属性和方法，无需实例化该类的对象，即可访问这些属性和方法，例如 java.net.URLEncoder 类，它的函数 encode() 就是静态方法。</p>
<h4 id="ECMAScript-没有静态作用域"><a href="#ECMAScript-没有静态作用域" class="headerlink" title="ECMAScript 没有静态作用域"></a>ECMAScript 没有静态作用域</h4><p>严格来说，ECMAScript 并没有静态作用域。不过，它可以给构造函数提供属性和方法。</p>
<p>构造函数只是函数。函数是对象，对象可以有属性和方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHello</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hello'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHello.alternate = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hi'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sayHello() <span class="comment">// 'hello'</span></span><br><span class="line"></span><br><span class="line">sayHello.alternate() <span class="comment">// 'hi'</span></span><br></pre></td></tr></table></figure>

<p>方法 alternate() 实际上是函数 sayHello 的方法。可以像调用常规函数一样调用 sayHello() 输出 “hello”，也可以调用 sayHello.alternate() 输出 “hi”。即使如此，alternate() 也是 sayHello() 公用作用域中的方法，而不是静态方法。</p>
<h3 id="关键字-this，指向调用该方法的对象"><a href="#关键字-this，指向调用该方法的对象" class="headerlink" title="关键字 this，指向调用该方法的对象"></a>关键字 this，指向调用该方法的对象</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> oCar = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">oCar.color = <span class="string">'red'</span></span><br><span class="line">oCar.showColor = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.color, <span class="keyword">this</span>) <span class="comment">// this 指向调用该方法的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">oCar.showColor() <span class="comment">// 'red'</span></span><br></pre></td></tr></table></figure>

<p>为什么要使用 this ？在实例化对象时，总是不能确定开发者会使用什么样的变量名。使用 this，即可在任何多个地方重用同一个函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showColor</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.color, <span class="keyword">this</span>) <span class="comment">// this 指向调用该方法的对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oCar = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">oCar.color = <span class="string">'red'</span></span><br><span class="line">oCar.showColor = showColor</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oBike = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line">oBike.color = <span class="string">'blue'</span></span><br><span class="line">oBike.showColor = showColor</span><br><span class="line"></span><br><span class="line">oCar.showColor() <span class="comment">// 'red'</span></span><br><span class="line"></span><br><span class="line">oBike.showColor() <span class="comment">// 'blue'</span></span><br></pre></td></tr></table></figure>

<h4 id="注意，引用对象的属性时，必须使用-this-关键字"><a href="#注意，引用对象的属性时，必须使用-this-关键字" class="headerlink" title="注意，引用对象的属性时，必须使用 this 关键字"></a>注意，引用对象的属性时，必须使用 this 关键字</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showColor</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(color)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果不用对象或 this 关键字引用变量，ECMAScript 就会把它看作局部变量或全局变量。然后该函数将查找名为 color 的局部或全局变量。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">'red'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showColor</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> color = <span class="string">'blue'</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(color) <span class="comment">// 局部查找，发现 color</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showColor() <span class="comment">// 'blue'</span></span><br><span class="line"><span class="built_in">console</span>.log(color) <span class="comment">// 'red'</span></span><br></pre></td></tr></table></figure>

<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">'red'</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showColor</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  color = <span class="string">'blue'</span> <span class="comment">// 这里 color 被调用进行赋值运算，但是局部查找没有，在全局查找到了</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(color)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showColor() <span class="comment">// 'blue'</span></span><br><span class="line"><span class="built_in">console</span>.log(color) <span class="comment">// 'blue'</span></span><br></pre></td></tr></table></figure>

<h2 id="定义类或对象"><a href="#定义类或对象" class="headerlink" title="定义类或对象"></a>定义类或对象</h2><ul>
<li>工厂方式，原始的方式</li>
<li>构造函数方式</li>
<li>原型方式</li>
<li>混合的构造函数/原型方式</li>
<li>动态原型方法</li>
<li>混合工厂方式</li>
</ul>
<h3 id="工厂方式，原始的方式"><a href="#工厂方式，原始的方式" class="headerlink" title="工厂方式，原始的方式"></a>工厂方式，原始的方式</h3><p>能创建并返回特定类型的对象的工厂函数(factory function)。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showColor</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createCar</span> (<span class="params">sColor, iDoors, iMpg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oTempCar = <span class="keyword">new</span> object;</span><br><span class="line">  oTempCar.color = sColor;</span><br><span class="line">  oTempCar.doors = iDoors;</span><br><span class="line">  oTempCar.mpg = iMpg;</span><br><span class="line">  oTempCar.showColor = showColor; <span class="comment">// 从功能上讲，这样解决了重复创建函数对象的问题；但是从语义上讲，该函数不太像是对象的方法</span></span><br><span class="line">  <span class="keyword">return</span> oTempCar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oCar1 = createCar(<span class="string">"red"</span>, <span class="number">4</span>, <span class="number">23</span>);</span><br><span class="line"><span class="keyword">var</span> oCar2 = createCar(<span class="string">"blue"</span>, <span class="number">3</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">oCar1.showColor();		<span class="comment">//输出 "red"</span></span><br><span class="line">oCar2.showColor();		<span class="comment">//输出 "blue"</span></span><br></pre></td></tr></table></figure>

<h3 id="构造函数方式"><a href="#构造函数方式" class="headerlink" title="构造函数方式"></a>构造函数方式</h3><p>第一步选择类名，即构造函数的名字。根据惯例，这个名字的首字母大写，以使它与首字母通常是小写的变量名分开。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showColor</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span> (<span class="params">sColor, iDoors, iMpg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.color = sColor;</span><br><span class="line">  <span class="keyword">this</span>.doors = iDoors;</span><br><span class="line">  <span class="keyword">this</span>.mpg = iMpg;</span><br><span class="line">  <span class="keyword">this</span>.showColor = showColor; <span class="comment">// 从功能上讲，这样解决了重复创建函数对象的问题；但是从语义上讲，该函数不太像是对象的方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oCar1 = <span class="keyword">new</span> Car(<span class="string">"red"</span>, <span class="number">4</span>, <span class="number">23</span>);</span><br><span class="line"><span class="keyword">var</span> oCar2 = <span class="keyword">new</span> Car(<span class="string">"blue"</span>, <span class="number">3</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">oCar1.showColor();		<span class="comment">//输出 "red"</span></span><br><span class="line">oCar2.showColor();		<span class="comment">//输出 "blue"</span></span><br></pre></td></tr></table></figure>

<p>首先在构造函数内没有创建对象，而是使用 this 关键字。使用 new 运算符构造函数时，在执行第一行代码前先创建一个对象，只有用 this 才能访问该对象。然后可以直接赋予 this 属性，默认情况下是构造函数的返回值(不必明确使用 return 运算符)。</p>
<h3 id="原型方式"><a href="#原型方式" class="headerlink" title="原型方式"></a>原型方式</h3><p>该方式利用了函数对象的 prototype 属性，可以把它看成创建新对象所依赖的原型。</p>
<p>这里，首先用空构造函数来设置类名。然后所有的属性和方法都被直接赋予 prototype 属性。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span> (<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Car.prototype.color = <span class="string">"blue"</span>;</span><br><span class="line">Car.prototype.doors = <span class="number">4</span>;</span><br><span class="line">Car.prototype.mpg = <span class="number">25</span>;</span><br><span class="line">Car.prototype.showColor = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;; <span class="comment">// 从语义上讲，该函数确实是对象的方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oCar1 = <span class="keyword">new</span> Car();</span><br><span class="line"><span class="keyword">var</span> oCar2 = <span class="keyword">new</span> Car();</span><br><span class="line"></span><br><span class="line">oCar1.showColor();		<span class="comment">//输出 "red"</span></span><br><span class="line">oCar2.showColor();		<span class="comment">//输出 "blue"</span></span><br></pre></td></tr></table></figure>

<p>首先定义构造函数(Car)，其中无任何代码。接下来的几行代码，通过给 Car 的 prototype 属性添加属性去定义 Car 对象的属性。调用 new Car() 时，原型的所有属性都被立即赋予要创建的对象，意味着所有 Car 实例存放的都是指向 showColor() 函数的指针。从语义上讲，所有属性看起来都属于一个对象，因此解决了前面两种方式存在的问题。</p>
<p>此外，使用这种方式，还能用 instanceof 运算符检查给定变量指向的对象的类型。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">oCar1 <span class="keyword">instanceof</span> Car <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>但是，使用原型方式，不能通过给构造函数传递参数来初始化属性的值！</p>
<p>因为 Car1 和 Car2 的 color 属性都等于 “blue”，doors 属性都等于 4，mpg 属性都等于 25。这意味着必须在对象创建后才能改变属性的默认值，这点很令人讨厌，但还没完。真正的问题出现在属性指向的是对象，而不是函数时。函数共享不会造成问题，但对象却很少被多个实例共享。</p>
<h3 id="混合的构造函数-原型方式"><a href="#混合的构造函数-原型方式" class="headerlink" title="混合的构造函数/原型方式"></a>混合的构造函数/原型方式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showColor</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="keyword">this</span>.color);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span> (<span class="params">sColor, iDoors, iMpg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.color = sColor;</span><br><span class="line">  <span class="keyword">this</span>.doors = iDoors;</span><br><span class="line">  <span class="keyword">this</span>.mpg = iMpg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Car.prototype.showColor = showColor</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> oCar1 = <span class="keyword">new</span> Car(<span class="string">"red"</span>, <span class="number">4</span>, <span class="number">23</span>);</span><br><span class="line"><span class="keyword">var</span> oCar2 = <span class="keyword">new</span> Car(<span class="string">"blue"</span>, <span class="number">3</span>, <span class="number">25</span>);</span><br><span class="line"></span><br><span class="line">oCar1.showColor();		<span class="comment">//输出 "red"</span></span><br><span class="line">oCar2.showColor();		<span class="comment">//输出 "blue"</span></span><br></pre></td></tr></table></figure>

<p>所有的非函数属性都在构造函数中创建，意味着又能够用构造函数的参数赋予属性默认值了。因为只创建 showColor() 函数的一个实例，所以没有内存浪费。因为使用了原型方式，所以仍然能利用 instanceof 运算符来判断对象的类型。</p>
<p>这种方式是 ECMAScript 采用的主要方式，最常用！它具有其他方式的特性，却没有他们的副作用。但还是不够完美。</p>
<h3 id="动态原型方法"><a href="#动态原型方法" class="headerlink" title="动态原型方法"></a>动态原型方法</h3><p>动态原型方法的基本想法与混合的构造函数/原型方式相同，即在构造函数内定义非函数属性，而函数属性则利用原型属性定义。唯一的区别是赋予对象方法的位置。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span>(<span class="params">sColor, iDoors, iMpg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.color = sColor</span><br><span class="line">  <span class="keyword">this</span>.doors = iDoors</span><br><span class="line">  <span class="keyword">this</span>.mpg = iMpg</span><br><span class="line">  <span class="keyword">this</span>.drivers = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">'Mike'</span>, <span class="string">'John'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> Car._initialized == <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    Car.prototype.showColor = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="keyword">this</span>.color)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Car._initialized = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>直到检查 <code>typeof Car._initialized</code> 是否等于 <code>&quot;undefined&quot;</code> 之前，这个构造函数都未发生变化。这行代码是动态原型方法中最重要的部分。如果这个值未定义，构造函数将用原型方式继续定义对象的方法，然后把 <code>Car._initialized</code> 设置为 <code>true</code>。如果这个值定义了(它的值为 <code>true</code> 时，<code>typeof</code> 的值为 <code>Boolean</code>)，那么就不再创建该方法。简而言之，该方法使用标志(<code>_initialized</code>)来判断是否已给原型赋予了任何方法。该方法只创建并赋值一次，传统的 <code>OOP</code> 开发者会高兴地发现，这段代码看起来更像其他语言中的类定义了。</p>
<h3 id="混合工厂方式"><a href="#混合工厂方式" class="headerlink" title="混合工厂方式"></a>混合工厂方式</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> oTempCar = <span class="keyword">new</span> <span class="built_in">Object</span></span><br><span class="line">  oTempCar.color = <span class="string">'blue'</span></span><br><span class="line">  oTempCar.doors = <span class="number">4</span></span><br><span class="line">  oTempCar.mpg = <span class="number">25</span></span><br><span class="line">  oTempCar.showColor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.color)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> oTempCar</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>与经典方式不同，这种方式使用 <code>new</code> 运算符，使它看起来像真正的构造函数。</p>
<p>由于在 <code>Car()</code> 构造函数内部调用了 <code>new</code> 运算符，所以将忽略第二个 <code>new</code> 运算符(位于构造函数之外)，在构造函数内部创建的对象被传递回变量 <code>car</code>。</p>
<p>这种方式在对象方法的内部管理方面与经典方式有着相同的问题。强烈建议：除非万不得已，还是避免使用这种方式。</p>
<h2 id="修改对象"><a href="#修改对象" class="headerlink" title="修改对象"></a>修改对象</h2><p>通过使用 ECMAScript，不仅可以创建对象，还可以修改已有对象的行为。</p>
<p>prototype 属性不仅可以定义构造函数的属性和方法，还可以为本地对象添加属性和方法。</p>
<h3 id="创建新方法"><a href="#创建新方法" class="headerlink" title="创建新方法"></a>创建新方法</h3><p>把数字对象直接转换为十六进制字符串：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Number</span>.prototype.toHexString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.toString(<span class="number">16</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> iNum = <span class="number">15</span></span><br><span class="line"><span class="built_in">console</span>.log(iNum.toHexString()) <span class="comment">// f</span></span><br></pre></td></tr></table></figure>

<h3 id="重命名已有方法"><a href="#重命名已有方法" class="headerlink" title="重命名已有方法"></a>重命名已有方法</h3><p>可以给 Array 类添加两个方法 enqueue() 和 dequeue()，只让它们反复调用已有的 push() 和 shift() 方法即可：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.enqueue = <span class="function"><span class="keyword">function</span> (<span class="params">vItem</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.push(vItem)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.prototype.dequeue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.shift()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Function 的 toString() 方法通常输出的是函数的源代码。覆盖该方法，可以返回另一个字符串(在这个例子中，可以返回 “Function code hidden”)。不过，toString() 指向的原始函数怎么了呢？它将被无用存储单元回收程序回收，因为它被完全废弃了。没有能够恢复原始函数的方法，所以在覆盖原始方法前，比较安全的做法是存储它的指针，以便以后的使用。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Function</span>.prototype.originalToString = <span class="built_in">Function</span>.prototype.toString</span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.originalToString().length &gt; <span class="number">100</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'Function too long to display.'</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.originalToString()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="极晚绑定-Very-Late-Binding"><a href="#极晚绑定-Very-Late-Binding" class="headerlink" title="极晚绑定(Very Late Binding)"></a>极晚绑定(Very Late Binding)</h3><p>从技术上讲，根本不存在极晚绑定。本书采用该术语描述 ECMAScript 中的一种现象，即能够在对象实例化后再定义它的方法。例如：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hi'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.sayHi()</span><br></pre></td></tr></table></figure>

<p>在大多数程序设计语言中，必须在实例化对象之前定义对象的方法。这里，方法 sayHi() 是在创建 Object 类的一个实例之后来添加进来的。在传统语言中不仅没听说过这种操作，也没听说过该方法还会自动赋予 Object 对象的实例并能立即使用（接下来的一行）。</p>
<p>注意：不建议使用极晚绑定方法，因为很难对其跟踪和记录。不过，还是应该了解这种可能。</p>
<h2 id="ES6-之-class"><a href="#ES6-之-class" class="headerlink" title="ES6 之 class"></a>ES6 之 class</h2><p>ES6 提供了更接近传统语言的写法，引入了 <code>Class（类）</code>这个概念，作为对象的模板。通过 <code>class</code> 关键字，可以定义类。</p>
<p>基本上，ES6 的 <code>class</code> 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 <code>class</code> 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x</span><br><span class="line">  <span class="keyword">this</span>.y = y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (x, y) &#123;</span><br><span class="line">    <span class="keyword">this</span>.x = x</span><br><span class="line">    <span class="keyword">this</span>.y = y</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'('</span> + <span class="keyword">this</span>.x + <span class="string">', '</span> + <span class="keyword">this</span>.y + <span class="string">')'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码定义了一个“类”，可以看到里面有一个 <code>constructor</code> 方法，这就是构造方法，而 <code>this</code> 关键字则代表实例对象。也就是说，ES5 的构造函数 <code>Point</code>，对应 ES6 的 <code>Point</code> 类的构造方法。</p>
<p><code>Point</code> 类除了构造方法，还定义了一个 <code>toString</code> 方法。注意，定义“类”的方法的时候，前面不需要加上 <code>function</code> 这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。</p>
<p>ES6 的类，完全可以看作构造函数的另一种写法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> Point <span class="comment">// "function"</span></span><br><span class="line">Point === Point.prototype.constructor <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码表明，类的数据类型就是函数，类本身就指向构造函数。</p>
<p>使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。</p>
<p>构造函数的 <code>prototype</code> 属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的 <code>prototype</code> 属性上面。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString () &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  valueOf () &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line">Point.prototype = &#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;&#125;,</span><br><span class="line">  toString () &#123;&#125;,</span><br><span class="line">  valueOf () &#123;&#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在类的实例上面调用方法，其实就是调用原型上的方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> B();</span><br><span class="line"></span><br><span class="line">b.constructor === B.prototype.constructor <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，b 是 B 类的实例，它的 constructor 方法就是 B 类原型的 constructor 方法。</p>
<p>由于类的方法都定义在 prototype 对象上面，所以类的新方法可以添加在 prototype 对象上面。<code>Object.assign</code> 方法可以很方便地一次向类添加多个方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>()&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.assign(Point.prototype, &#123;</span><br><span class="line">  toString () &#123;&#125;,</span><br><span class="line">  valueOf () &#123;&#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p><code>prototype</code> 对象的 <code>constructor</code> 属性，直接指向“类”的本身，这与 ES5 的行为是一致的。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">Point.prototype.constructor === Point <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> (x, y) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  toString () &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(Point.prototype) <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Point.prototype) <span class="comment">// ["constructor", "toString"]</span></span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>toString</code> 方法是 <code>Point</code> 类内部定义的方法，它是不可枚举的。<code>这一点与 ES5 的行为不一致。</code></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Point = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Point.prototype.toString = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(Point.prototype) <span class="comment">// ["toString"]</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(Point.prototype) <span class="comment">// ["constructor", "toString"]</span></span><br></pre></td></tr></table></figure>

<p>class 的简介大致就这些，想学习更多 class 的知识，敬请期待后面对 class 的深入探究。</p>
<p>迫不及待想学习，可以阅读 <a href="http://es6.ruanyifeng.com/#docs/class" target="_blank" rel="noopener">ES6 之 Class 的基本语法</a></p>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><h2 id="转-Boolean"><a href="#转-Boolean" class="headerlink" title="转 Boolean"></a>转 Boolean</h2><p>在条件判断时，除了 <code>undefined</code>， <code>null</code>， <code>false</code>， <code>NaN</code>， <code>&#39;&#39;</code>， <code>0</code>，<code>-0</code>，其他所有值都转为 <code>true</code>，包括所有对象，甚至是 <code>[]</code>、<code>{}</code>。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">false</span>, <span class="literal">NaN</span>, <span class="string">''</span>, <span class="number">0</span>, <span class="number">-0</span>, [], &#123;&#125;]</span><br><span class="line"></span><br><span class="line">arr.forEach(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (item) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="literal">true</span>)</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="literal">false</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;item&#125;</span>转Boolean为<span class="subst">$&#123;!!item&#125;</span>`</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>转 Boolean，有 <code>!! + 变量</code> 或 <code>Boolean(变量)</code></p>
<p>条件判断有：<code>if</code>，<code>三目运算</code>，<code>for</code>，<code>while</code>，<code>do...while</code>、<code>switch</code> 等。</p>
<h2 id="对象转基本类型"><a href="#对象转基本类型" class="headerlink" title="对象转基本类型"></a>对象转基本类型</h2><p>对象在转换基本类型时，有 <code>toString</code>，<code>valueOf</code>，<code>Symbol.toPrimitive</code>。默认调用 <code>toString</code>。三个方法都可以重写，而且越后面优先级越大。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line">obj.toString() <span class="comment">// '[object Object]'</span></span><br><span class="line">obj.valueOf() <span class="comment">// &#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> + obj <span class="comment">// '1[object Object]'</span></span><br><span class="line"></span><br><span class="line"><span class="string">'a'</span> + obj <span class="comment">// 'a[object Object]'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  toString () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'a'</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> + obj <span class="comment">// ‘1a’</span></span><br><span class="line"><span class="string">'a'</span> + obj <span class="comment">// 'aa'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  valueOf () &#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> + obj <span class="comment">// 2</span></span><br><span class="line"><span class="string">'a'</span> + obj <span class="comment">// 'a1'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  toString () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'a'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  valueOf () &#123;</span><br><span class="line">  	<span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> + obj <span class="comment">// 2</span></span><br><span class="line"><span class="string">'a'</span> + obj <span class="comment">// 'a1'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  toString () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'a'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  valueOf () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive] () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> + obj <span class="comment">// 3</span></span><br><span class="line"><span class="string">'a'</span> + obj <span class="comment">// 'a2'</span></span><br></pre></td></tr></table></figure>

<p>转字符串，有 <code>&#39;&#39; + 变量</code> 或 <code>String(变量)</code></p>
<p>转数字，有 <code>+ 变量</code> 或 <code>Number(变量)</code></p>
<h2 id="四则运算符"><a href="#四则运算符" class="headerlink" title="四则运算符"></a>四则运算符</h2><p>只有当加法运算时，其中一方是字符串类型，就会把另一个也转为字符串类型。并且加法运算会触发三种类型转换：将值转换为原始值，转换为数字，转换为字符串。</p>
<p>其他运算只要其中一方是数字，那么另一方就转为数字。</p>
<p>加法运算的结果不一定是数字。其他运算的结果一定是数字。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">'1'</span> <span class="comment">// '11'</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span> * <span class="string">'2'</span> <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>] + [<span class="number">2</span>, <span class="number">1</span>] <span class="comment">// '1,22,1'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// [1, 2].toString() -&gt; '1,2'</span></span><br><span class="line"><span class="comment">// [2, 1].toString() -&gt; '2,1'</span></span><br><span class="line"><span class="comment">// '1,2' + '2,1' = '1,22,1'</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span> + <span class="string">''</span> <span class="comment">// '1'，可以实现数字转字符串！</span></span><br><span class="line"></span><br><span class="line"><span class="string">'1'</span> - <span class="number">0</span> <span class="comment">// 1，可以实现字符串转数字！</span></span><br><span class="line"></span><br><span class="line">+ <span class="string">'1'</span> <span class="comment">// 1，可以实现字符串转数字！</span></span><br></pre></td></tr></table></figure>

<p>对于加号需要注意这个表达式 <code>&#39;a&#39; + + &#39;b&#39;</code>。在加法运算中，一般在变量前加 ‘+’，可以保证变量转化为数字。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">'a'</span> + + <span class="string">'b'</span> <span class="comment">// -&gt; "aNaN"</span></span><br><span class="line"><span class="comment">// 因为 + 'b' -&gt; NaN</span></span><br><span class="line"><span class="comment">// 你也许在一些代码中看到过 + '1' -&gt; 1</span></span><br></pre></td></tr></table></figure>

<h2 id="操作符"><a href="#操作符" class="headerlink" title="== 操作符"></a>== 操作符</h2><p><img src="https://cmspic-10004025.image.myqcloud.com/8b46e0f0-ab58-11e8-a714-437600d65b55_size_1078x908" alt="== 操作符"></p>
<p>上图中的 <code>toPrimitive</code> 就是对象转基本类型。</p>
<p>在 == 比较中，需要将【布尔值/字符串/】转化为【数值】，需要将【对象】转化为【基本类型】。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">undefined</span> == <span class="literal">false</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">null</span> == <span class="literal">false</span> <span class="comment">// false</span></span><br><span class="line"><span class="literal">NaN</span> == <span class="literal">false</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="string">''</span> == <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0</span> == <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">-0</span> == <span class="literal">false</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">NaN</span> == <span class="literal">NaN</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">null</span> == <span class="literal">null</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([] == <span class="literal">false</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([] == []) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log([] == ![]) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; == <span class="literal">false</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; == &#123;&#125;) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(&#123;&#125; == !&#123;&#125;) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>为何 <code>[] == ![] // -&gt; true</code> ？</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">[] == ![]</span><br><span class="line"><span class="comment">// [] 是真值，![] -&gt; false，即</span></span><br><span class="line">[] == <span class="literal">false</span></span><br><span class="line"><span class="comment">// 根据第 9 条得出</span></span><br><span class="line">[] == ToNumber(<span class="literal">false</span>)</span><br><span class="line"><span class="comment">//ToNumber(false) -&gt; 0，即</span></span><br><span class="line">[] == <span class="number">0</span></span><br><span class="line"><span class="comment">// 根据第 11 条得出</span></span><br><span class="line">ToPrimitive([]) == <span class="number">0</span></span><br><span class="line"><span class="comment">// [].toString() -&gt; ''，即</span></span><br><span class="line"><span class="string">''</span> == <span class="number">0</span></span><br><span class="line"><span class="comment">// 根据第 7 条得出</span></span><br><span class="line"><span class="number">0</span> == <span class="number">0</span> <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>

<p><code>null</code> 只能和 <code>null</code> 或 <code>undefined</code> 相等，其他都不相等！</p>
<p>同样，<code>undefined</code> 只能和 <code>undefined</code> 或 <code>null</code> 相等，其他都不相等！</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="literal">null</span> == <span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> == <span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> == <span class="number">0</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> == <span class="string">''</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="literal">null</span> == <span class="literal">false</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>由于 0 的类型是数值，null 的类型是 null。因此上面的前 11 步都得不到结果，要到第 12 步才能得到 false。</p>
<p><a href="http://es6.ruanyifeng.com/#docs/spec#%E7%9B%B8%E7%AD%89%E8%BF%90%E7%AE%97%E7%AC%A6" target="_blank" rel="noopener">相等运算符</a></p>
<h2 id="操作符-1"><a href="#操作符-1" class="headerlink" title="=== 操作符"></a>=== 操作符</h2><p>首先类型相等，其次判断 == 操作符</p>
]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
</search>
