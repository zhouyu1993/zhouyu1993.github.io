<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[谈谈字符编码]]></title>
    <url>%2Fzh%2F2018%2F05%2F04%2F%E8%B0%88%E8%B0%88%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[最近在做 vue-music，接口返回的日韩文字是实体编号的形式，所以需要将其解析成可阅读的日韩文字。 字符编码字符编码（Character encoding）也称字集码，是把字符集中的字符编码为指定集合中某一对象（例如：比特模式、自然数序列、8位组或者电脉冲），以便文本在计算机中存储和通过通信网络的传递。 因为计算机只能处理数字，所以如果要处理文本，就必须先把文本转换为数字。 最早的计算机在设计时采用 8 个比特（bit）作为一个字节（byte）。所以，一个字节能表示的最大的整数就是 255（二进制 11111111 = 十进制 255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是 65535，4 个字节可以表示的最大整数是 4294967295。 比特比特（BIT，binary system），计算机专业术语，是信息量单位。同时也是二进制数字中的位，信息量的度量单位，为信息量的最小单位。 8 bit (位) = 1 B (字节) 计算机中的 CPU 位数指的是 CPU 一次能处理的最大位数。例如 32 位计算机的 CPU 一次最多能处理 32 位数据。 二进制数系统中，每个 0 或 1 就是一个位（bit）。 二进制：00000000 (0) ~ 11111111 (255) parseInt(string, radix) 返回一个十进制的整数。string 指需被解析的字符串，其实字符串会先被转化为数字（Number(string)）；radix 指需解析的数字的基数（进制），值介于 2 ~ 36 之间，非必填。 如果 radix 不填，默认为十进制。 如果 radix 不填，但是 string 是以 ‘0’ 开头，则有可能是八进制有可能是十进制；string 是以 ‘0x’ 开头，则是十六进制。 123456789101112131415161718192021222324parseInt('00000000', 2) // -&gt; parseInt(0, 2)parseInt(0, 2) // 0parseInt(00000000, 2)parseInt('00000011', 2) // -&gt; parseInt(11, 2)parseInt(11, 2) // 3parseInt('11111111', 2) // -&gt; parseInt(11111111, 2)parseInt(11111111, 2) // 255parseInt('11', 8) // -&gt; parseInt(11, 8)parseInt(11, 8) // 9parseInt('11', 16) // -&gt; parseInt(11, 16)parseInt(11, 16) // 17parseInt('00000011') // -&gt; parseInt(11)parseInt(11) // 11 十进制parseInt(00000011) // -&gt; parseInt(Number(00000011)) -&gt; parseInt(9) 这里 Number 转化当作八进制处理了parseInt(9) // 9parseInt('0x000011') // -&gt; parseInt(0x000011)parseInt(0x000011) // 17 十六进制 字节字节（Byte），指一小组相邻的二进制数码。 ASCII：一个英文字母（不分大小写）占一个字节的空间，一个中文占两个字节的空间。一个二进制数字序列，在计算机中作为一个数字单元，一般为 8 位二进制数，换算为十进制。最小值 0，最大值 255。如一个 ASCII 就是一个字节。 utf-8：一个英文字符（含英文标点）等于一个字节，一个中文（含繁体和中文标点）等于三个字节。 Unicode：一个英文（含英文标点）等于两个字节，一个中文（含繁体和中文标点）等于两个字节。 字通常分为若干个字节，每个字所包含的位数称为字长。 字符集如需正确地显示 HTML 页面，浏览器必须知道使用何种字符集。 ASCII万维网早期使用的字符集是 ASCII。ASCII 支持 0-9 的数字，大写和小写英文字母表，以及一些特殊字符。 HTML 和 XHTML 用标准的 7 比特 ASCII 在网络上传输数据。 7 比特 ASCII 可提供 128 个不同的字符值。&amp;#0; ~ &amp;#127; 通常会额外使用一个扩充的比特，以便于以 1 个字节的方式存储，1 个字节等于 8 比特。 ISO 字符集ISO 字符集是国际标准组织 (ISO) 针对不同的字母表 / 语言定义的标准字符集。 ISO 字符集 描述 使用范围 ISO-8859-1 Latin alphabet part 1 北美、西欧、拉丁美洲、加勒比海、加拿大、非洲 ISO-8859-2 Latin alphabet part 2 东欧 … … … ISO-2022-JP Latin/Japanese part 1 日本语 ISO-2022-KR Latin/Korean part 1 韩语 ISO 8859-1HTML 4.01 支持 ISO 8859-1 字符集。 ISO-8859-1 的较低部分（从 1 到 127 之间的代码）是最初的 7 比特 ASCII。 ISO-8859-1 的较高部分（从 160 到 255 之间的代码）全都有实体名称。 这些符号中的大多数都可以在不进行实体引用的情况下使用，但是实体名称或实体编号为那些不容易通过键盘键入的符号提供了表达的方法。 注释：实体名称对大小写敏感。 Unicode 标准由于上面列出的字符集都有容量限制，而且不兼容多语言环境，Unicode 联盟开发了 Unicode 标准。 Unicode 标准涵盖了世界上的所有字符、标点和符号。 不论是何种平台、程序或语言，Unicode 都能够进行文本数据的处理、存储和交换。 Unicode 可以被不同的字符集兼容。最常用的编码方式是 utf-8 和 utf-16。 utf-8： UTF8 中的字符可以是 1-4 个字节长。utf-8 可以表示 Unicode 标准中的任意字符。utf-8 向后兼容 ASCII。utf-8 是网页和电子邮件的首选编码。 1&lt;meta charset="utf-8"&gt; utf-16： 16 比特的 Unicode 转换格式是一种 Unicode 可变字符编码，能够对全部 Unicode 指令表进行编码。utf-16 主要被用于操作系统和环境中，比如微软的 Windows 2000/XP/2003/Vista/CE 以及 Java 和 .NET 字节代码环境。 提示：最前面的 256 个 Unicode 字符集字符对应于 256 个 ISO-8859-1 字符。 提示：所有 HTML 4 处理器均已支持 utf-8，而所有 XHTML 和 XML 处理器支持 utf-8 和 utf-16。 HTML 4.01 符号实体本字符实体参考手册包括了数学符号、希腊字符、各种箭头记号、科技符号以及形状。 注释：实体名称对大小写敏感。 实体名称不一定有，但实体编码一定有! 实体名称与实体编号 结果 实体名称 实体编号 &amp; &amp;amp; &amp;#38; ♥ &amp;hearts; &amp;#9829; 지 - &amp;#51648; 𠮷 - &amp;#134071; 123456789101112131415161718192021&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; &lt;i&gt;♥&lt;/i&gt; &lt;i&gt;&amp;hearts;&lt;/i&gt; &lt;i&gt;&amp;#9829;&lt;/i&gt; &lt;/p&gt; &lt;p&gt; &lt;i&gt;지&lt;/i&gt; &lt;i&gt;&amp;#51648;&lt;/i&gt; &lt;/p&gt; &lt;p&gt; &lt;i&gt;𠮷&lt;/i&gt; &lt;i&gt;&amp;#134071;&lt;/i&gt; &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 显示结果 实体编码的显示一般在 html 代码里写实体编码，会被直接识别成结果显示在网页上。 如果需要在网页上显示出实体编码，只需要将 &amp; 写成 &amp;#38;。例如想显示 &amp;#134071; 即写成 &amp;#38;#134071;。另外还有一种形式，利用伪元素 :before 或 :after 的 css content 属性。 12&lt;i&gt;&amp;#38;#134071;&lt;/i&gt;&lt;i class="showCode"&gt;&lt;/i&gt; 123.showCode:before &#123; content: '&amp;#134071;';&#125; 显示结果与实体编码的互相转化显示结果转实体编码12345678910111213function encodeChar (input) &#123; const div = document.createElement('div') div.innerText = input const output = div.innerHTML return output&#125;encodeChar('&amp;') // '&amp;amp;'encodeChar('♥') // '♥'，失效encodeChar('지') // '지'，失效encodeChar('𠮷') // '𠮷'，失效encodeChar('&amp;♥지𠮷') // '&amp;amp;♥지𠮷'，失效encodeChar('지나;정일훈') // '지나;정일훈'，失效 我们发现，这种只对 ASCII 有效，返回的是 ASCII 的实体名称形式，而且只能在客户端使用（依赖 window.document）。 推荐采取下面方式，借助 for...of 和 codePointAt。 1234567891011121314function encodeChar (input) &#123; let output = '' for (let key of input) &#123; output += `&amp;#$&#123;key.codePointAt(0)&#125;;` &#125; return output&#125;encodeChar('&amp;') // '&amp;#38;'encodeChar('♥') // '&amp;#9829;'encodeChar('지') // '&amp;#51648;'encodeChar('𠮷') // '&amp;#134071;'encodeChar('&amp;♥지𠮷') // '&amp;#38;&amp;#9829;&amp;#51648;&amp;#134071;'encodeChar('지나;정일훈') // '&amp;#51648;&amp;#45208;&amp;#59;&amp;#51221;&amp;#51068;&amp;#54984;' 实体编码转显示结果遇到特殊字符如日韩文字的时候，后端返回给前端的数据通常会是实体编码的形式，因为是异步获取并非是直接写在 html 代码中，所以无法被浏览器解析，从而需要前端进行转义。 1234567891011121314function decodeChar (input) &#123; const div = document.createElement('div') div.innerHTML = input const output = div.innerText return output&#125;decodeChar('&amp;#38;') // '&amp;'decodeChar('&amp;#9829;') // '♥'decodeChar('&amp;#51648;') // '지'decodeChar('&amp;#134071;') // '𠮷'decodeChar('&amp;#38;&amp;#9829;&amp;#51648;&amp;#134071;') // '&amp;♥지𠮷'decodeChar('&amp;#51648;&amp;#45208;&amp;#59;&amp;#51221;&amp;#51068;&amp;#54984;') // '지나;정일훈'decodeChar('&amp;#51648;&amp;#45208;;&amp;#51221;&amp;#51068;&amp;#54984;') // '지나;정일훈' 这种方式只能在客户端使用（依赖 window.document）。 推荐采取下面方式，借助正则表达式和 String.fromCodePoint。 123456789101112131415function decodeChar (input) &#123; const output = input.replace(/&amp;#&#123;1&#125;[0-9]&#123;1,&#125;;&#123;1&#125;/ig, (v) =&gt; &#123; const code = v.replace(/&amp;#(.*);/, '$1') return String.fromCodePoint(code) &#125;) return output&#125;decodeChar('&amp;#38;') // '&amp;'decodeChar('&amp;#9829;') // '♥'decodeChar('&amp;#51648;') // '지'decodeChar('&amp;#134071;') // '𠮷'decodeChar('&amp;#38;&amp;#9829;&amp;#51648;&amp;#134071;') // '&amp;♥지𠮷'decodeChar('&amp;#51648;&amp;#45208;&amp;#59;&amp;#51221;&amp;#51068;&amp;#54984;') // '지나;정일훈'decodeChar('&amp;#51648;&amp;#45208;;&amp;#51221;&amp;#51068;&amp;#54984;') // '지나;정일훈' ES6+ 中字符串的扩展JavaScript 内部，字符以 utf-16 的格式储存，每个字符固定为 2 个字节。对于那些需要 4 个字节储存的字符（Unicode 码点大于 0xffff，即 65535 的字符），JavaScript 不能正确处理，JavaScript 会认为它们是两个字符，字符串长度会误判为 2，charCodeAt 方法只能分别返回前两个字节和后两个字节的值。 지 这个字的码点是 51648，ES6 之前的字符串方法处理是没有问题。 𠮷 这个字的码点是 134071，ES6 之前的字符串方法处理就会有问题。 123456789101112131415161718192021222324252627'지'.length // 1'지'.charAt(0) // '지''지'.charCodeAt(0) // 51648，码点，十进制'지'.charCodeAt(0).toString(16) // 'c9c0'+('0x' + '지'.charCodeAt(0).toString(16)) // '0xc9c0' -&gt; 0xc9c0 码点，十六进制 -&gt; 51648// ES 6'지'.codePointAt(0) // 51648，码点，十进制'지'.codePointAt(0).toString(16) // 'c9c0'+('0x' + '지'.codePointAt(0).toString(16)) // '0xc9c0' -&gt; 0xc9c0 码点，十六进制 -&gt; 5164851648 === 0xc9c0 // trueparseInt(0xc9c0) // 51648'지' === '\uc9c0' // true// ES 6'지' === '\u&#123;c9c0&#125;' // trueString.fromCharCode(51648) // '지'String.fromCharCode(0xc9c0) // '지'// ES 6String.fromCodePoint(51648) // '지'String.fromCodePoint(0xc9c0) // '지' 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647'𠮷'.length // 2。字符串长度误被判为 2'𠮷'.charAt(0) // '�'，失效'𠮷'.charAt(1) // '�'，失效'𠮷'.charCodeAt(0) // 55362，码点，十进制，失效'𠮷'.charCodeAt(0).toString(16) // 'd842'，失效+('0x' + '𠮷'.charCodeAt(0).toString(16)) // '0xd842' -&gt; 0xd842 码点，十六进制 -&gt; 55362，失效'𠮷'.charCodeAt(1) // 57271，码点，十进制，失效'𠮷'.charCodeAt(1).toString(16) // 'dfb7'，失效+('0x' + '𠮷'.charCodeAt(1).toString(16)) // '0xdfb7' -&gt; 0xdfb7 码点，十六进制 -&gt; 57271，失效// ES 6'𠮷'.codePointAt(0) // 134071，码点，十进制'𠮷'.codePointAt(0).toString(16) // '20bb7'+('0x' + '𠮷'.codePointAt(0).toString(16)) // '0x20bb7' -&gt; 0x20bb7 码点，十六进制 -&gt; 134071'𠮷'.codePointAt(1) // 57271，码点，十进制'𠮷'.codePointAt(1).toString(16) // 'dfb7'+('0x' + '𠮷'.codePointAt(1).toString(16)) // '0xdfb7' -&gt; 0xdfb7 码点，十六进制 -&gt;57271// codePointAt 方法在第一个字符（即 “𠮷” 的前两个字节）上，正确地识别了 “𠮷”，返回了它的十进制码点 134071（即十六进制的 0x20bb7）。在第二个字符（即 “𠮷” 的后两个字节）上，codePointAt 方法的结果与 charCodeAt 方法相同。// 对于类似字符串 '𠮷a'，字符 'a' 在字符串 '𠮷a' 的正确位置序号应该是 1，但是必须向 codePointAt 方法传入 2。解决这个问题的一个办法是使用 `for...of` 循环，因为它会正确识别 32 位的 utf-16 字符。let i = 0for (let key of '𠮷a') &#123; i ++ console.log(key, i)&#125;// '𠮷', 0// 'a', 1134071 === 0x20bb7 // trueparseInt(0x20bb7) // 134071'𠮷' === '\u20bb7' // false，失效// ES 6'𠮷' === '\u&#123;20bb7&#125;' // trueString.fromCharCode(134071) // 'ஷ'，失效String.fromCharCode(0x20bb7) // 'ஷ'，失效// ES 6String.fromCodePoint(134071) // '𠮷'String.fromCodePoint(0x20bb7) // '𠮷' ES6 为字符串添加了遍历器接口（详见 Iterator 和 for…of]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于vue的音乐music搜索(vue-music)]]></title>
    <url>%2Fzh%2F2018%2F05%2F02%2F%E5%9F%BA%E4%BA%8Evue%E7%9A%84%E9%9F%B3%E4%B9%90music%E6%90%9C%E7%B4%A2(vue-music)%2F</url>
    <content type="text"><![CDATA[一个基于vue的音乐搜索网页。预览vue-music。 风格复制qq-music。 代码参考sioxas-music。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机场初体验]]></title>
    <url>%2Fzh%2F2018%2F04%2F30%2F%E6%9C%BA%E5%9C%BA%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[周六去了南京禄口机场。浪？不存在的。 长这么大，我没怎么出过江苏省。过年回老家会途径安徽，然后就是之前去浙江旅游过几次。省内其他城市也去的很少，无非镇江、无锡、常州等。 高铁都很少坐的我，飞机更是没当面见过。偶尔听到空中轰鸣，旁边哥们指着天空，大喊一句，“看，飞机！”此处@大学室友觊凯，我们会好奇地抬头仰望。 外公他今年79岁了，去年来南京的时候，我带着玩了两天，他去哪儿都免费，倒是我，陪着玩却花了不少门票钱。 他很早就想去新疆玩。并不是像很多西行青年一样，所谓的穷游体会人生，他去的主要原因还是那里有亲戚。 五一劳动节终于下定决心去。提前一个星期打电话给我，让我在网上订票。 第一次订飞机票，最简单方式，打开【支付宝】APP。这跟广告无关。推荐大家使用【孩子王】APP。嗯，这是条硬广。 点击首页快捷入口【更多】，找到【第三方服务】中的【火车票机票】。选择出发点与目的地，选择出发日期。由于家境一般，我只会选择筛选【经济舱】，这里不想解释。。。然后就是看起飞时间与价格。然后看航班类型。 关于航班类型，这里多说几句。分【直达】【经停】【中转】。直达意思很简单，从出发地直接飞到目的地，一般路程短时间少。经停是，经过某个地方停下来，然后再飞到目的地，一般是路程较远，而且出发地客源较少，飞机从出发地带第一批人，然后飞到经停地，再带第二批人，通常会让第一批人下飞机休息一会儿，并打扫飞机上卫生，当然如果遇到晚点，会让第一批人留在飞机上，并让第二批人迅速上飞机。而中转的意思是，从出发地坐第一架飞机坐到中转地，然后所有人都下飞机，到中转地的人直接走了，到目的地的人在中转地机场等第二架飞机飞到目的地。【经停】和【中转】的区别就是前者一架飞机，后者多架飞机，显然后者时间长。如果你不赶时间，而且想在中转地玩一玩，中转是个好选择，机票便宜，而且能多去一个城市。 因为外公年纪大，而且对航线这些不太懂，怕他转机麻烦，我选了经停。一般航线都是固定的，例如我选的南京去克拉玛依的深航ZH9591，都是早上6点55分起飞。 机票总价一般包含机票钱、基建燃油钱和保险钱。前两个是必交，后一个是选交。关于保险，航空意外险还是很有必要的。关于延误险，个人觉得，如果不赶时间，没必要选。 由于是第一次去机场，很多东西不懂，加上行李很多，要办托运，另外住的地方离禄口机场比较远，虽然有地铁，但是最早也要6点，所以为了保险起见，决定提前两小时打车过去。为了避免半夜叫不到车的尴尬，虽然我跟爸妈说半夜叫车也容易，但是还是于前一天晚上预约了滴滴。 大约5点到达机场。快下车的时候，司机问我是 T1 还是 T2。当时就懵逼了，啥意思？也怪自己英语丢回了英国，不懂 T 是啥意思。 一般机场包含多个航站楼 Terminals 。南京禄口机场有两个航站楼，即所谓的 T1 和 T2。原 T1 是货运，但目前 T1 已经“暂停休整”，所以 T2 正负责国内、国际出发。据了解，以后 T1 航站楼将主要承担国内航班的到发，T2 航站楼将承担国际及部分国内航班的到发。 关于航班动态信息，可登录南京禄口国际机场查看，也可关注微信公众号【南京禄口国际机场】。比如我们输入【ZH9591】可查询，可以得知在 T2，也可以得知对应的值机柜台。 到达 T2 后，在门口航班信息公告屏上也可查询到对应航班所在的值机柜台。然后找寻值机柜台所在地，然后找一台可用的自动取票机，凭身份证或护照或网值电子二维码领取登机牌。关于护照，这里只允许中国，包含港澳台地区。外国人必须在人工值机柜台领取登机牌。关于电子二维码，需要关注微信公众号【南京禄口国际机场】，然后在微信值机功能中领取电子二维码，而且必须提前60分钟办理，一般适用于无托运行李的旅客。凭电子二维码可以直接在国内安检通道进行安检，当然国外的是不行的。 另外老人岁数比较大，自动取票机也是不支持的，必须走人工值机柜台，需要询问健康。我外公岁数大，所以就需要等工作人员上班。还要注意自己是什么舱，例如经济舱，就要在经济舱指定的值机柜台处理。 期间，有一家外国人，在我旁边试了半天的自动取票。看女人头戴纱巾，可能是印度等地。然后男人用英语指着自动取票机，问我怎么取票。我其实没听懂他说啥，但手势大致明白了。禄口机场有个不好的地方，自动取票机长得不一样，他面前这台机器我一下子没找到外国人用护照取票的地方。看屏幕提示半天，发现机器顶部有个长的横向卡槽，需要将护照的条形码在上面从左到右滑动。于是，讲了一句蹩脚的英语：“This! Here, slide it from left to right!”我指了指他的护照，然后指了那个横向卡槽，做了一个从左到右的动作。显然他看懂了我的动作，捣鼓了一句，然后尝试了起来。试了四五次，没成功，很尴尬，我也不知道怎么弄。然后他放弃了，指了指屏幕上的二维码，问我 “How to get it?”。我当时根本不知道这个二维码是啥。上面关于电子二维码的知识，是我事后诸葛亮上网查的。当时我只知道那东西叫 “qr code”。我很想来一句，“Can you speak Chinese?”。我还是决定灰溜溜地走开。后来我办理托运的时候，看到他们在值机班长那边办理。现在我懂了，外国人都只能在人工柜台那边办理。所以这些东西，是不是能更人性化一点，让国人以及外国人一下子就清楚咋回事？ 工作人员上班后，大概5点半，立马审核取票。然后办托运。关于行李，在家整理的时候，就要分两部分。随身携带的行李，一个五公斤以内的小包，一般是手提包或背包，放贵重物品如钱、手机、证件以及常用的物品如充电宝。托运行李，限重量不限数量，最多为40公斤。排队托运是个麻烦而且耗时的流程，所以如果有行李托运，一定要提前两小时左右去机场，而且去了立马排队。 托运办完后，就可以过安检了。一般是提前45分钟进行登机，所以安检尽量在45分钟前完成，除非有什么事情要处理。 走到对应安检区域，分国内和国外。安检过后，走到对应的登机口，等待安排登机。登机口可能随时发生变化，需要随时注意广播。 安检时，送行人员就不允许进入了。我给外公指清楚安检区域内大的指示牌提示的登机口，让他沿着那个方向走，找对应登机口，然后让他不懂的就问工作人员。 据外公说，到达登机口后，是安排小公交前往对应飞机的。 后面的事情我也不太清楚了，上诉有些是自己体验，有些是后来上网查询，总之也算对坐飞机的流程有了初步了解。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>趣事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每一个人都有灵魂，每一段文字都有思想]]></title>
    <url>%2Fzh%2F2018%2F01%2F08%2F%E6%AF%8F%E4%B8%80%E4%B8%AA%E4%BA%BA%E9%83%BD%E6%9C%89%E7%81%B5%E9%AD%82%EF%BC%8C%E6%AF%8F%E4%B8%80%E6%AE%B5%E6%96%87%E5%AD%97%E9%83%BD%E6%9C%89%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[“几年前，她抛弃了我，嫁给了一个开帕萨特的土鳖，我暗暗下定决心，将来一定要把现在受到的屈辱还给她。几年后，当我开着奔驰出现在她面前的时候，她一脸的惊讶，还招呼我去她家坐坐。” 方炎笑着说道。 蒋钦的心神完全被方炎的故事吸引，大眼睛一眨不眨地看着他。 这是一个屌丝被女神抛弃，然后奋发图强终于成功的励志故事？ “现在后悔了吧？早干什么去了？当然，我也果断地拒绝了她，因为我还得去公司接我老板下班呢～”方炎接着讲道。 “啊哈哈哈……” 蒋钦大笑，软软的身体前仰后合。 “太好玩了。这个人怎么这么贱啊！” 方炎说道：“这个段子很好笑，对不对？但是，你有没有想过，只要在这个段子里面改动一个字，就是一个很温馨浪漫的爱情故事。” 蒋钦瞪大了眼睛，说道：“还可以这样？” “你改着试试。”方炎笑了起来。“看看能不能找到那个需要改动的字。” 蒋钦习惯性的把笔杆咬在嘴里，小脸认真的思索起来。 “改变一个字就成了温馨浪漫的爱情故事？”小丫头的嘴里念念有词。“要改动哪一个字呢？” 方炎笑呵呵地看着她，等待着她的答案。 蒋钦显然不是一个多么有耐心的人，三五分钟后就放弃了。 她把沾着口水的铅笔丢在桌子上，烦躁地说道：“烦死了烦死了，人家想不出来。要改哪个字？” 方炎笑呵呵地看着她，说道：“每一个人都有灵魂，每一段文字都有思想，这些字是活的，它们是一个整体，你要从这个整体上去寻找一颗痣。这颗痣很微小，但是也很显眼。如果你能够静下心来，就一定可以找到。” “我已经很静心了啊。”小丫头撒娇的说道。她赤裸的小脚从桌子底下去踢方炎的小腿，说道：“方老师，你快告诉我嘛。我真的很好奇。” “如果把‘老板’改成‘老婆’，只是换一个字，换一个身份，故事的意思是不是就全然不一样了？” “啊？”小丫头惊叫出声。她都没想过改动会如此的简单。 可是，改动之后，故事的灵魂立即就发生了颠覆性的变化。 “几年前，她抛弃了我，嫁给了一个开帕萨特的土鳖，我暗暗下定决心，将来一定要把现在受到的屈辱还给她。几年后，当我开着奔驰出现在她面前的时候，她一脸的惊讶，还招呼我去她家坐坐。现在后悔了吧？早干什么去了？当然，我也果断地拒绝了她，因为我还得去公司接我老婆下班呢～” 前面一个故事，男主角是屌丝，却仍然没有逆袭成功。而改动过一个字后，男主角不仅仅在社会上证明了自己的能力，还对自己的老婆忠贞不渝。那个“前女友”失去了一个对感情认真负责的潜力黑马。 “你认真的想一想。”方炎说道。 蒋钦点头答应，趴在桌子上沉默不语。 “每一段文字都有一个命门，如果你能够找到它的命门，就再也没有什么问题能够难倒你了。” “生活也是。”蒋钦咯咯地笑。 原文]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>人性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 模块的演变]]></title>
    <url>%2Fzh%2F2018%2F01%2F08%2FJavaScript%20%E6%A8%A1%E5%9D%97%E7%9A%84%E6%BC%94%E5%8F%98%2F</url>
    <content type="text"><![CDATA[ES6 带来的原生 JavaScript 模块体系，相信你已经用起来了，如果还没有，那你还有时间看文章？看什么看，你还不赶紧去用用。 转载：原生 JavaScript 模块的现在与未来 JavaScript 一开始并没有内建模块化支持，也几乎没有模块化这种概念。当时没那么大的需求，搞个模块化显得大材小用啊。随着互联网的发展，尤其是 2006 年 ajax 技术的出现和之后 Web 2.0 的兴起，越来越多的业务逻辑向前端转移，前端开发的复杂程度和代码量逐渐提升。这时，由于缺乏模块化概念，JavaScript 的一些问题便凸显出来：代码难以复用、容易出现全局变量污染和命名冲突、依赖管理难以维护等等。一开始，开发者们使用诸如暴露全局对象、自执行函数等方法来规避这些问题，但仍无法从根本上解决问题。 CommonJS2009 年，基于将 JavaScript 应用于服务端的尝试，ServerJS 诞生了。之后 ServerJS 更名为 CommonJS，并逐步发展为一个完整的模块规范。简称 CMD（Common Module Definition） CommonJS官网CommonJS阮一峰 CommonJS 为模块的使用定义了一套 API。比如，它定义了全局函数 require，通过传入模块标识来引入其他模块，如果被引入的模块又依赖了其他模块，那么会依次加载这些模块；通过 module.exports 向外部暴露 API，以便其他的模块引入。 由于 CommonJS 是使用同步方式加载模块的，即只有加载完成才能进行接下来的操作，因此当应用于浏览器端时会受到网速的限制。 123456789101112131415const $ = require('jquery')// 定义私有方法function log (...arg) &#123; console.log(...arg)&#125;// 定义公有方法function sayHello () &#123; const el = $('body') log('zhouyu, hello', el)&#125;// 暴露公有方法module.exports = &#123; sayHello&#125; AMD之后，在 CommonJS 组织的讨论中，AMD（Asynchronous Module Definition）应运而生。和 CommonJS 不同的是，它使用异步方式加载模块，因此更适合被浏览器端采用。AMD 用全局函数 define 来定义模块，它需要三个参数：模块名称、模块的依赖数组、所有依赖都可用之后执行的回调函数（该函数按照依赖声明的顺序，接收依赖作为参数）。 AMDAMD中文 12345678910111213define(['jquery'], function ($) &#123; // 定义私有方法 function log (...arg) &#123; console.log(...arg) &#125; // 定义公有方法 function sayHello () &#123; const el = $('body') log('zhouyu, hello', el) &#125; // 暴露公有方法 return sayHello&#125;) UMD如果需要同时支持 CommonJS 和 AMD 两种格式，那么可以使用 UMD（Universal Module Definition）。事实上，UMD 通过一系列 if/else 判断来确定当前环境支持的模块体系，因此多数情况下 UMD 格式的模块会占用更大的体积。 123456789101112131415161718192021222324(function (root, factory) &#123; if (typeof define === 'function' &amp;&amp; define.amd) &#123; // AMD define(['jquery'], factory) &#125; else if (typeof exports === 'object') &#123; // Nodejs 或 CommonJS module.exports = factory(require('jquery')) &#125; else &#123; // 浏览器全局变量(root 即 window) root.returnExports = factory(root.jQuery) &#125;&#125;(this, function ($) &#123; // 定义私有方法 function log (...arg) &#123; console.log(...arg) &#125; // 定义公有方法 function sayHello () &#123; const el = $('body') log('zhouyu, hello', el) &#125; // 暴露公有方法 return sayHello&#125;)); ES6 Modules无论是 CommonJS，AMD 还是 UMD，它们都不是标准的 JavaScript 模块解决方案。换句话说，它们都没有被写进 ECMA 的规范中。直到 2015 年 6 月，TC39 委员会终于将 Modules 写进 ECMAScript 2015 中，标志着原生模块新时代的到来。至此，JavaScript 文件有了两种形式：脚本（自 JavaScript 诞生起我们就在使用的）和模块（即 ECMAScript 2015 Modules）。下面就让我们来一起探索 ECMAScript 2015 Modules（以下简称 ES6 Modules） ES6 ModulesES6阮一峰 12345678910111213import $ from('jquery')// 定义私有方法function log (...arg) &#123; console.log(...arg)&#125;// 定义公有方法function sayHello () &#123; const el = $('body') log('zhouyu, hello', el)&#125;export default sayHello ES6 Modules 现状时至今日，几大主流浏览器都在积极推进支持原生 ES6 Modules 的工作，部分浏览器的技术预览版也已经初步完成了这一使命。可以通过 caniuse 查看目前浏览器的支持情况。 使用 Babel 和 webpack由于绝大多数浏览器都不支持 ES6 Modules，所以目前如果想使用它的语法，需要借助 Babel 和 webpack，即通过 Babel 将代码编译为 ES5 的语法，然后使用 webpack 打包成目标格式。 直接使用 ES6 Modules有些游览器已经支持 ES6 Modules，我们利用 &lt;script type=&quot;module&quot;&gt;（默认是 defer）来使用。 其他探索 动态加载方案 import() 1234const load = async (url) =&gt; &#123; const module = await import(url) console.log(module, window[tempGlobal])&#125; 12345678910111213141516171819202122function load (url) &#123; return new Promise((resolve, reject) =&gt; &#123; const script = document.createElement('script') const tempGlobal = '__tempModuleLoadingVariable' + Math.random().toString(32).substring(2) script.type = 'module' script.textContent = `import * as m from "$&#123;url&#125;"; window.$&#123;tempGlobal&#125; = m;` script.onload = () =&gt; &#123; resolve(window[tempGlobal]) delete window[tempGlobal] script.remove() &#125; script.onerror = () =&gt; &#123; reject(new Error('Failed to load module script with URL ' + url)) delete window[tempGlobal] script.remove() &#125; document.documentElement.appendChild(script) &#125;)&#125; 基于 ES6 Modules 的 module-pusher 尝试 查看原文]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好人有好报？]]></title>
    <url>%2Fzh%2F2017%2F12%2F24%2F%E5%A5%BD%E4%BA%BA%E6%9C%89%E5%A5%BD%E6%8A%A5%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[好人有好报，这句话现在似乎变成了鸡汤。 今天是平安夜，本该是成双成对，你侬我侬着，显然我不是。 上午一踏进地铁站，听着地铁工作者特地点播的节日喜庆歌曲，心里却一直荡起，“lonely lonely christmas”，问我的心情，大概是哭笑不得。不过今天是出去旅游观光的，我得表现得 happy 点。 走马观花地看完大报应寺。 大报应寺，是继洛阳白马寺之后中国的第二座寺庙，也是中国南方建立的第一座佛寺。 大报恩寺内琉璃宝塔高达78.2米，通体用琉璃烧制，塔内外置长明灯一百四十六盏，自建成至衰毁一直是中国最高的建筑，也是世界建筑史上的奇迹，位列中世纪世界七大奇迹，被当时西方人视为代表中国的标志性建筑，有“中国之大古董，永乐之大窑器”之誉，被称为“天下第一塔”。 寺内阿育王塔中的佛顶骨舍利是世界现存唯一一枚佛祖（释迦摩尼）真身顶骨舍利，不过现在供奉于南京牛首山的佛顶宫中。 寺内三藏塔中供奉着玄奘法师（唐僧）的顶骨舍利。 南朝四百八十寺，多少楼台烟雨中。如今看风景，已全然没有少时那副怡然自得的欣赏，也不会看到一处就随口吟上一句相应的古诗。 大报应寺，报应报应，因果循环。 《吕祖说三世因果经》主要说的是：一是人的命是自己造就的；二是怎样为自己造一个好命；三是行善积德与行凶作恶干坏事的因果循环报应规律。因果报应指事物的起因和结果，种什么因，结什么果，宗教认为种什么因，结什么果报。 《涅槃经》讲：业有三报，一现报，现作善恶之报，现受苦乐之报；二生报，或前生作业今生报，或今生作业来生报；三速报，眼前作业，目下受报。 俗话说：善有善报，恶有恶报，不是不报，时候未到，时候一到，一切全报。 所以，常听周围说：好人有好报。 上面只是胡扯一通，瞎写一气，狗屁不是，不看也罢，看了无妨。 然而说说接下来的遭遇，报应真的一个接着一个，但我也没干什么坏事啊。 找了一家中华门城头下的羊肉馆，点一份羊杂汤，热乎吃完也罢。站着刚把钱付了，站我对面的是店家一老龄员工，手上端着估计有过百度的一大锅羊肉汤。大概是锅底被高温烫的脱掉了，哗啦啦，滚烫的羊肉汤顿时倾盆而下。恰巧泼到我脚下，我顿时炸毛，可由于这两年体态丰腴了些，敏捷性明显下降，还是慢了，左脚脚背被泼到了。顿时一股灼烧感从脚背传到头皮，疼得我牙痒痒。也不顾着形象了，当场脱了鞋袜。暗自感叹，还好鞋子好，防水，只是左脚一小片烫的发红。 事情发生到着，我先不往下说，各位先代入想想，假如是你遇到这种事情，你会怎么处理？ 去医院和赔钱呗。但我们往往看到是一方抵赖，一方讹钱。我这花钱吃饭，却无端遭了这罪，脚被烫着，凭什么？另外我的鞋子虽然不算贵，也才几百块，经此一泼，虽然发挥些艰苦奋斗的精神，刷一刷还是照穿无误，但凭什么？当然事实是，老板说带我去医院，我说不用了，我也没有提要钱，甚至我都没让老板把我的单免了。脚被烫了一下而已，鞋子脏了而已，能忍则忍了，乡下人老实，不觉得这是多大事。但另一方面，也许是内心软弱吧，也许要被人以鲁迅先生的话训斥为“哀其不幸，怒其不争”。我们经常看到类似新闻，例如有，某一女子（不是歧视女性）的名牌包包被弄脏要求巨额赔偿，甚至说被人厌烦的碰瓷。我这里并不是说，我们遇到这事情，我们不该要求赔偿，如果确实有损失，那么要求赔偿是必然的。甚至是一些严重的事情，第一反应是报警去医院。不要为了钱而要钱，不要越过做人的底线。假如对方不是故意的，你也能够接受，不妨退一步海阔天空，人家也不容易，一大锅汤损失不少钱，不至于捡起来重煮吧。。。 大概看到这里，你会说，好人有好报的。你是在积德行善，将来你会娶个好老婆。 你可知，这只是开始。 我坐在城墙下的路边休息，阳光刺眼，我就闭眼假寐，顺便缓缓脚上的疼痛。突然一堆水溅了过来，不过这次是冷水，泼了我一腿。大哥，冰火两重天不是这么玩的啊，你怎么知道我脚需要降温，但是你浇鞋子就行了，浇我一腿干嘛。我看着晒水车扬长而去，看着那一行“城市清洁”字苦笑，我大概是城市垃圾。 我是不敢坐着了，赶紧站起来，朝着阳光，抖抖自己的裤子，自然风干吧。没过几分钟，哗啦啦，屁股一激灵，低头一看，我呢子大衣上挂着一颗颗水珠，投影着我胖乎乎的脸，我看着他们，他们看着我，仿佛听见一句和声，“傻逼”。不打招呼就来一场雷阵雨，我不想看啊。洒水大哥，你也挺幸苦的啊，政府规定要洒两遍还是咋地，我就站这休息，我犯法了吗，你不能提醒我一下？我是来大报应了吗？ 不深入阐述了，也不说些什么升华的话语，鸡汤虽好喝，但是你们不爱喝啊。 我还活着，活着就好！ 愿你喜乐安好！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>人性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fzh%2F2017%2F12%2F23%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
