<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[nginx]]></title>
    <url>%2Fzh%2F2019%2F06%2F03%2Fnginx%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[不同系统中nginx的安装与使用。 包括：MacOS、linux、windows 等。 MacOS安装 nginx1234567891011121314# First update the formulae and Homebrew itself:brew update# You can now find out what is outdated with:brew outdated# Upgrade everything with:brew upgrage# Check nginx information to see if it is installed:brew search nginx# Install nginxbrew install nginx 安装完成后， nginx 目录在 /usr/local/Cellar/nginx nginx 的主页文件在 /usr/local/var/www nginx 的日志文件在 /usr/local/var/log/nginx nginx 的配置文件在 /usr/local/etc/nginx/nginx.conf 使用 nginx1234567891011121314151617# 查看使用 brew 安装的服务列表（包括服务状态）brew services list# 清除已卸载应用的无用的配置brew services cleanup# 查看 80 端口lsof -i:80# 启动 nginx 服务，并注册brew services start nginx# 停止 nginx 服务，并取消注册brew services stop nginx# 重启 nginx 服务，并注册brew services restart nginx 注意，这里不要使用 nginx 命令来启动 nginx 服务，这样不方便停止 linuxlinux 常用命令 ls: 列出目录 cd: 切换目录 pwd: 显示目前的目录 mkdir: 创建一个新的目录 cp: 复制文件或目录 rm: 移除文件或目录 mv: 移动文件与目录，或修改文件与目录的名称 cat: 由第一行开始显示文件内容 nl: 显示的时候，顺道输出行号！ more: 一页一页的显示文件内容 less: 与 more 类似，但是比 more 更好的是，他可以往前翻页！ head: 只看头几行 tail: 只看尾巴几行 touch: 创建空白文档 vi: 创建一个编辑状态的空文档，只有保存退出后才创建成功，文件属性与 touch 创建的相同 vim: vi 的升级版本 linux 命令大全 在终端利用 ssh 登录远程服务器1234# 登录ssh -p [服务器port] [userName]@[服务器ip]# 输入密码 安装 nginxlinux packages 需要根据 linux 的版本选择对应的包 12345# 打印当前系统相关信息（操作系统名称、在网络上的主机名称、操作系统的发行编号、操作系统的版本、处理器类型、硬件平台、电脑类型、操作系统名称等）uname -a# 查看操作系统的标识文件cat /etc/*-release 发现是 CentOS 7 123456789# 查看机器的 ipifconfig# 查看机器是否能访问外网curl -l https://www.baidu.comwget https://www.baidu.comping baidu.com 如果机器能访问外网：Install the prerequisites: 1yum update &amp;&amp; yum install yum-utils To set up the yum repository, create the file named /etc/yum.repos.d/nginx.repo with the following contents: [nginx-stable]name=nginx stable repobaseurl=http://nginx.org/packages/centos/$releasever/$basearch/gpgcheck=1enabled=1gpgkey=https://nginx.org/keys/nginx_signing.key [nginx-mainline]name=nginx mainline repobaseurl=http://nginx.org/packages/mainline/centos/$releasever/$basearch/gpgcheck=1enabled=0gpgkey=https://nginx.org/keys/nginx_signing.key By default, the repository for stable nginx packages is used. If you would like to use mainline nginx packages, run the following command: 1yum-config-manager --enable nginx-mainline To install nginx, run the following command: 1yum install nginx 如果机器不能访问外网：本地安装 PCRE 和 Nginx ： PCRE 作用是让 Nginx 支持 Rewrite 功能。 下载 PCRE 安装包，下载地址：https://sourceforge.net/projects/pcre/files/pcre/ 选择最新的 zip 包，例如：http://downloads.sourceforge.net/project/pcre/pcre/8.43/pcre-8.43.tar.gz 1wget http://downloads.sourceforge.net/project/pcre/pcre/8.43/pcre-8.43.tar.gz 下载 Nginx 安装包，下载地址：http://nginx.org/en/download.html 选择最新的 zip 包，例如：http://nginx.org/download/nginx-1.17.0.tar.gz 1wget http://nginx.org/download/nginx-1.17.0.tar.gz 使用 ssh 上传 PCRE 和 Nginx 的安装包 如果已知服务器密码，在本地： 123scp -r [本地文件路径] [userName]@[服务器ip]/[服务器文件路径]# 输入密码 如果未知服务器密码，在服务器： 123scp -r [userName]@[本地ip]/[本地文件路径] [服务器文件路径]# 输入密码 当然，未知服务器密码时，需要本地开启 ssh。下面给出 MacOS 开启 ssh 服务的方法： 12345sudo systemsetup -getremotelogin # 查看 ssh 服务状态sudo systemsetup -setremotelogin on # 开启 ssh 服务sudo systemsetup -setremotelogin off # 关闭 ssh 服务 或者 系统偏好设置 -&gt; 共享 -&gt; 远程登录 解压 pcre 安装包并编译安装 123456789101112131415# 进入刚刚上传安装包的文件目录，自定义。这里选择 /usr/local/srccd /usr/local/src# 解压 pcretar -zxvf pcre-8.43.tar.gz# 编译安装 pcrecd pcre-8.43./configuremake &amp;&amp; make install# 查看 pcre 版本pcre-config --version 解压 nginx 安装包并编译安装 123456789101112131415161718# 进入刚刚上传安装包的文件目录，自定义。这里选择 /usr/local/srccd /usr/local/src# 解压 nginxtar -zxvf nginx-1.17.0.tar.gz# 查看是否存在 opensslwhich openssl# 编译安装 nginxcd nginx-1.17.0./configure --with-http_stub_status_module --with-http_ssl_module --with-pcre=/usr/local/src/pcre-8.43make &amp;&amp; make install# 查看 nginx 版本/usr/local/nginx/sbin/nginx -v nginx 编译选项： –prefix=path 定义一个目录，存放服务器上的文件，也就是 nginx 的安装目录。默认为 /usr/local/nginx。 –sbin-path=path 设置 nginx 的可执行文件的路径，默认为 *prefix*/sbin/nginx。 –conf-path=path 设置 nginx.conf 文件的路径。默认为 *prefix*/conf/nginx.conf。 –pid-path=path 设置 nginx.pid 文件的路径。安装完成后，可以随时改变的文件名，在 nginx.conf 配置文件中使用 PID 指令。默认为 *prefix*/logs/nginx.pid。 –error-log-path=path 设置主错误、警告和诊断文件的路径。安装完成后，可以随时改变的文件名，在 nginx.conf 配置文件中使用 error_log 指令。默认为 *prefix*/logs/error.log。 –http-log-path=path 设置主请求的 HTTP 服务器的日志文件的路径。安装完成后，可以随时改变的文件名，在nginx.conf 配置文件中使用 access_log 指令。默认为 *prefix*/logs/access.log。 –with-http_stub_status_module 开启 stub_status 模块监控，查看 Nginx 的一些状态信息。 –with-http_ssl_module 使用 https 协议模块。默认情况下，该模块没有被构建。建立并运行此模块的 openssl 库是必需的。 –with-pcre=path 设置 PCRE 库的源码路径。让 Nginx 支持 Rewrite 功能。 将 nginx 命令添加到 PATH 中 1234567891011121314# 修改 /etc/profilevi /etc/profile# 找到 export 行，在下面新增加一行，内容为：export PATH=$PATH:/usr/local/webserver/nginx/sbin# 保持并退出：:wq# 立即生效source /etc/profile# 查看 nginx 版本nginx -v 使用 nginx1234nginx -h/--help# 启动 nginxnginx 修改 /usr/local/nginx/conf/nginx.conf： 1vi /usr/local/nginx/conf/nginx.conf 在 http 块下加 include conf.d/*.conf;： 123456789http &#123; include mime.types; default_type application/octet-stream; # 新增 include conf.d/*.conf; # ...&#125; 新建 /usr/local/nginx/conf/conf.d 文件夹，新建 xxx.com.conf： 123cd /usr/local/nginx/conf &amp;&amp; mkdir conf.dcd conf.d &amp;&amp; vi xxx.com.conf 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950upstream mipush-op &#123; server yyy.yyy.yyy.yyy:port;&#125;server &#123; listen 80; server_name xxx.com; ssi on; error_log /home/work/log/nginx/xxx.com-error.log; access_log /home/work/log/nginx/xxx.com-access.log; log_not_found on; set $root_dir /home/work/html/xxx.com; set $root_dir_zh $root_dir/zh_CN/; set $root_dir_en $root_dir/en/; root $root_dir; location / &#123; rewrite ^(.*)$ http://xxx.com/zh_CN/ redirect; &#125; location ^~ /zh_CN &#123; alias $root_dir_zh; try_files $uri $uri/ /zh_CN/index.html; &#125; location ^~ /en &#123; alias $root_dir_en; try_files $uri $uri/ /en/index.html; &#125; location ~ /(mipush/op/.*)$ &#123; rewrite ^/mipush/(.*)$ /$1 break; proxy_pass http://mipush-op; proxy_set_header Host $http_host; &#125; error_page 404 /404.html; error_page 500 /500.html; error_page 502 /502.html; error_page 503 /503.html; error_page 504 /504.html; # 自定义 404 location = /404.html &#123; root $root_dir/404.html; &#125;&#125; 重新加载 nginx 配置文件 12345# 检查nginx -t# 重载nginx -s reload 停止 nginx 12345678910nginx -s quit/stop# 查看 80 端口lsof -i:80# 查询 nginx 主进程号ps -ef | grep nginx# 强制停止 nginxkill -9 [主进程号] nginx 常用命令nginx -h nginx -v nginx -V nginx -t nginx -s stop/quit/reopen/reload nginx 配置相关知识location 匹配语法规则1234567location [ = | ^~ | ~ | ~* | !~ | !~* | / ] uri &#123; // ...&#125;location @name &#123; // ...&#125; 语法规则很简单，一个 location 关键字，后面跟着可选的修饰符，后面是要匹配的字符，花括号中是要执行的操作。 修饰符123456789101112131415= # 进行普通字符精确匹配。只有请求的 url 路径与后面的字符串完全相等时，才会命中^~ # 表示普通字符匹配，如果该选项匹配，只匹配该选项，不再匹配别的选项，一般用来匹配目录~ # 表示执行一个正则匹配，区分大小写~* # 表示执行一个正则匹配，不区分大小写!~ # 表示执行一个正则不匹配，区分大小写!~* # 表示执行一个正则不匹配，不区分大小写/ # 通用匹配, 如果没有其它匹配，任何请求都会匹配到@ # 定义一个命名的 location，使用在内部定向时，例如 error_page, try_files 顺序 no优先级： (location =) &gt; (location 完整路径) &gt; (location ^~ 路径) &gt; (location 、* 正则顺序) &gt; (location 部分起始路径) &gt; (/) 建议使用：=、^~、~*、/ 匹配过程 对请求的 url 序列化。例如，对 %xx 等字符进行解码，去除 url 中多个相连的 /，解析 url 中的 .，.. 等。这一步是匹配的前置工作。 location 有两种表示形式，一种是使用前缀字符，一种是使用正则。如果是正则的话，前面有 ~ 或 ~* 修饰符。 具体的匹配过程如下： 首先先检查使用前缀字符定义的 location，选择最长匹配的项并记录下来。 如果找到了精确匹配的 location，也就是使用了 = 修饰符的 location，结束查找，使用它的配置。 然后按顺序查找使用正则定义的 location，如果匹配则停止查找，使用它定义的配置。 如果没有匹配的正则 location，则使用前面记录的最长匹配前缀字符 location。 基于以上的匹配过程，我们可以得到以下两点启示： 使用正则定义的 location 在配置文件中出现的顺序很重要。因为找到第一个匹配的正则后，查找就停止了，后面定义的正则就是再匹配也没有机会了。 使用精确匹配可以提高查找的速度。例如经常请求 / 的话，可以使用 = 来定义 location。 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253location = / &#123; # 精确匹配 / ，主机名后面不能带任何字符串 [ configuration A ]&#125;location / &#123; # 因为所有的地址都以 / 开头，所以这条规则将匹配到所有请求 # 但是正则和最长字符串会优先匹配 [ configuration B ]&#125;location /documents/ &#123; # 匹配任何以 /documents/ 开头的地址，匹配符合以后，记住还要继续往下搜索 # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条 [ configuration C ]&#125;location ~ /documents/Abc &#123; # 匹配任何以 /documents/Abc 开头的地址，匹配符合以后，还要继续往下搜索 # 只有后面的正则表达式没有匹配到时，这一条才会采用这一条 [ configuration CC ]&#125;location ^~ /images/ &#123; # 匹配任何以 /images/ 开头的地址，匹配符合以后，停止往下搜索正则，采用这一条。 [ configuration D ]&#125;location ~* \.(gif|jpg|jpeg)$ &#123; # 匹配所有以 .gif, .jpg 或 .jpeg 结尾的请求 # 然而，所有请求 /images/ 下的图片会被 config D 处理，因为 ^~ 到达不了这一条正则 [ configuration E ]&#125;location /images/ &#123; # 字符匹配到 /images/，继续往下，会发现 ^~ 存在 [ configuration F ]&#125;location /images/abc &#123; # 最长字符匹配到 /images/abc，继续往下，会发现 ^~ 存在 # F 与 G 的放置顺序是没有关系的 [ configuration G ]&#125;location ~ /images/abc/ &#123; # 只有去掉 config D 才有效：先最长匹配 config G 开头的地址，继续往下搜索，匹配到这一条正则，采用 [ configuration H ]&#125;location ~* /js/.*/\.js &#123;&#125; / -&gt; config A精确完全匹配，匹配到A，即使 /index.html 也匹配不了 /downloads/download.html -&gt; config B完整路径，匹配到B，往下继续搜索发现没有任何匹配，最后采用B /images/1.gif -&gt; configuration D完整路径，匹配到F，往下匹配到D，停止往下，采用D /images/abc/def -&gt; config D完整路径，最长匹配到G，往下匹配到D，停止往下，采用D你可以看到 任何以 /images/ 开头的都会匹配到D并停止，FG写在这里是没有任何意义的，H是永远轮不到的，这里只是为了说明匹配顺序 /documents/document.html -&gt; config C完整路径，匹配到C，往下继续搜索发现没有任何匹配，最后采用C /documents/1.jpg -&gt; configuration E完整路径，匹配到C，往下正则匹配到E /documents/Abc.jpg -&gt; config CC完整路径，最长匹配到C，往下正则顺序匹配到CC，不会往下到E（正则匹配时，顺序很重要，一旦匹配就停止了） 实际使用建议实际使用中，个人觉得至少有三个匹配规则定义，如下： 1234567891011121314151617181920212223# 直接匹配网站根，通过域名访问网站首页比较频繁，使用这个会加速处理，官网如是说。# 这里是直接转发给后端应用服务器了，也可以是一个静态首页# 第一个必选规则location = / &#123; proxy_pass http://tomcat:8080/index&#125;# 第二个必选规则是处理静态文件请求，这是 nginx 作为 http 服务器的强项# 有两种配置模式，目录匹配或后缀匹配,任选其一或搭配使用location ^~ /static/ &#123; root /webroot/static/;&#125;location ~* \.(gif|jpg|jpeg|png|css|js|ico)$ &#123; root /webroot/res/;&#125;# 第三个规则就是通用规则，用来转发动态请求到后端应用服务器# 非静态文件请求就默认是动态请求，自己根据实际把握# 毕竟目前的一些框架的流行，带 .php, .jsp 后缀的情况很少了location / &#123; proxy_pass http://tomcat:8080/&#125; location @name 的用法@用来定义一个命名 location。主要用于内部重定向，不能用来处理正常的请求。其用法如下： 123456location / &#123; try_files $uri $uri/ @custom&#125;location @custom &#123; # ...do something&#125; 上例中，当尝试访问 url 找不到对应的文件就重定向到我们自定义的命名 location（此处为custom）。 值得注意的是，命名 location 中不能再嵌套其它的命名 location。 URL 尾部的 / 需不需要推荐带 根据约定，URL 尾部的 / 表示目录，没有 / 表示文件。 访问 /some-dir/ 时，服务器会自动去该目录下找对应的默认文件。 访问 /some-dir 时，服务器会先去找 some-dir 文件，找不到的话会将 some-dir 当成目录，重定向到 /some-dir/，去该目录下找默认文件。 set定义在 server, location, if 模块中 设置指定变量的值。变量的值可以包含文本，变量或者是它们的组合形式。 123456789location / &#123; set $var1 "host is "; set $var2 $host; set $var3 " uri is $request_uri"; return 200 "response ok $var1$var2$var3";&#125;# 发送如下请求# curl 127.0.0.1:8080/test# response ok host is 127.0.0.1 uri is /test root 与 alias推荐 alias 都可以定义在 location 模块中，都是用来指定请求资源的真实路径。 root，是把location那部分也给拼接起来了。 alias，正如其名，代理！是将 /i/ 代理为 /data/w3。 alias 只能作用在 location 中，而 root 可以存在 server、http 和 location 中。 alias 后面必须要用 “/” 结束，否则会找不到文件，而 root 则对 ”/” 可有可无。 123location /i/ &#123; root /data/w3;&#125; http://localhost/i/ -&gt; /data/w3 http://localhost/i/test.html -&gt; /data/w3/i/test.html http://localhost/i/j/test.html -&gt; /data/w3/i/j/test.html 123location /i/ &#123; alias /data/w3/;&#125; http://localhost/i/ -&gt; /data/w3 http://localhost/i/test.html -&gt; /data/w3/test.html http://localhost/i/j/test.html -&gt; /data/w3/j/test.html try_files12345678910111213141516upstream mongrel &#123; server 127.0.0.1:4000;&#125;location / &#123; try_files $uri $uri/ $uri.html =404;&#125;location / &#123; try_files $uri $uri/ /index.html @mongrel;&#125;location @mongrel &#123; proxy_pass http://mongrel; proxy_set_header Host $http_host;&#125; 当用户请求 http://localhost/example 时，这里的 $uri 就是 /example。 try_files 会到服务器里尝试找这个文件。如果存在名为 /$root/example（其中 $root 是项目代码安装目录）的文件，就直接把这个文件的内容发送给用户。 显然，目录中没有叫 example 的文件。然后就看 $uri/，增加了一个 /，也就是看有没有名为 /$root/example/ 的目录，如果有则去该目录下找默认文件 /$root/example/index.html。 又找不到，就会看 /index.html，发起一个内部 “子请求”，重定向到 http://localhost/index.html。 又找不到，就会看 @mongrel，发起一个内部 “子请求”，重定向到 @mongrel 模块。 index指令拥有默认值，index index.html，即，如果没有给出 index，默认初始页为 index.html。 12345location / &#123; root /data/www; try_files $uri $uri/ $uri.html =404; index index.html index.htm;&#125; rewriterewrite 功能就是，使用 nginx 提供的全局变量或自己设置的变量，结合正则表达式和标志位实现 url 重写以及重定向。 规则rewrite 只能放在 server {}, location {}, if {} 中，并且只能对域名后边的除去传递的参数外的字符串起作用。例如 http://seanlook.com/a/we/index.php?id=1&amp;u=str 只对 /a/we/index.php 重写。 语法：rewrite regex replacement [flag]; 如果相对域名或参数字符串起作用，可以使用全局变量匹配，也可以使用 proxy_pass 反向代理。 表面看 rewrite 和 location 功能有点像，都能实现跳转，主要区别在于 rewrite 是在同一域名内更改获取资源的路径，而 location 是对一类路径做控制访问或反向代理，可以 proxy_pass 到其他机器。很多情况下 rewrite 也会写在 location 里，它们的执行顺序是： 执行 server 块的 rewrite 指令 执行 location 匹配 执行选定的 location 中的 rewrite 指令 如果其中某步 uri 被重写，则重新循环执行 1-3，直到找到真实存在的文件；循环超过 10 次，则返回 500 Internal Server Error 错误。 rewrite 指令是使用指定的正则表达式 regex 来匹配请求的 uri，如果匹配成功，则使用 replacement 更改 uri。 rewrite 指令按照它们在配置文件中出现的顺序执行。可以使用 flag 标志来终止指令的进一步处理。如果替换字符串 replacement 以 http://，https:// 或 $ scheme 开头，则停止处理后续内容，并直接重定向返回给客户端。 第一种情况 重写的字符串带 http:// 123456789location / &#123; # 当匹配正则表达式 /test1/(.*)时 请求将被临时重定向到 http://www.$1.com # 相当于 flag 写为 redirect rewrite /test1/(.*) http://www.$1.com; return 200 "ok";&#125;# 在浏览器中输入 127.0.0.1:8080/test1/baidu# 则临时重定向到 http://www.baidu.com# 后面的 return 指令将没有机会执行了 第二种情况 重写的字符串不带 http:// 123456789location / &#123; rewrite /test1/(.*) www.$1.com; return 200 "ok";&#125;# 在终端中输入 curl 127.0.0.1:8080/test1/baidu# ok# 此处没有带 http:// 所以只是简单的重写。请求的 uri 由 /test1/baidu 重写为 www.baidu.com# 因为会顺序执行 rewrite 指令，所以下一步执行 return 指令，响应了 ok flag 标志位 last: 相当于 Apache 的 [L] 标记，表示完成 rewrite。 break: 停止执行当前虚拟主机的后续 rewrite 指令集。 redirect: 返回 302 临时重定向，地址栏会显示跳转后的地址 permanent: 返回 301 永久重定向，地址栏会显示跳转后的地址 因为 301 和 302 不能简单的只返回状态码，还必须有重定向的 URL，这就是 return 指令无法返回 301、302 的原因了。这里 last 和 break 区别有点难以理解： last 与 break last 一般写在 server 和 if 中，而 break 一般使用在 location 中 last 不终止重写后的 url 匹配，即新的 url 会再从 server 走一遍匹配流程，而 break 终止重写后的匹配 last 和 break 都能阻止继续执行后面的 rewrite 指令 例子： 12345678910111213141516171819202122232425262728rewrite xxx1 yyy last; ⑦rewrite xxx2 yyy last; ⑧rewrite xxx3 yyy last; ⑨rewrite xxx4 yyy last; ⑩location ~ url1 &#123; rewrite url1 url2 last; ①&#125;location ~ url3 &#123; rewrite url3 url4 break; ② # 这条指令会被忽略 rewrite url3 url5; # 因为 fastcgi_pass 不是 rewrite 模块的指令，所以它不会被 break终止 fastcgi_pass 127.0.0.1:9000;&#125;location ~ url5 &#123; rewrite url5 url6 break; ② # 这条指令会被忽略 rewrite url5 url7; # 因为 proxy_pass 不是 rewrite 模块的指令，所以它不会被 break终止 proxy_pass https://www.baidu.com;&#125; 第一个 location 中的 rewrite 指令处理完成之后，会跳出 location，再重新判断 rewrite 7 ~ 9 的规则。 第二个 location 中的 rewrite 指令处理完成之后，不会跳出 location，更不会重新判断 rewrite 7 ~ 9 的规则。而只能将信息传递给后面的 fastcgi_pass 或者 proxy_pass 等指令。 last: 使用了 last 指令，rewrite 后会跳出 location 作用域，重新开始再走一次刚刚的行为。 break: 使用了 break 指令，rewrite 后不会跳出 location 作用域。它的生命也在这个 location 中终结。 last 和 break 相对于访问日志的请求状态码是 200。 permanent 和 redirectpermanent 301 永久重定向 redirect 302 临时重定向 SEO 在利用百度的搜索引擎的时候，301 的 SEO 是对应重定向后的内容和 url，302 的 SEO 是对应重定向后的内容和重定向前的 url；在利用 Google 的搜索引擎的时候，Google会将 302 按照 301 处理，所以 SEO 都是重定向后的内容和 url； 尽量要使用 301 跳转，防止网址劫持。 尽量使用 permanent。 浏览器会缓存 301 的请求，不会缓存 302 的。 如果是个人网站，或网站用途只是开发测试，改动的可能性比较大，建议使用 302。 如果是生产环境，或改动的可能性比较小，建议使用 301。 rewrite 后的请求参数如果替换字符串 replacement 包含新的请求参数，则在它们之后附加先前的请求参数。如果你不想要之前的参数，则在替换字符串 replacement 的末尾放置一个问号，避免附加它们。 12# 由于最后加了个 ?，原来的请求参数将不会被追加到 rewrite 之后的 url 后面rewrite ^/users/(.*)$ /show?user=$1? last; if 指令if 可放在 server {}, location {} 中，语法为 if (condition) { ... }。 对给定的条件 condition 进行判断。如果为真，大括号内的 rewrite 指令将被执行，if 条件 (conditon) 可以是如下任何内容： 当表达式只是一个变量时，如果值为空或任何以 0 开头的字符串都会当做 false 直接比较变量和内容时，使用 = 或 !=。注意此处不要把相等当做赋值语句啊 ~ 区分大小写的正则匹配，~* 不区分大小写的正则匹配，!~、!~* 前面两者的非 检测文件是否存在，使用 -f(存在) 和 !-f(不存在) 检测路径是否存在，使用 -d(存在) 和 !-d(不存在) 后面判断可以是字符串也可是变量 检测文件、路径、或者链接文件是否存在，使用 -e(存在) 和 !-e(不存在) 后面判断可以是字符串也可是变量 检测文件是否为可执行文件，使用 -x(可执行) 和 !-x(不可执行) 后面判断可以是字符串也可是变量 注意，上面第1、2、3条被判断的必须是变量，第4、5、6、7则可以是变量也可是字符 12345678910111213141516171819202122232425set $variable &quot;0&quot;;if ($variable) &#123; # 不会执行，因为 &quot;0&quot; 为 false break; &#125;# 使用变量与正则表达式匹配 没有问题if ($http_host ~ &quot;^star\.igrow\.cn$&quot;) &#123; break; &#125;# 字符串与正则表达式匹配 报错if (&quot;star&quot; ~ &quot;^star\.igrow\.cn$&quot;) &#123; break; &#125;# 检查文件类的 字符串与变量均可if (!-f &quot;/data.log&quot;) &#123; break; &#125;if (!-f $filename) &#123; break; &#125; 12345678910111213141516171819202122232425262728293031if ($http_user_agent ~ MSIE) &#123; rewrite ^(.*)$ /msie/$1 break;&#125; //如果 UA 包含 &quot;MSIE&quot;，rewrite 请求到 /msid/ 目录下if ($http_cookie ~* &quot;id=([^;]+)(?:;|$)&quot;) &#123; set $id $1;&#125; // 如果 cookie 匹配正则，设置变量 $id 等于正则引用部分if ($request_method = POST) &#123; return 405;&#125; // 如果提交方法为 POST，则返回状态 405（Method not allowed）。return 不能返回 301，302if ($slow) &#123; limit_rate 10k;&#125; // 限速，$slow 可以通过 set 指令设置if (!-f $request_filename)&#123; break; proxy_pass http://127.0.0.1;&#125; // 如果请求的文件名不存在，则反向代理到 localhost。这里的 break 也是停止 rewrite 检查if ($args ~ post=140)&#123; rewrite ^ http://example.com/ permanent;&#125; // 如果 query string 中包含 &quot;post=140&quot;，永久重定向到 example.comlocation ~* \.(gif|jpg|png|swf|flv)$ &#123; valid_referers none blocked www.jefflei.com www.leizhenfang.com; if ($invalid_referer) &#123; return 404; &#125; // 防盗链&#125; 全局变量下面是可以用作 if 判断的全局变量： $args ： 这个变量等于请求行中的参数，同 $query_string $content_length ： 请求头中的 Content-length 字段。 $content_type ： 请求头中的 Content-Type 字段。 $document_root ： 当前请求在 root 指令中指定的值。 $host ： 请求主机头字段，否则为服务器名称。 $http_user_agent ： 客户端 agent 信息 $http_cookie ： 客户端 cookie 信息 $limit_rate ： 这个变量可以限制连接速率。 $request_method ： 客户端请求的动作，通常为 GET 或 POST。 $remote_addr ： 客户端的 IP 地址。 $remote_port ： 客户端的端口。 $remote_user ： 已经经过 Auth Basic Module 验证的用户名。 $request_filename ： 当前请求的文件路径，由 root 或 alias 指令与 uri 请求生成。 $scheme ： HTTP 方法（如 http，https）。 $server_protocol ： 请求使用的协议，通常是 HTTP/1.0 或 HTTP/1.1。 $server_addr ： 服务器地址，在完成一次系统调用后可以确定这个值。 $server_name ： 服务器名称。 $server_port ： 请求到达服务器的端口号。 $request_uri ： 包含请求参数的原始 uri，不包含主机名，如：”/foo/bar.php?arg=baz”。 $uri ： 不带请求参数的当前 uri，$uri 不包含主机名，如 ”/foo/bar.html”。 $document_uri ： 与 $uri 相同。 returnreturn 可放在 server {}, location {}, if (conditon) {} 中 123return code [text];return code URL;return URL; 该指令将结束执行直接返回 http 状态码到客户端. 支持的 http 状态码：200, 204, 400, 402-406, 408, 410, 411, 413, 416, 500-504，还有非标准的 444 状态码。 从 0.8.42 版本开始，return 语句可以指定重定向 url (状态码可以为如下几种 301,302,303,307)，也可以为其他状态码指定响应的文本内容，并且重定向的 url 和响应的文本可以包含变量。 有一种特殊情况，就是重定向的 url 可以指定为此服务器本地的 uri ，这样的话，nginx 会依据请求的协议 $scheme， server_name_in_redirect 和 port_in_redirect 自动生成完整的 url （此处要说明的是 server_name_in_redirect 和 port_in_redirect 指令是表示是否将 server 块中的 server_name 和 listen 的端口作为 redirect 用） 1234567891011121314# return code [text]; 返回 ok 给客户端location = /ok &#123; return 200 "ok";&#125;# return code URL; 临时重定向到 百度location = /redirect &#123; return 302 http://www.baidu.com;&#125;# return URL; 和上面一样 默认也是临时重定向location = /redirect &#123; return http://www.baidu.com;&#125; proxy_pass反向代理。在 proxy_pass 后面的 url 加 /，表示绝对根路径；如果没有 /，表示相对路径，把匹配的路径部分也给代理走。 最好 location 后面的 url 加 /，proxy_pass 后面的 url 也加 /。当然也视具体情况！ 123location /proxy &#123; proxy_pass https://www.baidu.com/;&#125; /proxy -&gt; https://www.baidu.com/ /proxys?wd=nginx -&gt; https://www.baidu.com/s?wd=nginx 123location /proxy &#123; proxy_pass https://www.baidu.com;&#125; /proxy -&gt; https://www.baidu.com/proxy -&gt; 404 -&gt; /search/error.html -&gt; 502 123location /proxy/ &#123; proxy_pass https://www.baidu.com/;&#125; /proxy -&gt; 301 -&gt; /proxy/ -&gt; https://www.baidu.com/ /proxy/s?wd=nginx -&gt; https://www.baidu.com/s?wd=nginx 123location /proxy/ &#123; proxy_pass https://www.baidu.com;&#125; /proxy -&gt; 301 -&gt; /proxy/ -&gt; https://www.baidu.com/proxy/ -&gt; 404 -&gt; /search/error.html -&gt; 502 正向代理与反向代理例子！！！ $proxy_host、$host 与 $http_host默认是 proxy_set_header Host $proxy_host; 123456789101112131415161718192021222324252627282930313233343536373839404142upstream myLocalhost &#123; server 127.0.0.1:8080; &#125;upstream baidu &#123; server www.baidu.com; &#125;server &#123; listen 80; server_name chuan.aty.sohuno.com; proxy_set_header Host $http_host; location /myLocalhost &#123; proxy_pass myLocalhost; &#125; location /baidu &#123; proxy_pass http://baidu; proxy_set_header Host $proxy_host; &#125; location /baidu2 &#123; proxy_pass http://baidu; proxy_set_header Host www.baidu.com; &#125; location /baidu3 &#123; proxy_pass http://baidu; proxy_set_header Host $http_host; &#125; location /baidu4 &#123; proxy_pass http://baidu; proxy_set_header Host $host; &#125; location /baidu5 &#123; proxy_pass http://baidu; proxy_set_header Host $host:$proxy_port; &#125;&#125; 当匹配到 /baidu 时，使用 baidu 处理，到 upstream 就匹配到 wwww.baidu.com，这里接转换成 IP 进行转发了。假如 www.baidu.com 是在另一台 nginx 下配置的，ip 为 10.22.10.116，则 $proxy_host 则对应为 10.22.10.116。此时相当于设置了 Host 为 10.22.10.116。如果想让 Host是 www.baidu.com，则进行如下设置： 1proxy_set_header Host www.baidu.com; 如果不想改变请求头 Host 的值，可以这样来设置： 1proxy_set_header Host $http_host; 但是，如果客户端请求头中没有携带这个头部，那么传递到后端服务器的请求也不含这个头部。这种情况下，更好的方式是使用 $host 变量——它的值在请求包含 Host 请求头时为 Host 字段的值，在请求未携带 Host 请求头时为虚拟主机的主域名： 1proxy_set_header Host $host; 此外，服务器名可以和后端服务器的端口一起传送： 1proxy_set_header Host $host:$proxy_port; 如果某个请求头的值为空，那么这个请求头将不会传送给后端服务器： 1proxy_set_header Accept-Encoding ""; $document_uri、$uri 与 $request_uri$document_uri 与 $uri 一样 $uri 指的是请求的文件和路径，不包含 ”?” 或者 ”#” 之类的东西 $request_uri 则指的是请求的整个字符串，包含了后面请求的东西（”?”、”#”等） 例如，请求地址：https://www.baidu.com/s?wd=nginx $uri：/s $request_uri：/s?wd=nginx upstreamnginx 负载均衡]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js 源码解析]]></title>
    <url>%2Fzh%2F2019%2F04%2F16%2F%E5%88%86%E4%BA%AB-Vue.js%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90-answershuto%2F</url>
    <content type="text"><![CDATA[Vue.js 源码解析。转。作者 answershuto。 Vue.js响应式原理Object.defineProperty 将数据data变成可观察（observable）的 代理 一是通过observe将所有数据变成observable。二是将_data上面的数据代理到vm上 Vue.js依赖收集做的是这样一件事：对于 data 中定义的某些变量，在实际模板中并没有被用到，修改这些变量时如何避免重新渲染模版？ ??? 从Vue.js源码角度再看数据绑定首先通过一次渲染操作触发Data的getter（这里保证只有视图中需要被用到的data才会触发getter）进行依赖收集，这时候其实Watcher与data可以看成一种被绑定的状态（实际上是data的闭包中有一个Deps订阅者，在修改的时候会通知所有的Watcher观察者），在data发生变化的时候会触发它的setter，setter通知Watcher，Watcher进行回调通知组件重新渲染的函数，之后根据diff算法来决定是否发生视图的更新。 Vue在初始化组件数据时，在生命周期的beforeCreate与created钩子函数之间实现了对data、props、computed、methods、events以及watch的处理。 Observer为数据加上响应式属性进行双向绑定。如果是对象则进行深度遍历，为每一个子对象都绑定上方法，如果是数组则为每一个成员都绑定上方法。 如果是修改一个数组的成员，该成员是一个对象，那只需要递归对数组的成员进行双向绑定即可。但这时候出现了一个问题：如果我们进行pop、push等操作的时候，push进去的对象根本没有进行过双向绑定，更别说pop了，那么我们如何监听数组的这些变化呢？ Vue.js提供的方法是重写push、pop、shift、unshift、splice、sort、reverse这七个数组方法。 看晕了，想睡觉zzzz Vue.js事件机制四个事件API，分别是$on，$once，$off，$emit。 VNode节点(Vue.js实现)]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PNG图片压缩原理解析]]></title>
    <url>%2Fzh%2F2019%2F04%2F16%2F%E5%88%86%E4%BA%AB-PNG%E5%9B%BE%E7%89%87%E5%8E%8B%E7%BC%A9%E5%8E%9F%E7%90%86%E8%A7%A3%E6%9E%90-airuikun%2F</url>
    <content type="text"><![CDATA[PNG图片压缩原理解析。转。作者 airuikun。 什么是 PNG ？PNG 的全称叫便携式网络图型（Portable Network Graphics）是目前最流行的网络传输和展示的图片格式，原因有如下几点： 无损压缩：PNG 图片采取了基于 LZ77 派生算法对文件进行压缩，使得它压缩比率更高，生成的文件体积更小，并且不损失数据。 体积小：它利用特殊的编码方法标记重复出现的数据，使得同样格式的图片，PNG 图片文件的体积更小。网络通讯中因受带宽制约，在保证图片清晰、逼真的前提下，优先选择 PNG 格式的图片。 支持透明效果：PNG 支持对原图像定义 256 个透明层次，使得图像的边缘能与任何背景平滑融合，这种功能是 GIF 和 JPEG 没有的。 PNG 类型PNG 图片主要有三个类型，分别为 PNG 8 / PNG 24 / PNG 32。 PNG8：PNG 8中的8，其实指的是8bits，相当于用2^8（2的8次方）大小来存储一张图片的颜色种类，2^8等于256，也就是说PNG 8能存储256种颜色，一张图片如果颜色种类很少，将它设置成PNG 8得图片类型是非常适合的。 PNG24：PNG 24中的24，相当于3乘以8 等于 24，就是用三个8bits分别去表示 R（红）、G（绿）、B（蓝）。R(0255),G(0255),B(0~255)，可以表达256乘以256乘以256=16777216种颜色的图片，这样PNG 24就能比PNG 8表示色彩更丰富的图片。但是所占用的空间相对就更大了。 PNG32：PNG 32中的32，相当于PNG 24 加上 8bits的透明颜色通道，就相当于R（红）、G（绿）、B（蓝）、A（透明）。R(0255),G(0255),B(0255),A(0255)。比PNG 24多了一个A（透明），也就是说PNG 32能表示跟PNG 24一样多的色彩，并且还支持256种透明的颜色，能表示更加丰富的图片颜色类型。 一类女神=PNG8：屌丝舔狗们见到第一类女神，顿时会觉得心情愉悦、笑逐颜开，屌丝发黑的印堂逐渐舒展，确认过眼神，是心动的感觉。 二类女神=PNG24：第二类女神开始厉害了，会给屌丝们一种菊花一紧、振聋发聩的心弦震撼，接触多了第二类女神能让屌丝每天精神抖擞，延年益寿。 三类女神=PNG32：在第三类女神面前，所有的语言都显得苍白无力。那是一种看了让屌丝上下通透、手眼通天的至尊级存在。超凡脱俗、天神下凡都不足以描摹她美色的二分之一。我曾经只有在梦里才见到过。 PNG 图片数据结构PNG 图片的数据结构其实跟 http 请求的结构很像，都是一个数据头，后面跟着很多的数据块，如： header -&gt; chunk -&gt; chunk -&gt; chunk -&gt; … 每一段十六进制编码就代表着一个特定的含义。 89504e470d0a1a0a：这个是 PNG 图片的头，所有的 PNG 图片的头都是这一串编码，图片软件通过这串编码判定这个文件是不是 PNG 格式的图片。 再 8 位是iHDR数据块的长度。 再 8 位是数据块的 type 再 8 位是图片的宽度 再 8 位是图片的高度 … 什么样的 PNG 图片更适合压缩颜色越单一，颜色值越少，压缩率就越大]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小菜前端的技术栈是如何规划和演进的]]></title>
    <url>%2Fzh%2F2019%2F04%2F16%2F%E5%88%86%E4%BA%AB-%E5%B0%8F%E8%8F%9C%E5%89%8D%E7%AB%AF%E7%9A%84%E6%8A%80%E6%9C%AF%E6%A0%88%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%84%E5%88%92%E5%92%8C%E6%BC%94%E8%BF%9B%E7%9A%84-Scott%2F</url>
    <content type="text"><![CDATA[小菜前端的技术栈是如何规划和演进的。转。作者 Scott。 一、团队管理首先说团队管理，这个是前提，没有配套的团队管理手段辅助，是很难单纯的让技术栈发生持续的好的变化，也很难将架构理念推进落地的，在团队管理这里我主要是分成四步走。 第一步 了解团队的长与短新加入到一个团队，尤其是成为资深工程师后新带领一个团队，除了埋头做事外，有一个很重要的事情要尽早做，那就是去了解团队，方式有很多，比如： 主动去看团队仓库里的历史代码，了解大家的编码水平，编程风格，工程维护的方式，架构的成熟度 与每个同学单独聊聊天，聊聊他对于一个技术的看法，对于业务上思考，对于自己和所处团队的认知 请大家去吃吃饭，听听大家都聊什么，玩什么，关注什么，每个人的气场和表达方式，在办公桌和餐桌上有什么不同 找服务端团队和业务团队的同学，问问他们对于前端团队的印象，对于合作童鞋的看法 在会议上抛出一些问题，观察大家的参与积极性和表述观点的深度 还可以一起去打游戏看电影，一起参加公司活动等等，这是一个比较粗的了解，我进团队后，也是挑了上面两三种方式对团队成员有了一个比较粗的摸底，看到了很多好的特征也看到了不少问题。 技术分享作为一个大家共同做的事情，让团队在这一件事情达成唯一的共识 - 技术团队影响力的提升和个人总结能力的提高。 第二步 鞭策团队完善内部短板所谓内部短板，就是完全是自己的锅的问题，比如发布系统不完善，比如代码不规范，比如工具不健全这些都是甩都别想甩出去的锅，有了第一步的总结归纳后，就可以在这些问题里面，优先挑选跟业务有强关系的问题重点突破。 开发上线流：工程骨架 -&gt; 组件安装 -&gt; Mock -&gt; 代码校验 -&gt; 打包测试 -&gt; 打包线上 -&gt; 推包 -&gt; 配置白名单 -&gt; 审核发布 第三步 推动团队迈向无主之地如果已经解决掉了团队的核心内部问题，接下来就可以把跟产品，运营、业务有关系的环节完善掉了，比如 App 在线上运行的异常监控这些，实际上在创业公司，一般是没有一个部门直接对它负责的，大家都焦点在业务上，那么这时候从前端团队手里出去的作品，理应由前端自己驱动自己来为它负责，这里我把线上运行时的监控单独作为一条线，它配合内部问题的 Mock 阶段的 GPM（GraphQL 数据聚合服务层），都是跨出了前端团队的职能，与其他团队产生了关系 为公司内三不管的无主之地做一些协同的工具和系统，这会给团队带来很多正向的口碑，同时也有技术的提升，最重要的是，在内部问题和外部协同上，一旦你成为发起者和驱动者，你的角色和身份就发生了变化，你既是产品经理也是项目经理，既是需求方也是业务方，对于个人的综合能力会有很大的提升，对于整个团队在公司内部的影响力提升也有帮助，在工作中部门之间互相帮助也打下了一些底子，这一点对于不善表达比较木讷的工程师团队很有意义。 第四步 鼓励团队技术与业务创新从前面的三步，大家可以看出我的套路，带团队往前走，比较稳的方式就是从内到外，从技术到跨团队事务到业务，最终也就是第四步，再回归到业务和技术的结合，来利用技术创新驱动业务，利用业务可能性倒逼技术突破，这虽然不是终极态，但对于工程师团队已经是一个非常可接受的状态了。 二、技术栈规划ReactJS VueJS NodeJS]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>分享</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[免费域名申请与使用]]></title>
    <url>%2Fzh%2F2019%2F03%2F17%2F%E5%85%8D%E8%B4%B9%E5%9F%9F%E5%90%8D%E7%94%B3%E8%AF%B7%E4%B8%8E%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[分享一下如何申请一个免费域名 域名申请在这个 freenom 页面上，注册登录 检查域名是否可用例如输入 zhouyu.com，检查是否可用。 当然一般是要钱的。 然后选一个免费的，如 zhouyu.cf 后缀名像游戏 cf 好记。免费域名只支持 http 不支持 https。 管理已选域名在这个 域名列表 页面上，管理域名 Manage -&gt; Management Tools -&gt; Nameservers -&gt; Use custom nameservers (enter below) 在 Nameserver 1 输入 F1G1NS1.DNSPOD.NET 在 Nameserver 2 输入 F1G1NS2.DNSPOD.NET 域名解析在这个 腾讯云 页面上，注册登录。 控制台 -&gt; 域名解析 -&gt; 添加解析 -&gt; 填写域名 zhouyu.cf 点击对应域名的解析按钮 -&gt; 快速添加网站 -&gt; 绑定对应主机/服务器的 IP 地址 一个 IP 可以对应多个域名，后期用 nginx 去管理。 以及在这个 dnspod 页面上，注册登录。 可用开启 D 监控，时刻查看域名状况。 购买主机/服务器上面域名解析需要绑定对应主机/服务器的 IP 地址，这需要购买了。当然也可以免费申请。 我们如果需要翻墙（爬梯子），看一些特殊的神奇的东西，会购买 vps 之类的东西，例如有这样一个网站 vultr。 购买后，我们就可用建自己的 centOS。 上面说的 nginx 就是在这 centOS 上安装管理。 More累了 睡觉]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>域名</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生存指南]]></title>
    <url>%2Fzh%2F2019%2F03%2F17%2F%E7%94%9F%E5%AD%98%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[瞎扯些要命题 — 生存指南 下次再说]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>人性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新生态推送服务前期调研]]></title>
    <url>%2Fzh%2F2019%2F01%2F30%2F%E6%96%B0%E7%94%9F%E6%80%81%E6%8E%A8%E9%80%81%E6%9C%8D%E5%8A%A1%E5%89%8D%E6%9C%9F%E8%B0%83%E7%A0%94%2F</url>
    <content type="text"><![CDATA[本文是对新生态推送服务前期调研的汇报。 利益相关，删除了]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[box-sizing]]></title>
    <url>%2Fzh%2F2018%2F12%2F28%2Fcss%5Bbox-sizing%5D%2F</url>
    <content type="text"><![CDATA[box-sizing，“盒子的大小”，顾名思义，这个属性影响的是盒模型。 适用于：所有接受 width 和 height 的元素。 继承性：无。 所以我们一般定义： 123456789101112// 元素的内边距和边框将在已设定的宽度和高度内进行绘制::before &#123; box-sizing: border-box;&#125;::after &#123; box-sizing: border-box;&#125;* &#123; box-sizing: border-box;&#125; 取值： content-box padding和border不被包含在定义的width和height之内。对象的实际宽度等于设置的width值和border、padding之和，即 ( Element width = width + border + padding ) 此属性表现为标准模式下的盒模型。 border-box padding和border被包含在定义的width和height之内。对象的实际宽度就等于设置的width值，即使定义有border和padding也不会改变对象的实际宽度，即 ( Element width = width ) 此属性表现为怪异模式下的盒模型。 content-box 是默认值。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[BFC]]></title>
    <url>%2Fzh%2F2018%2F12%2F28%2Fcss%5BBFC%5D%2F</url>
    <content type="text"><![CDATA[啥叫 BFC 啊？ 文档流我们先来了解一下文档流，或者定位方案。 文档流其实分为普通流、浮动流和定位流三种。 普通流 (normal flow)在普通流中，元素按照其在 HTML 中的先后位置至上而下布局，在这个过程中，行内元素水平排列，直到当行被占满然后换行，块级元素则会被渲染为完整的一个新行，除非另外指定，否则所有元素默认都是普通流定位，也可以说，普通流中元素的位置由该元素在 HTML 文档中的位置决定。 浮动流 (float flow)在浮动布局中，元素首先按照普通流的位置出现，然后根据浮动的方向尽可能的向左边或右边偏移，其效果与印刷排版中的文本环绕相似。 绝对定位流 (absolute positioning flow)绝对定位是 position: absolute; 或 position: fixed; position: absolute; 是相对向上查找的 position: relative; 父辈元素。 position: fixed; 是相对 viewpoint。 在绝对定位布局中，元素会整体脱离普通流，因此绝对定位元素不会对其兄弟元素造成影响，而元素具体的位置由绝对定位的坐标决定。 BFC 概念BFC，块格式化上下文（Block Formatting Context，BFC） 是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。 属于上述文档流中的普通流！ 具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素，并且 BFC 具有普通容器所没有的一些特性。 通俗一点来讲，可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。 触发或创建 BFC 根元素或包含根元素的元素 浮动元素（元素的 float 不是 none） 绝对定位元素（元素的 position 为 absolute 或 fixed） overflow 值不为 visible 的块元素 行内块元素（元素的 display 为 inline-block） 表格单元格（元素的 display为 table-cell，HTML表格单元格默认为该值） 表格标题（元素的 display 为 table-caption，HTML表格标题默认为该值） 匿名表格单元格元素（元素的 display为 table、table-row、 table-row-group、table-header-group、table-footer-group（分别是HTML table、row、tbody、thead、tfoot的默认属性）或 inline-table） display 值为 flow-root 的元素 contain 值为 layout、content或 strict 的元素 弹性元素（display为 flex 或 inline-flex元素的直接子元素） 网格元素（display为 grid 或 inline-grid 元素的直接子元素） 多列容器（元素的 column-count 或 column-width 不为 auto，包括 column-count 为 1） column-span 为 all 的元素始终会创建一个新的BFC，即使该元素没有包裹在一个多列容器中（标准变更，Chrome bug）。 BFC 特性或规则及应用 内部的Box会在垂直方向，一个接一个地放置； 我们平常说的盒子是由margin、border、padding、content组成的，实际上每种类型的四条边定义了一个盒子，分别是分别是margin box、border box、padding box、content box，这四种类型的盒子一直存在，即使他们的值为0。决定块盒在包含块中与相邻块盒的垂直间距的便是margin-box。 Box之间的距离虽然也可以使用padding来控制，但是此时实际上还是属于box内部里面，而且使用padding来控制的话就不能再使用border属性了。 其实就是我们平常所说的div一行一行块级放置的样式 同一个BFC下相邻块级元素的垂直方向外边距会发生折叠，即之前提到的margin折叠只发生在同一个BFC中； 浮动定位和清除浮动时只会应用于同一个BFC内的元素； 浮动不会影响其它BFC中元素的布局，而清除浮动只能清除同一BFC中在它前面的元素的浮动； BFC可以包含浮动元素—清除内部浮动后； BFC可以阻止元素被浮动元素覆盖，BFC的区域不会与float box重叠； 12&lt;div style="height: 100px;width: 100px;float: left;background: blue"&gt;我是一个左浮动的元素&lt;/div&gt;&lt;div style="width: 200px; height: 200px;background: red"&gt;我是一个没有设置浮动，也没有触发 BFC 元素&lt;/div&gt; 第二个元素有部分被浮动元素所覆盖，(但是文本信息不会被浮动元素所覆盖) 如果想避免元素被覆盖，可触第二个元素的 BFC 特性，在第二个元素中加入 overflow: hidden; 12&lt;div style="height: 100px;width: 100px;float: left;background: blue"&gt;我是一个左浮动的元素&lt;/div&gt;&lt;div style="width: 200px; height: 200px;background: red;overflow: hidden"&gt;我是一个没有设置浮动，也没有触发 BFC 元素&lt;/div&gt; 实现两列自适应布局； 12&lt;div style="height: 100px;width: 100px;float: left;background: blue"&gt;我是一个左浮动的元素&lt;/div&gt;&lt;div style="height: 200px;background: red;overflow: hidden"&gt;我是一个没有设置浮动，也没有触发 BFC 元素&lt;/div&gt; 左边的宽度固定，右边的内容自适应宽度(去掉上面右边内容的宽度) BFC 与 LayoutIE 作为浏览器中的奇葩，当然不可能按部就班的支持 BFC 标准，于是乎 IE 中有了 Layout 这个东西。Layout 和 BFC 基本是等价的，为了处理 IE 的兼容性，在需要触发 BFC 时，我们除了需要用触发条件中的 CSS 属性来触发 BFC，还需要针对 IE 浏览器使用 zoom: 1 来触发 IE 浏览器的 Layout。 参考： MDN-BFC 10 分钟理解 BFC 原理]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git相关]]></title>
    <url>%2Fzh%2F2018%2F10%2F26%2Fgit%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[Git 是一个免费的开源分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。 Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。 git doc https://git-scm.com/book/zh/v2/起步-初次运行-Git-前的配置 https://git-scm.com/book/zh/v2/Git-基础-获取-Git-仓库 https://git-scm.com/book/zh/v2/Git-基础-记录每次更新到仓库 https://git-scm.com/book/zh/v2/Git-基础-查看提交历史 https://git-scm.com/book/zh/v2/Git-基础-撤消操作 https://git-scm.com/book/zh/v2/Git-基础-远程仓库的使用 https://git-scm.com/book/zh/v2/Git-基础-打标签 https://git-scm.com/book/zh/v2/Git-分支-分支的新建与合并 https://git-scm.com/book/zh/v2/Git-分支-分支管理 https://git-scm.com/book/zh/v2/Git-分支-远程分支 https://git-scm.com/book/zh/v2/服务器上的-Git-生成-SSH-公钥 https://git-scm.com/book/zh/v2/GitHub-对项目做出贡献 12345678910111213git remote add upstream [url] # 将源版本库添加为一个远端，并命名为“upstream”（上游）git fetch upstream # 从远端抓取最新的内容git merge upstream/master # 将主分支的内容合并到你的分支中vim test.js # 增删改查文件，推送git add test.jsgit commit -m 'build: add test.js'git push 创建一个任务列表： 编写代码 编写所有测试程序 为代码编写文档 关于版本控制 VC版本控制是一种记录一个或若干文件内容变化，以便将来查阅特定版本修订情况的系统。 如果你是位图形或网页设计师，可能会需要保存某一幅图片或页面布局文件的所有修订版本（这或许是你非常渴望拥有的功能），采用版本控制系统（VCS）是个明智的选择。有了它你就可以将某个文件回溯到之前的状态，甚至将整个项目都回退到过去某个时间点的状态，你可以比较文件的变化细节，查出最后是谁修改了哪个地方，从而找出导致怪异问题出现的原因，又是谁在何时报告了某个功能缺陷等等。使用版本控制系统通常还意味着，就算你乱来一气把整个项目中的文件改的改删的删，你也照样可以轻松恢复到原先的样子。但额外增加的工作量却微乎其微。 本地版本控制系统 [Local Version Control Systems] LVCS复制整个项目，以改名加时间为备份。 123451. file-2018010101.md2. file-2018010102.md...3. file-2018010201.md... 其中最流行的一种叫做 RCS，现今许多计算机系统上都还看得到它的踪影。 甚至在流行的 Mac OS X 系统上安装了开发者工具包之后，也可以使用 rcs 命令。 它的工作原理是在硬盘上保存补丁集（补丁是指文件修订前后的变化）；通过应用所有的补丁，可以重新计算出各个版本的文件内容。 集中化的版本控制系统 [Centralized Version Control Systems] CVCS如何让在不同系统上的开发者协同工作？CVCS 就产生了。 CVS、Subversion[svn] 以及 Perforce 等，都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 好处是相较于老式的本地 LVCS 可以进行协同开发。但缺点是中央服务器的单点故障。如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。 分布式版本控制系统 [Distributed Version Control System] DVCS为了应对这种问题，DVCS 就面世了。 Git、Mercurial、Bazaar 以及 Darcs 等，客户端并不只提取最新版本的文件快照，而是把代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。 Git存储每个文件与初始版本的差异Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 快照流。 Git 近乎所有操作都是本地执行在无网情况也可以进行提交，只需要等待有网再上传即可。 Git 保证完整性Git 中所有数据在存储前都计算校验和，然后以校验和来引用。 这意味着不可能在 Git 不知情时更改任何文件内容或目录内容。 这个功能建构在 Git 底层，是构成 Git 哲学不可或缺的部分。 若你在传送过程中丢失信息或损坏文件，Git 就能发现。 Git 用以计算校验和的机制叫做 SHA-1 散列（hash，哈希）。 这是一个由 40 个十六进制字符（0-9 和 a-f）组成字符串，基于 Git 中文件的内容或目录结构计算出来。 三种状态Git 有三种状态，你的文件可能处于其中之一：已提交（committed）、已修改（modified）和已暂存（staged）。 已提交表示数据已经安全的保存在本地数据库中。 已修改表示修改了文件，但还没保存到数据库中。 已暂存表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。 三个工作区域三个工作区域的概念：Git 仓库（Git Repository）、工作目录（Working Directory）以及暂存区域（Staging Area）。 push: 工作目录 -&gt; 暂存区域 -&gt; Git 仓库 clone/fetch/merge: Git 仓库 -&gt; 工作目录 Git 仓库目录是 Git 用来保存项目的元数据和对象数据库的地方。这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。 工作目录是对项目的某个版本独立提取出来的内容。这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。 暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作’索引’，不过一般说法还是叫暂存区域。 基本的 Git 工作流程如下： 在工作目录中修改文件。 暂存文件，将文件的快照放入暂存区域。 提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。 命令行Mac OS 用户，使用 Terminal 或者 iTerm2 Windows 用户，使用 git-bash 安装 GitMac OS 用户 brew install git Windows 用户 http://git-scm.com/download/win 初次运行前的配置Git 自带一个 git config 的工具来帮助设置控制 Git 外观和行为的配置变量。 这些变量存储在三个不同的位置： /etc/gitconfig 文件: 包含系统上每一个用户及他们仓库的通用配置。 如果使用带有 –system 选项的 git config 时，它会从此文件读写配置变量。 ~/.gitconfig 或 ~/.config/git/config 文件：只针对当前用户。 可以传递 –global 选项让 Git 读写此文件。 当前使用仓库的 Git 目录中的 config 文件（就是 .git/config）：针对该仓库。 每一个级别覆盖上一级别的配置，所以 .git/config 的配置变量会覆盖 /etc/gitconfig 中的配置变量。 列出配置项1git config --list 修改或增加配置12git config --global user.name RainJoygit config --global user.email 1490079545@qq.com 12git config user.name RainJoygit config user.email 1490079545@qq.com 获取帮助123git --helpgit help xxxx 获取 git 仓库有两种取得 Git 项目仓库的方法。 第一种是：生成。在现有项目或目录下导入所有文件到 Git 中。 1234567891011git initgit add .git add LICENSE # 增加证书git commit -m 'init'git remote add origin git@github.com:zhouyu1993/zhouyu1993.github.io.gitgit push --set-upstream origin master 第二种是：克隆。从一个服务器克隆一个现有的 Git 仓库。 1git clone git@github.com:zhouyu1993/zhouyu1993.github.io.git git clone [url]克隆远程 Git 仓库 Git 支持许多数据传输协议。之前的例子使用的是 git:// 协议，不过你也可以用 http(s):// 或者 user@server:/path.git 表示的 SSH 传输协议。 使用 git:// 协议或者 SSH 传输协议，更安全！ git@[host]:[user-name]/[project-name].git 使用 http(s):// 协议 https://[host]/[user-name]/[project-name].git 检测当前文件状态1git status -s 查看已暂存和未暂存的修改（具体修改了什么地方）123git diffgit diff [filename] 撤销文件的修改1234567# 撤销单个文件git checkout [filename]# 撤销所有git checkout . 忽略文件.gitignore 文件 文件 .gitignore 的格式规范如下： 所有空行或者以 ＃ 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。 1touch .gitignore 查看库的整体提交记录1git log 从库中删除对某文件的控制1git rm --cached [filename] 查看库的远程地址1git remote -v 将本地项目提交到远程仓库1234567891011# 将所有修改过的工作文件提交暂存区git add .# 填写提交信息(message)git commit -m 'message'# 修改提交信息(message)git commit --amend# 上传git push 将远程仓库更新到本地项目推荐 fetch + merge1git fetch # 默认更新所有分支 1git merge # 合并冲突 1git pull 打标签12345678910111213# 打上标签并写备注信息git tag -lgit tag -a v0.1.0 -m "修改网页风格，打标签 2017/04/27"# 上传git push origin --tags# 删除本地标签git tag -d v0.1.0# 删除远程标签git push origin :refs/tags/v0.0.1 分支创建与合并12345678910111213141516# 本地创建新分支git branch [branche-name]# 切换到分支git checkout [branche-name]# 将第一次建立的新分支上传到远程仓库git add.git commit -m 'add branche-name'git push --set-upstream origin [branche-name]# 切回主支git checkout master# 将分支合并到主支git merge [branche-name] 管理分支查看当前分支信息1git branch -v 列出所有分支【本地和远程】1git branch -a 拉取远程分支1git checkout -b [branche-name] origin/[branche-name] 删除本地分支1git branch -d [branche-name] 删除远程分支1git push origin -d [branche-name] 提交空目录的方法只需要在目录下创建 .gitkeep 文件，然后在项目的 .gitignore 中设置不忽略 .gitkeep 让 git 对文件大小写敏感1git config core.ignorecase false 配置 SSHssh 1.检查本机是否有 SSH key 1cd ~/.ssh 如果 .ssh No such file or directory 12345cd ~mkdir .ssh# 接 2 如果正常进入, 查看是否有 *_rsa.pub 1ls -a # 或 ll -a 如果无, 则清空 12rm *# 接 2 如果有，检查是否可用, 接 3 2.重新设置 SSH sey 12345678910111213141516cd ~/.ssh# 填写库的登陆邮箱ssh-keygen -t rsa -C '1490079545@qq.com'# 有结果如下：Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa): #可不填直接回车# #如果填写，则重命名，例如 xiaomi_rsaCreated directory '/c/Users/Administrator/.ssh'. #创建id_rsa#Enter passphrase (empty for no passphrase): #可不填直接回车# #如果填写则是密码Enter same passphrase again: #可不填直接回车# #如果填写则是密码Your identification has been saved in /c/Users/Administrator/.ssh/id_rsa. #保存id_rsa#Your public key has been saved in /c/Users/Administrator/.ssh/id_rsa.pub. #创建id_rsa.pub## 配置 gitgit config --global user.name 'RainJoy' #name#git config --global user.email '1490079545@qq.com' #email#git config --list 3.在库的 Settings &gt; SSH key 对应 key 填写位置填写生成的 SSH key 12345# 复制 id_rsa.pub 内容，填写到相应位置cat ~/.ssh/id_rsa.pub# 或者pbcopy &lt; ~/.ssh/id_rsa.pub # 复制文件内容 4.测试 SSH key 是否设置成功 1234567891011ssh -T git@github.com# 有结果如下：Are you sure you want to continue connecting (yes/no)? # 这里一定输入 yes 不能直接回车，不然会报 Host key verification failed.Enter passphrase for key '/Users/xxx/.ssh/*_rsa': # 输入设置的密码ssh -T git@gitlab.com# 有结果如下：Are you sure you want to continue connecting (yes/no)? # 这里一定输入 yes 不能直接回车，不然会报 Host key verification failed.Enter passphrase for key '/Users/xxx/.ssh/*_rsa': # 输入设置的密码 以 SSH key 方式下载项目即可 1git clone git@github.com:zhouyu1993/zhouyu1993.github.io.git LICENSE 开源许可证http://www.ruanyifeng.com/blog/2011/05/how_to_choose_free_software_licenses.html MIT 或 Apache]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>管理工具</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript算法]]></title>
    <url>%2Fzh%2F2018%2F10%2F08%2FJavaScript%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[算法 (Algorithm) 是解决特定问题求解步骤的描述，在计算机中表现为指令的有序序列，并且每条指令表示一个或多个操作。对于给定的问题是可以有多种算法进行解决的。 没有通用的算法。就跟没有包治百病的药一样。现实世界的问题千奇百怪，解决问题的算法当然也是千变万化的。 时间复杂度和空间复杂度参考 为什么需要复杂度分析？ 学习数据和算法就是为了解“快”和“省”的问题，也就是如何设计你的代码才能使运算效率更快，占用空间更小。那如何来计算代码执行效率呢？这里就会用到复杂度分析。 虽然我们可以用代码准确的计算出执行时间，但是这也会有很多局限性。 数据规模的不同会直接影响到测试结果。比如说同一个排序算法，排序顺序不一样，那么最后的计算效率的结果也会不一样；如果恰好已经是排序好的了数组，那么执行时间就会更短。又比如说如果数据规模比较小的话，测试结果可能也无法反应算法的性能。 测试的环境不同也会影响到测试结果。比如说同一套代码分别在 i3 和 i7 处理器上进行测试，那么 i7 上的测试时间肯定会比 i3 上的短。 所以需要一个不用准确的测试结果来衡量，就可以粗略地估计代码执行时间的方法。这就是复杂度分析。 大 O 复杂度表示法1234567function total (n) &#123; // 1 var sum = 0; // 2 for (var i = 0; i &lt; n; i ++) &#123; // 3 sum += i + 1; // 4 &#125; return sum;&#125; 我们假设每行代码执行的时间都一样，记做 t，那么上面的函数中的第 2 行需要 1 个 t 的时间，第 3 行 和 第 4 行分别需要 n 个 t 的时间，那么这段代码总的执行时间为 (2n+1)*t。 123456789function total (n) &#123; // 1 var sum = 0; // 2 for (var i = 0; i &lt; n; i ++) &#123; // 3 for (var j = 0; j &lt; n; j ++) &#123; // 4 sum += i + j + 1; // 5 &#125; &#125; return sum;&#125; 第 2 行需要一个 t 的时间，第 3 行需要 n 个 t 的时间，第 4 行和第 5 行分别需要 n^2 个的时间，那么这段代码总的执行时间为 (2n^2+n+1)*t 的时间。 从数学角度来看，我们可以得出个规律：代码的总执行时间 T(n) 与每行代码的执行次数成正比： T(n) = O(f(n)) 在这个公式中，T(n) 表示代码的执行时间；n 表示数据规模的大小；f(n) 表示每行代码执行的次数总和；O 表示代码的执行时间 T(n) 与 f(n) 表达式成正比。 所以上边两个函数的执行时间可以标记为 T(n) = O(2n+1) 和 T(n) = O(2n^2+n+1)。这就是大 O 时间复杂度表示法，它不代表代码真正的执行时间，而是表示代码随数据规模增长的变化趋势，简称时间复杂度。 而且当 n 很大时，我们可以忽略常数项，只保留一个最大量级即可。所以上边的代码执行时间可以简单标记为 T(n) = O(n) 和 T(n) = O(n^2)。 时间复杂度分析 只关注循环执行次数最多的一段代码 1234567function total (n) &#123; // 1 var sum = 0; // 2 for (var i = 0; i &lt; n; i ++) &#123; // 3 sum += i + 1; // 4 &#125; return sum;&#125; 只有第 3 行和第 4 行是执行次数最多的，分别执行了 n 次，那么忽略常数项，所以此段代码的时间复杂度就是 O(n)。 加法法则：总复杂度等于量级最大的那段代码的复杂度 1234567891011121314151617181920function total (n) &#123; var sum = 0; for (var i = 0; i &lt; n; i ++) &#123; for (var j = 0; j &lt; n; j ++) &#123; sum += i + j + 1; &#125; &#125; var sum2 = 0; for (var i = 0; i &lt; 1000; i ++) &#123; sum2 += i; &#125; var sum3 = 0; for (var i = 0; i &lt; n; i ++) &#123; sum3 += i; &#125; return sum;&#125; 我们先分别分析每段 for 循环的时间复杂度，再取他们中最大的量级来作为整段代码的时间复杂度。 第一段 for 循环的时间复杂度为 O(n^2)。 第二段 for 循环执行了 1000 次，是个常数量级，尽管对代码的执行时间会有影响，但是当 n 无限大的时候，就可以忽略。因为它本身对增长趋势没有影响，所以这段代码的时间复杂度可以忽略。 第三段 for 循环的时间复杂度为 O(n)。 总上，取最大量级，所以整段代码的时间复杂度为 O(n^2)。 乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积 1234567891011121314151617function fun (n) &#123; var sum = 0; for (var i = 0; i &lt; n; i ++) &#123; sum += i; &#125; return sum;&#125;function total (n) &#123; var sum = 0; for (var i = 0; i &lt; n; i ++) &#123; sum += fun(i); &#125; return sum;&#125; 单独看 total 函数的时间复杂度就是为 T1(n) = O(n)，但是考虑到 fun 函数的时间复杂度也为 T2(n) = O(n)。 所以整段代码的时间复杂度为 T(n) = T1(n) * T2(n) = O(n) * O(n) = O(n^2)。 几种常见的时间复杂度分析只看最高量级的复杂度，效率是递减的 O(1) 常数阶 O(logn) 对数阶 O(n) 线性阶 O(n^2) 平方阶 O(n^3) 立方阶 O(2^n) 指数阶 O(n!) 阶乘阶 粗略的分为两类，多项式量级和非多项式量级。其中，非多项式量级只有两个：O(2^n) 和 O(n!) 增长率: 当数据规模 n 增长时，非多项式量级的执行时间就会急剧增加，所以，非多项式量级的代码算法是非常低效的算法。 思考题目：sum = 1+2+3+...+n ，计算 sum 的值。 1234567function total (n) &#123; // 1 var sum = 0; // 2 for (var i = 0; i &lt; n; i ++) &#123; // 3 sum += i + 1; // 4 &#125; return sum;&#125; 时间复杂度是 O(n)，能不能优化呢？ 利用【等差数列求和公式】：Sn = n(a1 + an)/2 1234function total (n) &#123; // 1 var sum = n * (1 + n) / 2; // 2 return sum;&#125; 时间复杂度仅仅为 O(1)，在数据规模比较庞大的时候，是不是明显效率更高! 空间复杂度分析空间复杂度的话和时间复杂度类似推算即可。 所谓空间复杂度就是表示算法的存储空间和数据规模之间的关系。 1234567function initArr () &#123; var arr = [] for (var i = 0; i &lt; n; i ++) &#123; arr[i] = i &#125; return arr&#125; 根据时间复杂度的推算，忽略掉常数量级，每次数组赋值都会申请一个空间存储变量，所以此函数会申请 n 个的空间，复杂度为 O(n)。 常见的空间复杂度只有 O(1)、O(n)、O(n2)。其他的话很少会用到。 总结复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，一个表示执行的快慢，一个表示内存的消耗，用来分析算法执行效率与数据规模之间的增长关系，可以粗略的表示，越高阶复杂度的算法，执行效率越低。 数据结构和算法动态可视化数据结构和算法动态可视化 排序排序是一个非常经典的问题，它以一定的顺序对一个数组（或一个列表）中的项进行重新排序（可以进行比较，例如整数，浮点数，字符串等）（增加，非递减，递减， 增加，词典等）。 有许多不同的排序算法，每个都有其自身的优点和局限性。 排序通常被用作各种计算机科学课程中的介绍性问题，以展示一系列算法思想。 Array.prototype.sort()The sort() method sorts the elements of an array in place and returns the array. The default sort order is built upon converting the elements into strings, then comparing their sequences of UTF-16 code units values. The time and space complexity of the sort cannot be guaranteed as it is implementation dependent. sort() 方法用原地算法对数组的元素进行排序，并返回数组。排序算法现在是稳定的。默认排序顺序是根据字符串Unicode码点。 由于它取决于具体实现，因此无法保证排序的时间和空间复杂性。 sort(compareFunction) 如果没有指明 compareFunction，那么元素会按照转换为的字符串的诸个字符的Unicode位点进行排序。 如果指明了 compareFunction，那么数组会按照调用该函数的返回值排序。即 a 和 b 是两个将要被比较的元素： 如果 compareFunction(a, b) 小于 0，那么 a 会被排列到 b 之前 如果 compareFunction(a, b) 等于 0， a 和 b 的相对位置不变（CMAScript 标准并不保证这一行为，而且也不是所有浏览器都会遵守,例如 Mozilla 在 2003 年之前的版本） 如果 compareFunction(a, b) 大于 0，那么 b 会被排列到 a 之前 compareFunction(a, b) 必须总是对相同的输入返回相同的比较结果，否则排序的结果将是不确定的（利用这一特性，可实现随机排序） compareFunction 可能需要对元素做多次映射以实现排序，尤其当 compareFunction 较为复杂，且元素较多的时候，某些 compareFunction 可能会导致很高的负载。使用 map 辅助排序将会是一个好主意。基本思想是首先将数组中的每个元素比较的实际值取出来，排序后再将数组恢复。 123456789[3, 2, 1].sort() // [1, 2, 3][3, 2, 11].sort() // [11, 2, 3] 这里说明如果没有指明 compareFunction，那么元素会按照转换为的字符串的诸个字符的Unicode位点进行排序。['3', '2', '11'].sort()。'11' &lt; '2' &lt; '3'[3, 2, 11].sort((a, b) =&gt; &#123; return a - b&#125;) // [2, 3, 11]['c', 'b', 'a'].sort() sort() 方法如何实现排序？ 12345678910111213141516var arr = [3, 1, 2]arr.sort((a, b) =&gt; &#123; console.log(arr, a, b) return a - b&#125;)/*** 控制台输出 [3, 1, 2] 1 3 [3, 1, 2] 2 1 [1, 3, 2] 2 3 [1, 3, 2] 2 1 [1, 2, 3]*/ a 相当于 next，b 相当于 prev。 第一次，数组 [3, 1, 2]，初始数组。1 和 3 比较，1 - 3 &lt; 0，1 要排列到 3 之前，需要调整。 第二次，数组 [3, 1, 2]，数组没变。2 和 1 比较，2 - 1 &gt; 0，1 要排列到 2 之前，不需要调整。 第三次，数组 [1, 3, 2]，数组变了，说明在上一轮比较结束后调整了位置。3 和 1 不用比较，直接跳过。2 和 3 比较，3 - 2 &gt; 0，2 要排列到 3 之前，需要调整。 第四次，数组 [1, 3, 2]，数组没变。2 和 1 比较，2 - 1 &gt; 0，1 要排列到 2 之前，不需要调整。 比较结束，数组 [1, 2, 3]。 sort() 好像是冒泡和插入两种方式结合进行排序的！ 十大经典排序算法https://github.com/hustcc/JS-Sorting-Algorithm https://github.com/Wscats/CV/issues/13 http://bubkoo.com/tags/algorithm/ 冒泡排序算法步骤： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较 1234567891011121314151617function bubbleSort (arr) &#123; const len = arr.length for (let i = 0; i &lt; len - 1; i ++) &#123; for (let j = 0; j &lt; len - 1 - i; j ++) &#123; // 内循环，相邻元素，两两对比 if (arr[j] &gt; arr[j + 1]) &#123; // 元素交换，左小右大 const temp = arr[j] arr[j] = arr[j + 1] arr[j + 1] = temp &#125; &#125; &#125; return arr&#125; 分析：冒泡排序，可以看成三个规则的组合： 外层 for 循环 内层 for 循环 最内层的 swap 时间复杂度为：O(n) * O(n) * O(1) = O(n^2) 最快：当输入的数据已经是正序时(都已经是正序了，我还要你冒泡排序有何用啊)。 最慢：当输入的数据是反序时(写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗)。 选择排序算法步骤： 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。 重复第二步，直到所有元素均排序完毕。 12345678910111213141516171819202122function selectionSort(arr) &#123; const len = arr.length for (let i = 0; i &lt; len - 1; i ++) &#123; let minIndex = i // 最小数的索引，每次初始化为 i for (let j = i + 1; j &lt; len; j ++) &#123; // 内循环，寻找最小数 if (arr[j] &lt; arr[minIndex]) &#123; // 将最小数的索引保存 minIndex = j &#125; &#125; // 元素交换，修正本轮寻找到的最小数 const temp = arr[i] arr[i] = arr[minIndex] arr[minIndex] = temp &#125; return arr&#125; 分析：选择排序，可以看成两个规则的组合： 外层 for 循环 内层 for 循环 每次挑选出最小的数，不停往前堆放 时间复杂度为：O(n) * O(n) = O(n^2) 插入排序算法步骤： 将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。 从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。） 123456789101112131415161718192021222324function insertionSort (arr) &#123; const len = arr.length let prevIndex, current // 将第一(0)个数看做一个有序序列，把第二(1)个元素到最后一个元素当成是未排序序列 for (let i = 1; i &lt; len; i ++) &#123; prevIndex = i - 1 // 有序序列的最后一个数的索引 current = arr[i] // 未排序序列的第一个元素 // 用未排序序列的第一个元素，与有序序列比较，从右到左 while (prevIndex &gt;= 0 &amp;&amp; arr[prevIndex] &gt; current) &#123; // 向右移位，留出待插入的位置 arr[preIndex + 1] = arr[prevIndex] prevIndex -- &#125; // 找到最终待插入的位置，插入元素 arr[preIndex + 1] = current &#125; return arr&#125; 时间复杂度为：O(n) * O(n) = O(n^2) 希尔排序也称递减增量排序算法，是插入排序的一种更高效的改进版本。 算法步骤： 选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1； 按增量序列个数 k，对序列进行 k 趟排序； 每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。 1234567891011121314151617181920212223242526function shellSort (arr) &#123; const len = arr.length let gap = 1 while (gap &lt; len / 3) &#123; // 动态定义间隔序列 gap = gap * 3 + 1 &#125; for (gap; gap &gt; 0; gap = Math.floor(gap / 3)) &#123; for (let i = gap; i &lt; len; i++) &#123; const temp = arr[i] let j = i - gap for(j; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= gap) &#123; arr[j + gap] = arr[j] &#125; arr[j + gap] = temp &#125; &#125; return arr&#125; 归并排序采用分治法(Divide and conquer) 分而治之。 两种方法： 自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）； 自下而上的迭代； 算法步骤： 申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列； 设定两个指针，最初位置分别为两个已经排序序列的起始位置； 比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置； 重复步骤 3 直到某一指针达到序列尾； 将另一序列剩下的所有元素直接复制到合并序列尾。 123456789101112131415161718192021222324252627282930313233function merge (left, right) &#123; const result = [] while (left.length &amp;&amp; right.length) &#123; if (left[0] &lt;= right[0]) &#123; result.push(left.shift()) &#125; else &#123; result.push(right.shift()) &#125; &#125; while (left.length) result.push(left.shift()) while (right.length) result.push(right.shift()) return result&#125;function mergeSort (arr) &#123; // 采用自上而下的递归方法 const len = arr.length if (len &lt; 2) return arr const middle = Math.floor(len / 2) const left = arr.slice(0, middle) const right = arr.slice(middle) return merge(mergeSort(left), mergeSort(right))&#125; 时间复杂度为：O(nlogn) 从分治算法到 MapReduce 快速排序使用分治法(Divide and conquer)策略来把一个串行(list)分为两个子串行(sub-lists)。 分而治之。 本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。 快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(nlogn) 的排序算法表现要更好。 算法步骤： 从数列中挑出一个元素，称为 “基准”(pivot); 重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面(相同的数可以到任一边)。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区(partition)操作； 递归地(recursive)把小于基准值元素的子数列和大于基准值元素的子数列排序； 递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代(iteration)中，它至少会把一个元素摆到它最后的位置去。 代码实现12345678910111213141516171819202122232425262728293031323334353637383940function swap (arr, i, j) &#123; const temp = arr[i] arr[i] = arr[j] arr[j] = temp&#125;function partition (arr, left ,right) &#123; // 分区操作 // 设定基准值(pivot) const pivot = left let index = pivot + 1 for (let i = index; i &lt;= right; i++) &#123; if (arr[i] &lt; arr[pivot]) &#123; swap(arr, i, index) index ++; &#125; &#125; swap(arr, pivot, index - 1) return index - 1&#125;function quickSort (arr, left, right) &#123; const len = arr.length left = typeof left != 'number' ? 0 : left, right = typeof right != 'number' ? len - 1 : right if (left &lt; right) &#123; const partitionIndex = partition(arr, left, right) quickSort(arr, left, partitionIndex - 1) quickSort(arr, partitionIndex + 1, right) &#125; return arr&#125; [left, right) 代表区间，从 left 到 right 之间进行排序！ 堆排序 {没搞懂}利用堆这种数据结构所设计的一种排序算法。 堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 堆排序可以说是一种利用堆的概念来排序的选择排序。 分为两种方法： 大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列； 小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列； 堆排序的平均时间复杂度为 Ο(nlogn)。 算法步骤： 创建一个堆 H[0……n-1]； 把堆首（最大值）和堆尾互换； 把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置； 重复步骤 2，直到堆的尺寸为 1。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748var len // 因为声明的多个函数都需要数据长度，所以把 len 设置成为全局变量function swap (arr, i, j) &#123; var temp = arr[i] arr[i] = arr[j] arr[j] = temp&#125;function heapify (arr, i) &#123; // 堆调整 var left = 2 * i + 1, right = 2 * i + 2, largest = i if (left &lt; len &amp;&amp; arr[left] &gt; arr[largest]) &#123; largest = left &#125; if (right &lt; len &amp;&amp; arr[right] &gt; arr[largest]) &#123; largest = right &#125; if (largest != i) &#123; swap(arr, i, largest) heapify(arr, largest) &#125;&#125;function buildMaxHeap (arr) &#123; // 建立大顶堆 len = arr.length; for (var i = Math.floor(len / 2); i &gt;= 0; i --) &#123; heapify(arr, i); &#125;&#125;function heapSort (arr) &#123; buildMaxHeap(arr) for (var i = arr.length - 1; i &gt; 0; i --) &#123; swap(arr, 0, i); len --; heapify(arr, 0); &#125; return arr;&#125; 计数排序 {没搞懂}核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。 必须知道最大值。。。 123456789101112131415161718192021222324function countingSort (arr, maxValue) &#123; var bucket = new Array(maxValue + 1), sortedIndex = 0, arrLen = arr.length, bucketLen = maxValue + 1; for (var i = 0; i &lt; arrLen; i ++) &#123; if (!bucket[arr[i]]) &#123; bucket[arr[i]] = 0; &#125; bucket[arr[i]] ++; &#125; for (var j = 0; j &lt; bucketLen; j ++) &#123; while (bucket[j] &gt; 0) &#123; arr[sortedIndex++] = j; bucket[j] --; &#125; &#125; return arr;&#125; 桶排序 {没搞懂}桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。 为了使桶排序更加高效，我们需要做到这两点： 在额外空间充足的情况下，尽量增大桶的数量 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中 同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。 最快：当输入的数据可以均匀的分配到每一个桶中。 最慢：当输入的数据被分配到了同一个桶中。 1234567891011121314151617181920212223242526272829303132333435363738function bucketSort (arr, bucketSize) &#123; if (arr.length === 0) return arr var i var minValue = arr[0] var maxValue = arr[0] for (i = 1; i &lt; arr.length; i ++) &#123; if (arr[i] &lt; minValue) &#123; minValue = arr[i] // 输入数据的最小值 &#125; else if (arr[i] &gt; maxValue) &#123; maxValue = arr[i] // 输入数据的最大值 &#125; &#125; // 桶的初始化 var DEFAULT_BUCKET_SIZE = 5 // 设置桶的默认数量为 5 bucketSize = bucketSize || DEFAULT_BUCKET_SIZE var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1 var buckets = new Array(bucketCount) for (i = 0; i &lt; buckets.length; i ++) &#123; buckets[i] = [] &#125; // 利用映射函数将数据分配到各个桶中 for (i = 0; i &lt; arr.length; i ++) &#123; buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]) &#125; arr.length = 0 for (i = 0; i &lt; buckets.length; i ++) &#123; insertionSort(buckets[i]) // 对每个桶进行排序，这里使用了插入排序 for (var j = 0; j &lt; buckets[i].length; j++) &#123; arr.push(buckets[i][j]) &#125; &#125; return arr&#125; 基数排序 {没搞懂}基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。 123456789101112131415161718192021222324252627// LSD Radix Sortvar counter = []function radixSort (arr, maxDigit) &#123; var mod = 10 var dev = 1 for (var i = 0; i &lt; maxDigit; i ++, dev *= 10, mod *= 10) &#123; for (var j = 0; j &lt; arr.length; j ++) &#123; var bucket = parseInt((arr[j] % mod) / dev) if (counter[bucket] == null) &#123; counter[bucket] = [] &#125; counter[bucket].push(arr[j]) &#125; var pos = 0 for (var j = 0; j &lt; counter.length; j ++) &#123; var value = null if (counter[j] != null) &#123; while ((value = counter[j].shift()) != null) &#123; arr[pos ++] = value &#125; &#125; &#125; &#125; return arr&#125; 基数排序 vs 计数排序 vs 桶排序这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异： 基数排序：根据键值的每位数字来分配桶； 计数排序：每个桶只存储单一键值； 桶排序：每个桶存储一定范围的数值； 时间换空间以及空间换时间两个数字进行交换 12345678910111213// 时优 运用空间而减少了时间的使用function swap (a, b) &#123; var temp = a a = b b = temp&#125;// 空优 运用时间而减少了空间的使用function swap (a, b) &#123; a = a + b b = a - b a = a - b&#125; 数组去重，也是一个典型的用空间换时间的例子 1234567891011121314function unique (arr) &#123; var obj = &#123;&#125; var result = [] for (var i in arr) &#123; if(!obj[arr[i]]) &#123; obj[arr[i]] = true result.push(arr[i]) &#125; &#125; return result&#125; 未完 判断一个单词是否是回文？回文是指把相同的词汇或句子，在下文中调换位置或颠倒过来，产生首尾回环的情趣，叫回文，也叫回环。比如 mamam redivider。 其实考的是，如何将字符串逆向排序，反转/颠倒？ 1234567function reverse (str) &#123; // ...&#125;function isPalindrome (str) &#123; return str === reverse(str)&#125; 利用数组 reverse 方法字符串转数组 -&gt; 数组 reverse -&gt; 数组转字符串 123456789function reverse (str) &#123; console.log('开始', +new Date()) const reverseStr = [...str].reverse().join('') // str.split('').reverse().join('') console.log('结束', +new Date()) return reverseStr&#125; 利用数组 reduceRight 方法字符串转数组 -&gt; 数组 reduceRight 数组 reduce(function(accumulator, currentValue, currentIndex, array), initValue) 、reduceRight(function(accumulator, currentValue, currentIndex, array), initValue) 接收 2 个参数。对于空数组是不会执行回调函数的。 function(accumulator, currentValue, currentIndex, array) 是必须。数组遍历执行的回调函数。 initValue 是可选。传递给函数的初始值。如果有这个参数，那么第一个 accumulator 等于 initialValue，并且 currentValue 等于数组中的第一个值；如果没有这个参数，那么第一个 accumulator 等于数组中的第一个值，并且 currentValue 等于数组中的第二个值。如果是是数组累加器，不要写 initValue 为 0，这样可以减少一次遍历，0 的累加也没有意义。 reduce 是顺序，reduceRight 是逆序。 123456789function reverse (str) &#123; console.log('开始', +new Date()) const reverseStr = [...str].reduceRight((prev, curr) =&gt; prev + curr) console.log('结束', +new Date()) return reverseStr&#125; 利用 for 循环123456789101112function reverse (str) &#123; console.log('开始', +new Date()) let reverseStr = '' for (let i = str.length - 1; i &gt;= 0; i --) &#123; reverseStr += str[i] &#125; console.log('结束', +new Date()) return reverseStr&#125; 利用字符串 slice 加递归复杂且耗时 123456789function reverse (str) &#123; console.log('开始', +new Date()) const reverseStr = str &amp;&amp; (reverse(str.slice(1)) + str[0]) console.log('结束', +new Date()) return reverseStr&#125; 数组去重利用 Set123456789function unique (arr) &#123; console.log('开始', +new Date()) const uniqueArr = [...new Set(arr)] console.log('结束', +new Date()) return uniqueArr&#125; 利用 Object 的 key 唯一性12345678910111213141516function unique (arr) &#123; console.log('开始', +new Date()) const obj = &#123;&#125; const uniqueArr = [] for (let key of arr) &#123; if (!obj[key]) &#123; obj[key] = true uniqueArr.push(key) &#125; &#125; console.log('结束', +new Date()) return uniqueArr&#125; 12345678910111213function unique (arr) &#123; console.log('开始', +new Date()) const obj = &#123;&#125; for (let key of arr) &#123; if (!obj[key]) obj[key] = true &#125; const uniqueArr = Object.keys(obj) console.log('结束', +new Date()) return uniqueArr&#125; 利用数组的 indexOf123456789101112function unique (arr) &#123; console.log('开始', +new Date()) const uniqueArr = [] for (let key of arr) &#123; if (uniqueArr.indexOf(key) === -1) uniqueArr.push(key) &#125; console.log('结束', +new Date()) return uniqueArr&#125; 统计一个字符串出现最多的字母这里需要统计重复次数，并求最大值。类似的求最小值。 利用 Object 的 key 唯一性123456789101112131415161718192021222324function findMaxDuplicateChar (arr) &#123; console.log('开始', +new Date()) const obj = &#123;&#125; for (let key of arr) &#123; if (!obj[key]) &#123; obj[key] = 1 &#125; else &#123; obj[key] ++ &#125; &#125; let maxChar = '', maxValue = 1 for (let key in obj) &#123; const value = obj[key] if (value &gt; maxValue) &#123; maxChar = key maxValue = value &#125; &#125; console.log('结束', +new Date()) return maxChar&#125; 不借助临时变量，进行两个整数的交换这种问题非常巧妙，需要大家跳出惯有的思维，利用 a , b进行置换。 主要是利用 + - 去进行运算，类似 a = a + (b - a) 实际上等同于最后的 a = b 12345function swap (a, b) &#123; a = a + b b = a - b a = a - b&#125; 未完]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[取值与单位]]></title>
    <url>%2Fzh%2F2018%2F09%2F11%2Fcss%5B%E5%8F%96%E5%80%BC%E4%B8%8E%E5%8D%95%E4%BD%8D%5D%2F</url>
    <content type="text"><![CDATA[取值与单位 长度值与单位长度取值 长度取值 版本 描述 &lt;length&gt; CSS2 &lt;number&gt;接长度单位 123456&lt;number&gt;接长度单位。特殊值0可以省略单位。例如：margin:0px可以写成margin:0一些属性可能允许有负长度值，或者有一定的范围限制。如果不支持负长度值，那应该变换到能够被支持的最近的一个长度值。长度单位包括包括：相对单位和绝对单位。相对长度单位包括有： em, ex, ch, rem, vw, vh, vmax, vmin绝对长度单位包括有： cm, mm, q, in, pt, pc, px 长度单位文本相对长度单位 长度单位 版本 描述 em CSS1 相对于当前对象内文本的字体尺寸 ex CSS1 相对于字符“x”的高度。通常为字体高度的一半 ch CSS3 数字“0”的宽度 rem CSS3 相对于根元素(即html元素)font-size计算值的倍数 % CSS1 百分比 视口相对长度单位 长度单位 版本 描述 vw CSS3 相对于视口的宽度。视口被均分为100单位的vw vh CSS3 相对于视口的高度。视口被均分为100单位的vh vmax CSS3 相对于视口的宽度或高度，总是相对于大的那个。视口的宽度或高度被均分为100单位的vmax vmin CSS3 相对于视口的宽度或高度，总是相对于小的那个。视口的宽度或高度被均分为100单位的vmin 绝对长度单位 长度单位 版本 描述 cm CSS1 厘米 mm CSS1 毫米 q CSS1 1/4毫米（quarter-millimeters）; 1q = 0.25mm in CSS1 英寸（inches）; 1in = 2.54cm pt CSS1 点（points）; 1pt = 1/72in pc CSS1 派卡（picas）; 1pc = 12pt px CSS1 像素（pixels）; 1px = 1/96in px 说是绝对长度单位，这是对于单个设备而言的。px 与设备显示屏的分辨率有关。对于屏幕显示，通常是一个设备像素（点）的显示。 浏览器支持 长度单位 Chrome IE Firefox Safari Opera em, ex, %, cm, mm, q, in, pt, pc, px 1.0 3.0 1.0 1.0 3.5 ch 27.0 9.0 1.0 7.0 20.0 rem 4.0 9.0 3.6 4.1 11.6 vh, vw 20.0 9.0 19.0 6.0 20.0 vmin 20.0 9.0* 19.0 6.0 20.0 vmax 26.0 不支持 19.0 不支持 20.0 注意: IE 9.0 是通过不标准的名称 vm 来支持 vmin 的。 常用相对长度相对长度单位指定了一个长度相对于另一个长度的属性。对于不同的设备，相对长度更适用。 单位 描述 em 相对于当前对象内文本的字体尺寸。如当前对行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸。比如如果当前行内文本的字体尺寸为 16px，2em === 32px rem 相对于根元素(即html元素)font-size vw viewpoint width，视窗宽度，1vw = 视窗宽度的 1% vh viewpoint height，视窗高度，1vh = 视窗高度的1% vmin 相对于 vw 和 vh 中较小的那个 vmax 相对于 vw 和 vh 中较大的那个 % 百分比。关键考虑到底相对什么的百分比 em 与 rem 的区别都是相对大小。em 相对的是从当前向上查询已定义的 px，；而 rem 相对的永远是相对于根元素(即html元素)font-size。 12345678910111213141516171819&lt;!-- 根元素 (html root) 的 font-size 为 50px --&gt;&lt;html style="font-size: 50px;"&gt; &lt;body style="margin: 0;"&gt; &lt;!-- 高度 16px --&gt; &lt;div style="font-size: 16px;line-height: 1;"&gt;px文字&lt;/div&gt; &lt;!-- 高度 2em === 100px，向上查询找到根元素 (html root) --&gt; &lt;div style="font-size: 2em;line-height: 1;"&gt;em文字&lt;/div&gt; &lt;div style="font-size: 16px;"&gt; &lt;!-- 高度 2em === 32px，向上查询找到 div 元素 --&gt; &lt;p style="font-size: 2em;line-height: 1;"&gt;em文字&lt;/p&gt; &lt;/div&gt; &lt;!-- 高度 2rem === 100px，相对根元素 (html root) --&gt; &lt;div style="font-size: 2rem;line-height: 1;"&gt;rem文字&lt;/div&gt; &lt;div style="font-size: 16px;"&gt; &lt;!-- 高度 2rem === 100px，相对根元素 (html root) --&gt; &lt;p style="font-size: 2rem;line-height: 1;"&gt;rem文字&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; vw、vh、vmin、vmax这里的 viewpoint 指浏览器内部的可视区域 viewpoint width，视窗宽度，是指 window.innerWidth viewpoint height，视窗高度，是指 window.innerHeight 10vw = window.innerWidth * 10 / 100 10vh = window.innerHeight * 10 / 100 浏览器内部宽度 window.innerWidth，不包括 scrollbars, toolbars 等 浏览器整体宽度 window.outerWidth，包括 scrollbars, toolbars 等 显示器宽度 window.screen.width，固定不变 window.screen.width &gt;= window.outerWidth &gt; window.innerWidth 有个奇怪的地方，在 chrome 的 device toolbar 调试时，window.innerWidth 最小是 980 % 百分比关键考虑到底相对什么的百分比 12345678910111213&lt;html&gt; &lt;body style="margin: 0;"&gt; &lt;div style="width: 400px;height: 500px;background: red;"&gt; &lt;!-- 宽高是父元素的 30%，即 120px 150px，padding 是父元素的 10%，即 40px，真实宽高为 200px 230px。margin 是父元素的 10%，即 40px，第一个子元素 --&gt; &lt;div style="width: 30%;height: 30%;background: #fff;margin: 10%;padding: 10%;"&gt; &lt;div style="width: 100%;height: 100%;background: #ff0;"&gt;&lt;/div&gt; &lt;/div&gt; &lt;div style="width: 30%;height: 30%;background: #fff;margin: 10%;padding: 10%;box-sizing: border-box;"&gt; &lt;div style="width: 100%;height: 100%;background: #ff0;"&gt;&lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; width/height 的百分比子元素的 width/height 的百分比是相对于父元素的 width/height 的百分比。 margin 的百分比子元素的 margin 的百分比是相对于父元素的 width (只是 content 部分)的百分比 margin padding 的百分比子元素的 padding 的百分比是相对于父元素的 width (只是 content 部分)的百分比 box-sizing 角度值与单位 角度取值 版本 描述 &lt;angel&gt; CSS3 &lt;number&gt;接角度单位 角度单位文本相对长度单位 角度单位 版本 描述 deg CSS3 度（Degrees） grad CSS3 梯度（Gradians） rad CSS3 弧度（Radians） turn CSS3 转、圈（Turns） degdeg 度（Degress）。一个圆共360度 90deg = (90/360)*400 grad ≈ (90/360)*2π rad = (90/360) turn grad梯度（Gradians）。一个圆共400梯度 rad弧度（Radians）。一个圆共2π弧度 π 为 Math.PI turn转、圈（Turns）。一个圆共1圈 时间取值与单位 时间取值 版本 描述 &lt;time&gt; CSS3 &lt;number&gt;接时间单位 时间值不允许有负值。 时间单位 时间单位 版本 描述 s CSS3 秒 ms CSS3 毫秒 1s = 1000ms 颜色取值 颜色取值 版本 描述 ColorName CSS1 用颜色名称来指定颜色。包括基本颜色关键字、系统颜色、SVG颜色关键字等 HEX CSS1 十六进制记法。语法如：#rrggbb或#rgb RGB CSS2 rgb记法 RGBA CSS3 rgba记法 HSL CSS3 hsl记法 HSLA CSS3 hsla记法 transparent CSS1/CSS3 全透明 currentColor CSS3 当前颜色 color 的部分关键字可能不被某些浏览器支持； hex。#RRGGBB。 RR：红色值，十六进制正整数 GG：绿色值，十六进制正整数 BB：蓝色值，十六进制正整数 取值范围：00 - FF。必须是两位数。对于只有一位的，应在前面补零 RGB(R,G,B)。 R：红色值，正整数 | 百分数 G：绿色值，正整数 | 百分数 B：蓝色值，正整数 | 百分数 正整数值的取值范围为：0 - 255。百分数值的取值范围为：0.0% - 100.0%。超出范围的数值将被截至其最接近的取值极限 RGBA(R,G,B,A)。 A：Alpha透明度。取值0~1之间。IE9+ 对于IE6-8，可以使用滤镜filter处理 HSL(H,S,L)。 H：Hue(色调)。0(或360)表示红色，120表示绿色，240表示蓝色，也可取其他数值来指定颜色。取值为：0 - 360。 S：Saturation(饱和度)。取值为：0.0% - 100.0% L：Lightness(亮度)。取值为：0.0% - 100.0% HSLA(H,S,L,A) A：Alpha透明度。取值0~1之间。 transparent 是全透明黑色(black)的速记法，即一个类似rgba(0,0,0,0)这样的值。 在CSS1中，transparent被用来作为background-color的一个参数值，用于表示背景透明。 在CSS2中，border-color也开始接受transparent作为参数值，《Open eBook(tm) Publication Structure 1.0.1》[OEB101]延伸到color也接受transparent作为参数值。 在CSS3中，transparent被延伸到任何一个有color值的属性上。 currentColor是 color 属性的值，具体意思是指：currentColor关键字的使用值是 color 属性值的计算值。12345678div &#123; border: 1px solid; color: red;&#125;/*上述代码将会让div拥有一个红色的边框，这就解释了 border-color 属性的默认值是 color 属性的值；如果将上述代码中的color属性定义删除，那么边框的颜色将取决于父元素的 color 计算值，因为 color 拥有继承性。*/ 文本取值 文本取值 版本 描述 inherit CSS2.1 该值使得属性能够继承祖先设置 initial CSS3 属性初始值 unset CSS3 擦除属性申明 &lt;string&gt; CSS2 字符串(含转义字符串) &lt;url&gt; CSS2 在网页上提供一个资源地址。（图像，声频，视频或浏览器支持的其他任何资源） &lt;identifier&gt; CSS2 使用用户自定义标识名作为组件取值 inherit 可以让一个不具备继承特性的属性可以继承父元素 initial 重置某个属性为UA默认设置 一个属性定义了unset值，如果该属性是默认继承属性，该值等同于inherit，如果该属性是非继承属性，该值等同于initial 字符串可以由双引号或单引号包起来；转义字符串由 反斜杠(\)开始，如：\&#39;, \&quot;。content、font-family 等。 有引号和无引号都是正确的。background 自定义标识。如 myIdentifier12345678910111213li &#123; animation: myIdentifier 3s linear;&#125;@keyframes myIdentifier &#123; 0% &#123; &#125; 100% &#123; &#125;&#125;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[margin]]></title>
    <url>%2Fzh%2F2018%2F09%2F11%2Fcss%5Bmargin%5D%2F</url>
    <content type="text"><![CDATA[margin 外补白 [ margin-top ] || [ margin-right ] || [ margin-bottom ] || [ margin-left ] 适用于所有元素，除非 table | inline-table | table-caption 的表格类元素之外。 取值： auto：水平（默认）书写模式下，margin-top/margin-bottom 计算值为0，margin-left/margin-right取决于可用空间 ：用长度值来定义外补白。可以为负值 ：用百分比来定义外补白。水平（默认）书写模式下，参照其包含块 width 进行计算，其它情况参照 height ，可以为负值 123456检索或设置对象四边的外延边距。如果提供全部四个参数值，将按上、右、下、左的顺序作用于四边。如果只提供一个，将用于全部的四边。如果提供两个，第一个用于上、下，第二个用于左、右。如果提供三个，第一个用于上，第二个用于左、右，第三个用于下。外延边距始终透明。 非替代(non-Replaced)行内元素可以使用该属性设置左、右两边的外补丁；若要设置上、下两边的外补丁，必须先使该对象表现为块级或内联块级。 margin折叠margin collapsing，某些相邻的margin会发生合并。 会发生外边距折叠的三种基本情况： 相邻元素之间 毗邻的两个元素之间的外边距会折叠（除非后一个元素需要清除之前的浮动）。 父元素与其第一个或最后一个子元素之间 如果在父元素与其第一个子元素之间不存在边框、内边距、行内内容，也没有创建块格式化上下文、或者清除浮动将两者的 margin-top 分开；或者在父元素与其最后一个子元素之间不存在边框、内边距、行内内容、height、min-height、max-height将两者的 margin-bottom 分开，那么这两对外边距之间会产生折叠。此时子元素的外边距会“溢出”到父元素的外面。 空的块级元素 如果一个块级元素中不包含任何内容，并且在其 margin-top 与 margin-bottom 之间没有边框、内边距、行内内容、height、min-height 将两者分开，则该元素的上下外边距会折叠。 一些需要注意的地方： 上述情况的组合会产生更复杂的外边距折叠。 即使某一外边距为0，这些规则仍然适用。因此就算父元素的外边距是0，第一个或最后一个子元素的外边距仍然会“溢出”到父元素的外面。 如果参与折叠的外边距中包含负值，折叠后的外边距的值为最大的正边距与最小的负边距（即绝对值最大的负边距）的和。 如果所有参与折叠的外边距都为负，折叠后的外边距的值为最小的负边距的值。这一规则适用于相邻元素和嵌套元素。 12345678&lt;html&gt; &lt;body style="margin: 0;"&gt; &lt;div style="margin-bottom: 10px;"&gt;这是一个标题&lt;/div&gt; &lt;div style="margin-top: 30px;"&gt; &lt;div style="margin-top: 20px;"&gt;这是又一个标题&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 本例中，第一个div的margin-bottom（10px），第二个div的margin-top（30px），第二个div的子元素div的margin-top（10px）将被合并，因为它们三个相邻。它们之间的margin间隙最后是（30px），即取三者之间最大的那个值。 如果给上例中的div加上border的话： 12345678&lt;html&gt; &lt;body style="margin: 0;"&gt; &lt;div style="margin-bottom: 10px;"&gt;这是一个标题&lt;/div&gt; &lt;div style="margin-top: 30px;border:1px solid #000;"&gt; &lt;div style="margin-top: 20px;"&gt;这是又一个标题&lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 本例中，第一个div的margin-bottom（10px），第二个div的margin-top（30px）将被合并，因为它们两个相邻。第二个div的子元素div的margin-top不与它们合并，因为它被border分隔，不与它们相邻。 margin折叠常规认知： margin折叠只发生在块级元素上； 浮动元素的margin不与任何margin发生折叠； 绝对定位元素的margin不与任何margin发生折叠； 设置了属性overflow且值不为visible的块级元素，将不与它的子元素发生margin折叠； 根元素的margin不与其它任何margin发生折叠； 意味着解决margin折叠的方法有： 元素设为行内块元素； 元素设为浮动元素； 元素设为绝对定位元素； 元素设置属性overflow且值不为visible； BFCBFC]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[权重]]></title>
    <url>%2Fzh%2F2018%2F09%2F10%2Fcss%5B%E6%9D%83%E9%87%8D%5D%2F</url>
    <content type="text"><![CDATA[css 权重问题并不简单。 什么是 css 权重css 权重决定了你 css 规则怎样被浏览器解析直到生效。css 权重关系到你的 css 规则是怎样显示的。 当很多的规则被应用到某一个元素上时，权重是一个决定哪种规则生效，或者是优先级的过程。 权重决定了哪一条规则会被浏览器应用在元素上 权重的不同，是你所期望的效果，没有通过 css 规则在元素上生效的主要原因 权重的级别划分时包含了所有的 css 选择器 如果两个选择器作用在同一元素上，则权重高者生效 如果两个选择器权重值相同，则最后定义的规则被计算到权重中(后面定度的 css 规则权重要更大，会取代前面的 css 规则) 如果两个选择器权重值不同，则权重大的规则被计算到权重中 如果一条规则包含了更高权重的选择器，那么这个规则权重更高 最后定义的规则会覆盖所有跟前面冲突的规则 四大等级行内样式 &gt; id &gt; class 类/伪类/属性 &gt; 标签/元素/伪元素 &gt; inherit 继承/* 通配符 行内样式：1000 id：100 class 类/伪类/属性：10 标签/元素/伪元素：1 inherit 继承/* 通配符：0 !important !important 会修改当前对应元素的当前 css 属性和值的权重，对子元素权重没影响 有 !important 指定的权重值大于所有未用 !important 指定的规则 非到万不得已不要用 !important]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WebKit渲染]]></title>
    <url>%2Fzh%2F2018%2F09%2F07%2FWebKit%E6%B8%B2%E6%9F%93%E5%9F%BA%E7%A1%80%E4%B9%8BRender%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B%2F</url>
    <content type="text"><![CDATA[WebKit 是一个渲染引擎，而不是一个浏览器，它专注于网页内容展示，其中渲染是其中核心的部分之一。 DOMDOM 是对 HTML 或者 XML 等文档的一种结构化表示方法，通过这种方式，用户可以通过提供标准的接口来访问 HTML 页面中的任何元素的相关属性，并可对 DOM 进行相应的添加、删除和更新操作等。更多相关信息可查阅 W3C 的文档。 W3C DOM 标准被分为 3 个不同的部分： 核心 DOM - 针对任何结构化文档的标准模型 XML DOM - 针对 XML 文档的标准模型 HTML DOM - 针对 HTML 文档的标准模型 HTML DOM 将 HTML 文档表达为树结构，即 DOM 树。 基于 DOM 树的一些可视(visual)的节点，WebKit 来根据需要来创建相应的 RenderObject 节点，这些节点也构成了一颗树，称之为 Render 树。基于 Render 树，WebKit 也会根据需要来为它们中的某些节点创建新的 RenderLayer 节点，从而形成一棵 RenderLayer 树。 Render 树和 RenderLayer 树是 WebKit 支持渲染所提供的基础但是却非常重要的设施。这是因为 WebKit 的布局计算依赖它们，浏览器的渲染和 GPU 硬件加速也都依赖于它们。幸运地是，得益于它们接口定义的灵活性，不同的浏览器可以很方便地来实现自己的渲染和加速机制。 为了直观了解这三种树，下图给出了这三种树及其它们之间的对应关系。 Render 树的建立Render 树是基于 DOM 树建立起来的一颗新的树， 是布局和渲染等机制的基础设施。Render 树节点和 DOM 树节点不是一一对应关系，那么哪些情况下需要建立新的 Render 节点呢？ DOM 树的 document 节点 DOM 树中的可视化节点，例如 HTML，BODY，DIV 等，非可视化节点不会建立 Render 树节点，例如 HEAD，META，SCRIPT 等 某些情况下需要建立匿名的 Render 节点，该节点不对应于 DOM 树中的任何节点 RenderObject 对象在 DOM 树创建的同时也会被创建，当然，如果 DOM 中有动态加入元素时，也可能会相应地创建 RenderObject 对象。下图示例的是 RenderObject 对象被创建的函数调用过程。 Render 树建立之后，布局运算会计算出相关的属性，这其中有位置，大小，是否浮动等。有了这些信息之后，渲染引擎才只知道在何处以及如何画这些元素。 RenderObject 类及其子类RenderObject 是 Render 树的节点基础类，提供了一组公共的接口。它有很多的子类，这些子类可能对应一些 DOM 树中的节点，例如 RenderText，有些则是容器类，例如 RenderBlock。下图给出了一些常用的类的继承关系图，这其中 RenderBlock 是一个非常重要的类。 匿名 RenderBlock 对象CSS 中有块级元素和内嵌(inline)元素之分。内嵌元素表现的是行布局形式，就是说这些元素以行进行显示。以 div 元素为例，如果设置属性 style 为 display:inline 时，则那是内嵌元素，那么它可能与前面的元素在同一行；如果该元素没有设置这个属性时，则是块级元素，那么在新的行里显示。 RenderBlock 是用来表示块级元素，为了处理上的方便，某些情况下需要建立匿名的 RenderBlock 对象，因为 RenderBlock 的子女必须都是内嵌的元素或者都是非内嵌的元素。所以，当它包含两种元素的时候，那么它会为相邻的内嵌元素创建一个块级 RenderBlock 节点，然后设置该节点为自己的子女并且设置这些内嵌元素为它的子女。 浏览器如何构建 Render 树Render 树的构建 浏览器取回代码后，首先会构造 DOM 树，就是根据 HTML 标签构建 HTML DOM 树。 之后会解析 CSS 样式，解析的顺序是浏览器的样式(UA defaults) -&gt; 页面的 link 标签引入的链接样式 -&gt; @import 引入的导入样式 -&gt; 写在 style 标签里面的内嵌样式 -&gt; 写在 html 标签是 style 属性的行内样式 根据 DOM 树以及解析的 CSS 样式，构造 Render 树，在 Render 树中，会把 DOM 树中没有的元素给去除，比如 head 标签以及里面的内容，以及 display:none 的元素也会被去除。 一旦 Render 树构建完成，浏览器会把树里面的内容绘制在屏幕上。 html 代码如下： 1234567891011121314151617181920&lt;html&gt;&lt;head&gt; &lt;title&gt;Beautiful page&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt; Once upon a time there was a looong paragraph... &lt;/p&gt; &lt;div style="display: none"&gt; Secret message &lt;/div&gt; &lt;div&gt;&lt;img src="..." /&gt;&lt;/div&gt; ...&lt;/body&gt;&lt;/html&gt; 构造的 DOM 树如下： 1234567891011121314documentElement (html) head title body p [text node] div [text node] div img ... Render 树如下： 123456789101112root (RenderView) body p line 1 line 2 line 3 ... div img ... CSS 的图层在渲染 DOM 的时候，浏览器所做的工作实际上是：1. 获取 DOM 后分割为多个图层 2. 对每个图层的节点计算样式结果 (Recalculate style – 样式重计算) 3. 为每个节点生成图形和位置 (Layout – 回流和重布局) 4. 将每个节点绘制填充到图层位图中 (Paint Setup和Paint – 重绘) 5. 图层作为纹理上传至 GPU 6. 符合多个图层到页面上生成最终屏幕图像 (Composite Layers – 图层重组) 重绘 (repaint/redraw) 和重排/回流 (reflow)重绘重绘 (repaint/redraw)。当盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定下来之后，浏览器便把这些原色都按照各自的特性绘制一遍，将内容呈现在页面上。重绘是指一个元素外观的改变所触发的浏览器行为，浏览器会根据元素的新属性重新绘制，使元素呈现新的外观。 触发重绘的条件：改变元素外观属性。如：color，background-color 等。 注意：table 及其内部元素可能需要多次计算才能确定好其在渲染树中节点的属性值，比同等元素要多花两倍时间，这就是我们尽量避免使用 table 布局页面的原因之一。 重排重排 (重构/回流/reflow)。当元素的尺寸/几何属性(宽或高)发生变化，元素显示隐藏等，会导致浏览器需要重新计算元素的几何属性和位置，同样其他元素的几何属性和位置也会因此受到影响。浏览器会使渲染树中受到影响的部分失效，并重新构造渲染树。这就称为重排。 完成重排后，浏览器会重新绘制受影响的部分到屏幕，该过程称为重绘。重排必然导致重绘，所以重排更加恶心。其实我们一直研究的应该是怎么避免触发多次重排。 每个页面至少需要一次重排，就是在页面第一次加载的时候。 触发重排的条件：任何页面布局和几何属性的改变都会触发重排。如： 页面渲染初始化(无法避免) 添加或删除可见的 DOM 元素 元素位置的改变，或者使用动画 元素尺寸的改变，包括大小、外边距、边框等 浏览器窗口尺寸的变化(resize事件发生时) 填充内容的改变，比如文本的改变或图片大小改变而引起的计算值宽度和高度的改变 读取元素尺寸或位置属性: offsetLeft/Top/Height/Width, clientTop/Left/Width/Height, scrollTop/Left/Width/Height, width/height, getComputedStyle(), currentStyle(IE) 建设重绘和重排来优化页面重绘和重排的代价：耗时，导致浏览器卡慢。 优化： 浏览器自身的优化：浏览器会维护 1 个队列，把所有会引起回流、重绘的操作放入这个队列，等队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会 flush 队列，进行一个批处理。这样就会让多次的回流、重绘变成一次回流重绘。 12345var ele = document.getElementById('myDiv');ele.style.borderLeft = '1px';ele.style.borderRight = '2px';ele.style.padding = '5px';// 乍一想，元素的样式改变了三次，每次改变都会引起重排和重绘，所以总共有三次重排重绘过程，但是浏览器并不会这么笨，它会把三次修改“保存”起来(大多数浏览器通过队列化修改并批量执行来优化重排过程)，一次完成！但是，有些时候你可能会(经常是不知不觉)强制刷新队列并要求计划任务立即执行 开发者的优化：减少重绘和重排就是要减少对渲染树的操作，可以合并多次的 DOM 和样式的修改，并减少对 style 样式的请求。 直接改变元素的 className 先设置元素为 display: none; 然后进行页面布局等操作；设置完成后将元素设置为 display: block; 这样的话就只引发两次重绘和重排 要经常访问浏览器的 flush 队列属性；如果一定要访问，可以利用缓存。将访问的值存储起来，接下来使用就不会再引发回流 使用 cloneNode (true or false) 和 replaceChild 技术，引发一次回流和重绘 将需要多次重排的元素，position 属性设为 absolute 或 fixed，元素脱离了文档流，它的变化不会影响到其他元素 如果需要创建多个 DOM 节点，可以使用 documentFragment 创建完后一次性的加入 document 1234567891011var fragment = document.createDocumentFragment()var li = document.createElement('li')li.innerHTML = 'apple'fragment.appendChild(li)var li = document.createElement('li')li.innerHTML = 'watermelon'fragment.appendChild(li)document.getElementById('fruit').appendChild(fragment) 尽量不要使用 table 布局 量不要在修改样式或者布局信息时查询样式，因为查询的时候会强制重排，导致浏览器无法优化多次重排 transform 是否可以避免重排重绘问题CSS 的最终表现分为以下四步：Recalculate Style -&gt; Layout -&gt; Paint Setup and Paint -&gt; Composite Layers，即查找并计算样式 -&gt; 排布 -&gt; 绘制 -&gt; 组合层 重排必定导致重绘，而查询样式会强制发生重排！ 由于 transform 是位于 Composite Layers 层，而 width、left、margin 等则是位于 Layout 层。在 Layout 层发生的改变必定导致 Paint Setup and Paint -&gt; Composite Layers，所以相对而言使用 transform 实现的动画效果肯定比 left 这些更加流畅。 动画性能优化用绝对定位(absolute)+ 改变位移(left、top等)+ 改变大小(whidth、height) + 改变边距 (margin) 来实现的动画，出现卡顿，其原因是当这些节点改变大小或位置时，浏览器重布局了整个页面！ CSS Triggers 强迫浏览器创建图层，开启 GPU 硬件加速如果能把动画单独创建一个图层，与页面独立开，就会让动画更顺畅。 满足以下条件就会创建一个图层： 3D或透视变换 (perspective transform) CSS 属性 使用硬件加速视频解码的 节点 拥有3D (WebGL) 上下文或硬件加速的 2D 上下文的 节点 混合插件(如 Flash) 对自己的 opacity 做 CSS 动画或使用一个动画 WebKit 变换的元素 拥有硬件加速 CSS 过滤器的元素 元素有一个包含复合层的后代节点(一个元素拥有一个子元素，该子元素在自己的层里) 元素有一个 z-index 较低且包含一个复合层的兄弟元素(换句话说就是该元素在复合层上面渲染) 强迫浏览器对元素单独生成一个图层，把重绘的工作交给 GPU 去做，而不占用主线程。也就是利用 GPU 重绘来做动画。 使用 3d 效果来开启硬件加速： 1234.speed-up &#123; -webkit-transform: rotate3d(250px,250px,250px,-120deg) scale3d(0.5, 0.5, 0.5) translate3d(250px, 250px, 250px); transform: rotate3d(250px,250px,250px,-120deg) scale3d(0.5, 0.5, 0.5) translate3d(250px, 250px, 250px);&#125; 如果并不需要用到 transform 变换，仅仅是开启硬件加速，可以用下面的语句: 1234.speed-up&#123; -webkit-transform: translateZ(0); transform: translateZ(0);&#125; 硬件加速最好只用在 animation 或者 transform 上。不要滥用硬件加速，因为这样会增加性能的消耗，如果滥用反而会使动画变得更加卡，这样就得不偿失了。 尽量不触发重绘想提高动画性能，需要做的就是减少浏览器在动画运行时所需要做的工作。最好的情况是，改变的属性仅仅影响图层的组合，变换 (transform) 和透明度(opacity)就属于这种情况。 减小选择器的复杂性1234567.box:nth-last-child(-n+1) .title &#123; /* styles */&#125;.final-box-title &#123; /* styles */&#125; 上面代码都是选择同一个元素，当元素很多时，第二个选择器的性能会明显优于第一个。BEM 规范有做类似事情，按照特性直接由一个选择器选择元素的性能往往会更优。 减少样式的计算量减少无效元素、冗余标签。 使用 Flexbox 布局css 动画与 js 动画css 动画优点： (1) 浏览器可以对动画进行优化 浏览器使用与 requestAnimationFrame 类似的机制，requestAnimationFrame 比起 setTimeout、setInterval 设置动画的优势主要是: requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频，一般来说，这个频率为每秒 60 帧。 在隐藏或不可见的元素中 requestAnimationFrame 不会进行重绘或回流，这当然就意味着更少的 CPU、GPU 和内存使用量。 强制使用硬件加速，通过 GPU 来提高动画性能 (2) 代码相对简单，性能调优方向固定 (3) 对于帧速表现不好的低版本浏览器，css 可以做到自然降级，而 js 则需要撰写额外代码 css 动画缺点： (1) 运行过程控制较弱，无法附加事件绑定回调函数。css 动画只能暂停，不能在动画中寻找一个特定的时间点，不能在半路反转动画，不能变换时间尺度，不能在特定的位置添加回调函数或是绑定回放事件，无进度报告 (2) 代码冗长。想用 CSS 实现稍微复杂一点动画,最后 css 代码都会变得非常笨重。 js 动画优点： (1) js 动画控制能力很强，可以在动画播放过程中对动画进行控制：开始、暂停、回放、终止、取消都是可以做到的。 (2) 动画效果比 css 动画丰富，有些动画效果，比如曲线运动、冲击闪烁、视差滚动效果，只有 js 动画才能完成 (3) css 动画有兼容性问题，而 js 动画大多时候没有兼容性问题 js 动画缺点： (1) js 在浏览器的主线程中运行，而主线程中还有其它需要运行的 js 脚本、样式计算、布局、绘制任务等，对其干扰导致线程可能出现阻塞，从而造成丢帧的情况。 (2) js 动画代码的复杂度高于 css 动画 总结：如果动画只是简单的状态切换，不需要中间过程控制，在这种情况下，css 动画是优选方案。它可以让你将动画逻辑放在样式文件里面，而不会让你的页面充斥 js 库。然而如果你在设计很复杂的客户端界面或者在开发一个有着复杂 UI 状态的 APP。那么你应该使用 js 动画，这样你的动画可以保持高效，并且你的工作流也更可控。所以，在实现一些小的交互动效的时候，就多考虑考虑 css 动画。对于一些复杂控制的动画，使用 js 动画比较可靠。 优化 js 动画使用 requestAnimationFrame将 setTimeout 换成 requestAnimationFrame，因为 setTimeout 时间控制可能造成在一帧的中间，目前各浏览器对 requestAnimationFrame 的支持已经比较好了。 使用 Web Workers将复杂计算的 JS 采用 Web Workers 进行处理。 减少垃圾回收垃圾回收是一个容易被忽略的问题，因为垃圾回收的时间是不受控制的，它可能在一个动画的中途，阻塞动画的执行，更理想的情况是在循环中复用对象。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[车]]></title>
    <url>%2Fzh%2F2018%2F09%2F06%2F%E8%BD%A6%2F</url>
    <content type="text"><![CDATA[车。 开车步骤带钥匙！ 观察车身周围环境！ 上车！ 关好车门！ 调整座椅！ 调整后视镜！ 系安全带！ 开机！ 如果要听歌或者导航或者要调整车窗/天窗等，现在就弄！ 关闭发动机自动启停功能！（右手边） 踩住制动踏板，释放电子驻车制动器！（左手边） 踩住制动踏板，移除P(驻车)档，挂R(倒车)档或者挂D(前进)档！ 打左转向灯！ 双手握住方向盘！不要单手，杜绝陋习！ 根据车身位置，选择向左打方向的角度。如果前方没有障碍物，稍微向左打。如果前方有障碍物，向左打死，或者确保能够安全转向使出！ 轻轻释放制动踏板，但不要全部释放！ 车身缓缓移动，及时缓动方向调整角度，观察左右后视镜以及收听驻车雷达提示，如果出现距离不够或出现提示，要立即停车观察，不要侥幸勉强！（2018年9月6日晚停车差点撞到车前面的树） 前进档和倒车档互相切换！调整车身位置！ 当车身进入安全行驶区域，保持车身方向，释放制动踏板，并选择缓缓踩下油门进行加速！ 行驶过程中注意专心、谨慎，保持目视前方，余光观察后视镜，保持车距（左右，前）！ 如果有儿童靠近，一定要停车！如果有非机动车靠近，一定要减速慢行！人行横道处，有行人通过，一定要停车让行人先过！遇到路口或人行横道，一定要左右观察！ 转弯、变道要打方向灯！ 转弯让直行！ 向左转弯时，靠路口中心点左侧转弯！ 相对方向行驶的右转弯车让左转弯车先行！ 直行 &gt; 左转 &gt; 右转 不能闯红灯！除非是圆盘红灯，可以右转！ 出现箭头右转红灯，不能右转！只有出现圆盘红灯，可以右转！ 直线行驶时保持方向，不要左右摇摆，也不要随意转动方向！ 停车步骤打右转向灯！ 释放油门！ 踩住制动踏板，控制力度调整速度！ 车身缓缓移动，及时缓动方向调整角度，观察左右后视镜以及收听驻车雷达提示，如果出现距离不够或出现提示，要立即停车观察，不要侥幸勉强！（2018年9月6日晚停车差点撞到车前面的树） 前进档和倒车档互相切换！调整车身位置！ 将车停靠在适当位置！ 踩住制动踏板，让车停止！ 挂P(驻车)档！ 启动电子驻车制动器！（左手边） 解安全带！ 收起后视镜！ 关闭听歌或者导航或者车窗/天窗等！ 关机！ 下车！ 观察车身是否处于安全位置！ 锁车门！ A、B、C 柱 A 柱驾驶员左前方和右前方的柱，是连接车棚和车身的柱子。 B 柱驾驶员最侧后方的，安全带一段固定的柱子。也是分为左右两侧的。 C 柱车的后排座椅左右两侧的车篷与车身连接的柱子。 难点左右转弯！拐弯时，一定要提前减速，只有慢一些才能安全的通过，或者拐错了能及时更正。相反如果拐弯速度过快就容易出现危险。 右拐时尽量拐小弯(方向盘打大，甚至向右打死，等拐过弯后再慢慢回正方向)。右拐时，有时会遇到直行的会正在行驶的车辆，像十字路口，这时你要拐弯就要拐个小弯，这样不会影响直行车辆正常行驶，否则会阻碍他人的。 左拐时尽量拐大弯(方向盘打小，稍微向左打一点，边拐边打方向)。尽量行驶至靠路口中心点左侧转弯。因为有些车辆也会在你想拐进去的路上出来，这时为了避免发生阻碍或碰撞等其它危险，应尽量的往远一点的地方拐进去。 看好后视镜。在拐弯时，一定要看好后视镜，判断好车后方或侧后方没人后再拐弯。这一点很多新手往往顾及不到，容易酿成交通事故。 留意拐弯的死角。新手在拐弯时往往会看上不看下，看左不看右，导致忽略了拐弯死角，容易压到马路基石上或发生刮擦。一定要看好后视镜下方的障碍物，必要时应该打开车门看一看再拐。 控制好方向盘。拐弯时，方向盘的控制很重要。如果想拐小弯，要把方向盘尽量打死，等拐过弯后再慢慢回正方向；想拐大弯，则要慢慢的打方向即可。 右拐让左拐，拐弯让直行。 两侧有障碍物，行驶空间小，如何安全通过！如何入库！“并联式” 停车位 将自己所驾车辆停在与停车位垂直的位置，且左侧与车位线保持 1.5 米左右的距离。 等确认好之后将车继续向前开两个停车位的距离，当自己在车内所坐的位置正好处于第二个停车位的中间时停车。 然后往左打满轮后开始倒车，注意车头车尾与左右两车的距离，保证不要剐蹭，左小向右回，右小向左回。 在确认车尾已经进入要停的车位而且车头已经摆正时，立刻将车轮回正，继续倒车进入车位，把握好车尾与后方的位置以后，停车就大功告成了。 当然如果出现左右距离明显不一致，要稍微修正，左小向右回，右小向左回。 “串联式” 停车位，即侧方位 将自己所驾车辆停在与停车位平行的位置，且与前车左侧保持 0.5 米左右的距离。 等确认好之后将车继续向前开，当右车镜对准前车 B 柱 (驾驶员最侧后方的，安全带一段固定的柱子) 时停车。 然后往右打满轮，开始倒车，注意车头车尾与左右两车的距离，保证不要剐蹭，左小向右回，右小向左回。 当车和前车成45度角时，往左打满轮，继续倒车。 进位后，头正回轮。 当然如果出现左右距离明显不一致，要稍微修正，左小向右回，右小向左回。 ”斜线式” 停车位 当看到自己所驾车辆的左后视镜与所要进的停车位的左侧边线对齐时停车。 向右打满轮，继续前进，注意车头车尾与左右两车的距离，保证不要剐蹭，左小向右回，右小向左回。 车身纵向与停车位呈一条直线时，将车停住，回正车轮，再平稳倒入停车位。 当然如果出现左右距离明显不一致，要稍微修正，左小向右回，右小向左回。 如何出库！ 技术不行，就小心谨慎、缓慢移动，慢是慢点，还是能成功的！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>车</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript的new运算符]]></title>
    <url>%2Fzh%2F2018%2F09%2F05%2FJavaScript%E7%9A%84new%E8%BF%90%E7%AE%97%E7%AC%A6%2F</url>
    <content type="text"><![CDATA[new 运算符，用来创建一个用户定义的对象类型的实例或具有构造函数的内置对象的实例。也就是说，是根据一个对象，去创建它的实例。 语法1new Constructor[([arguments])] 参数Constructor 一个指定对象实例的类型的类或函数。 arguments 一个用来被 Constructor 调用的参数列表。 过程 新生成了一个对象 链接到原型 绑定 this 回新对象 在调用 new 的过程中会发生以上四件事情，我们也可以试着来自己实现一个 new。 1234567function Car (make, model, year) &#123; this.make = make this.model = model this.year = year&#125;var car = new Car() 123456789function Car (make, model, year) &#123; this.make = make this.model = model this.year = year&#125;var car = &#123;&#125;car.__proto__ = Car.prototypeCar.call(car) 1234567891011121314151617181920function Car (make, model, year) &#123; this.make = make this.model = model this.year = year&#125;function create () &#123; // 创建一个空的对象 let obj = &#123;&#125; // 获得构造函数 let Con = [].shift.call(arguments) // 链接到原型 obj.__proto__ = Con.prototype // 绑定 this，执行构造函数 let result = Con.apply(obj, arguments) // 确保 new 出来的是个对象 return typeof result === 'object' ? result : obj&#125;var car = create(Car)]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript安全整数]]></title>
    <url>%2Fzh%2F2018%2F08%2F24%2FJavaScript%E5%AE%89%E5%85%A8%E6%95%B4%E6%95%B0%2F</url>
    <content type="text"><![CDATA[最近在做收银台业务，成功下单后，后端需要返回给前端订单号，前端根据订单号去跳转收银台，然后付款。但是碰到个奇怪的问题，一致订单异常。 一开始，我觉得订单异常，肯定是后端某个环节有问题，我前端就负责拿订单号去跳转收银台，能出什么问题？ 我指着下单接口，“你看，你接口给我的订单号是 201808221019001800”，又指着收银台接口，“你看，我传给收银台的订单号是 201808221019001800”，这订单异常，肯定是后端有问题啊！ 后端调试了半天，找不到原因，“我这都查过了，我写的代码都是对的啊！不过为什么你的订单号是 201808221019001800，我后台查不到这个订单啊！而且你的 uid 是 10007777，订单尾号应该是 1777 才对，我订单号取的逻辑是 ‘年月日时分秒’ 再加 uid 的第一位和后三位！是不是你那边请求问题啊”。 我心里呵呵一笑，我就请求个接口，还能请求出问题？我前端就负责调接口，你接口返回给我什么，我就展示什么，我还能改你返回的数据？我又没拦截！ 我去后台查了一下订单，我特么发现后台记录的那条订单，真是 201808221019001777。但到底为啥给我的就是 201808221019001800 呢？虽然不知道什么原因，但我不管，一定是后端处理错了！ 后端说，那好，我在返回之前打个日志，我看看我给你的到底是什么，你调调看。 试了一下，他打出的是 201808221019001777，我拿到的是 201808221019001800。呐呢？ 后端说那肯定是你调用的问题吧，我用 postman 试了试，我调出来的也是 201808221019001777。这越发让我疑惑。 于是我也用 postman 调用，特么真的是 201808221019001777，我又在 chrome 控制台调用，特么竟然又是 201808221019001800，什么鬼哦？还有这种操作？ 突然鬼使神差地，我在 chrome 控制台输入了 201808221019001777，按下 return 键，特么返回了 201808221019001800。 尼玛！原来是浏览器处理了！ 接口给的 201808221019001777 是个 Number 类型，超过了浏览器(js)能处理的最大安全整数！ 解决方案就是接口转化为 String 类型返回。 最大安全整数、最小安全整数js 最大安全整数是 Number.MAX_SAFE_INTEGER，最小安全整数是 Number.MIN_SAFE_INTEGER， 1234567Number.MAX_SAFE_INTEGER // 9007199254740991Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1 // trueNumber.MIN_SAFE_INTEGER // -9007199254740991Number.MIN_SAFE_INTEGER === 1 - Math.pow(2, 53) // true 2 的 53 次方js 安全整数的范围是 (Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER) 即 -2^53~2^53 (不包含边界) 。 安全整数，意思是说能够 one-by-one 表示的整数，也就是说在(-2^53, 2^53)范围内，双精度数表示和整数是一对一的，反过来说，在这个范围以内，所有的整数都有唯一的浮点数表示，这叫做安全整数。超过这个范围，会有两个或更多整数的双精度表示是相同的；反过来说，超过这个范围，有的整数是无法精确表示的，只能round到与它相近的浮点数（说到底就是科学计数法）表示，这种情况下叫做不安全整数。 12345678910111213Math.pow(2, 53) // 9007199254740992Math.pow(2, 53) === Math.pow(2, 53) + 1 // trueMath.pow(2, 53) + 1 // 9007199254740992Math.pow(2, 53) + 2 // 9007199254740994Math.pow(2, 53) + 3 // 9007199254740996Math.pow(2, 53) + 4 // 9007199254740996Math.pow（2,53）+ 5 // 9007199254740996 当运算数与运算结果都处于安全整数的范围内时，才能保证 js 运算结果正确。 请求接口中返回一个整数，例如订单号，是个不安全整数，就会导致前端处理异常！ 1201808221019001777 // 被处理成 201808221019001800 js 安全整数的范围为啥是 (Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER) 即 -2^53~2^53 (不包含边界) ？ js 里数字类型只有一种，Number 类型，是双精度浮点型，都是 64-bit (1bit 的符号位，11bits 的指数部分，以及 52bits 的小数部分) 的双精度浮点数(double)！ js 里的整型 int 是 双精度浮点型 double 的一个子集，而不是一个独立的数据类型。 由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心！ 引申问题： 0.1 + 0.2 为什么不等于 0.3 0.1 + 0.2 为什么不等于 0.3 123456typeof 1 // numbertypeof 1.0 // number1 === 1.0 // true0.1 + 0.2 === 0.3 // false IEEE 754 双精度浮点数。 参考1 参考3 参考2]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[健康指标]]></title>
    <url>%2Fzh%2F2018%2F08%2F14%2F%E5%81%A5%E5%BA%B7%E6%8C%87%E6%A0%87%2F</url>
    <content type="text"><![CDATA[罗列一些生活中需要知道健康指标。 血糖血中的葡萄糖称为血糖。 血糖的来源包括：①食物消化、吸收；②肝内储存的糖原分解；③脂肪和蛋白质的转化。 血糖的去路包括：①氧化转变为能量；②转化为糖原储存于肝脏、肾脏和肌肉中；③转变为脂肪和蛋白质等其他营养成分加以储存。 胰岛是体内调节血糖的血糖浓度的主要器官，肝脏储存肝糖元。此外，血糖浓度还受神经、内分泌激素的调节。 血糖值空腹血糖全血血糖(手指)。血浆血糖(静脉)。 空腹血糖正常值，全血血糖：3.89～6.11 mmol/L，血浆血糖：3.90～6.90 mmol/L 空腹全血血糖 ≥ 6.70 mmol/L，血浆血糖 ≥ 7.80 mmol/L，2 次重复测定可诊断为糖尿病。 餐后血糖餐后 1 小时：血糖 6.7-9.4 mmol/L。最多也不超过 11.1 mmol/L。 餐后 2 小时：血糖 ≤ 7.8 mmol/L。 餐后 3 小时：第三小时后恢复正常，各次尿糖均为阴性。 孕妇血糖空腹不超过 5.1 mmol/L。 餐后 1 小时不得超过 10.0 mmol/L 才是血糖的正常水平。 糖尿病糖尿病患者的空腹血糖参考值： 轻度糖尿病：7.08.4 mmol/L，中度糖尿病：8.411.1 mmol/L，重度糖尿病：大于 11.1 mmol/L。 药物二甲双胍。 二甲双胍片首选用单纯饮食控制及体育锻炼治疗无效的2型糖尿病，特别是肥胖的2型糖尿病。 本品与胰岛素合用，可减少胰岛素用量，防止低血糖发生。 可与磺酰脲类降血糖药合用，具协同作用。 服用本品时应尽量避免饮酒。 哪些食物降血糖1.饮食宜清淡，忌辛辣，低糖、低油、低盐，按时饮食 2.可以吃：苦瓜、洋葱、山药、海带、魔芋多吃，冬瓜、芹菜、菠菜、藕等少吃 3.可以吃：柚子、苹果、橘子、樱桃、草莓、梨、桃等升糖指数比较低，西瓜吃靠近瓜皮的，不吃瓜心 4.不能吃：香蕉、山楂、柿子、枣子 5.多喝凉白开，不要憋尿 6.检测足部，保护足部 7.多做足部运动，踮脚、脚趾抓地、泡完脚后用掌心搓脚心 8.不含糖的甜味剂，比如木糖醇、三氯蔗糖、阿斯巴甜、甜菊糖苷这类甜味剂；如果含有这些的食品，可以少量食用。燕麦片 多吃：冬瓜、苦瓜、洋葱、山药、海带、魔芋、芹菜、菠菜、木耳、藕 燕麦片燕麦片是燕麦粒轧制而成，呈扁平状，直径约相当于黄豆粒，形状完整的一种食品。燕麦煮出来高度粘稠，其中 beta 葡聚糖健康成分所带来的，具有降血脂、降血糖、高饱腹的效果，长期食用具有减肥功效。此外，燕麦中含有丰富的维生素 B1、B2、E、叶酸等，可以改善血液循环、缓解生活工作带来的压力；含有的钙、磷、铁、锌、锰等矿物质也有预防骨质疏松、促进伤口愈合、防止贫血的功效。 魔芋降血糖、降血脂、降血压、散毒、养颜、通脉、减肥、通便、开胃。 生魔芋有毒，必须煎煮 3 小时以上才可食用。 消化不良的人，每次食量不宜过多。 有皮肤病的人少食。 魔芋性寒，有伤寒感冒症状的应少食用。 海带海带是一种营养价值很高的蔬菜，同时具有一定的药用价值。含有丰富的碘等矿物质元素。海带含热量低、蛋白质含量中等、矿物质丰富。研究发现，海带具有降血脂、降血糖、调节免疫、抗凝血、抗肿瘤、排铅解毒和抗氧化等多种生物功能。 吃海带后不要马上喝茶(茶含鞣酸)，也不要立刻吃酸涩的水果(酸涩水果含植物酸)。 吃多也不好，会得甲亢。 山药具有滋养强壮，助消化，敛虚汗，止泻之功效，主治脾虚腹泻、肺虚咳嗽、糖尿病消渴、小便短频、遗精、妇女带下及消化不良的慢性肠炎。 血压是指血液在血管内流动时作用于单位面积血管壁的侧压力，它是推动血液在血管内流动的动力。在不同血管内被分别称为动脉血压、毛细血管压和静脉血压，通常所说的血压是指体循环的动脉血压。 影响动脉血压的因素主要有五个方面：①每搏输出量；②外周阻力；③心率；④主动脉和大动脉管壁的弹性；⑤循环血量与血管容量。 血压值收缩压：高压。舒张压：低压。 正常成人安静状态下的血压范围较稳定，正常范围收缩压 90～139 mmHg，舒张压 60～89 mmHg，脉压 30～40 mmHg。 高血压：未使用抗高血压药的前提下，18 岁以上成人收缩压 ≥ 140 mmHg 和(或)舒张压 ≥ 90mmHg。 低血压：未使用抗高血压药的前提下，18 岁以上成人收缩压 &lt; 90 mmHg 和(或)舒张压 &lt; 60mmHg。 哪些食物降血压茄子降低胆固醇，降血脂、降血压，防治胃癌，治疗慢性胃炎、肾炎水肿，防治坏血病及促进伤口愈合，清热解毒。 消化不良、容易腹泻、脾胃虚寒、便溏症状的人不宜多吃。 秋后的茄子有一定的毒素，不要吃。 白萝卜清肠排毒，促进消化，增强食欲，防癌抗癌，降血压 芹菜降低胆固醇，降血压 【芹菜+鸡肉】容易伤元气。 【芹菜+兔肉】容易引起脱皮。 BMI 指数身体质量指数，简称体质指数，又称体重. 体质指数(BMI)= 体重(kg)÷ 身高(m)^ 2 成人的BMI数值： 过轻：低于 18.5 正常：18.5-23.9 过重：24-27 肥胖：28-32 非常肥胖：高于 32 60 / (1.68 * 1.68) = 21.26 65 / (1.68 * 1.68) = 23.04 67 / (1.68 * 1.68) = 23.74 60 / (1.70 * 1.70) = 20.77 65 / (1.70 * 1.70) = 22.50 69 / (1.70 * 1.70) = 23.88 60 / (1.72 * 1.72) = 20.29 65 / (1.72 * 1.72) = 21.98 70 / (1.72 * 1.72) = 23.67 其他韭菜补肾，健胃，提神，降低胆固醇。 春食则香，夏食则臭。 【韭菜+菠菜】同食会有滑肠作用，容易引起腹泻。 【韭菜+牛肉】发 热动火，引起牙齿肿痛，口疮。 【韭菜+白酒】引起胃炎，胃溃肠病复发。 【韭菜+蜂蜜】同食容易引起腹泻。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>健康</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript继承机制]]></title>
    <url>%2Fzh%2F2018%2F08%2F14%2FJavaScript%E7%BB%A7%E6%89%BF%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[待补充]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript深浅复制(拷贝)]]></title>
    <url>%2Fzh%2F2018%2F08%2F14%2FJavaScript%E6%B7%B1%E6%B5%85%E5%A4%8D%E5%88%B6(%E6%8B%B7%E8%B4%9D)%2F</url>
    <content type="text"><![CDATA[拷贝，copy，复制，抄本、副本、别本。 拷贝就是拷贝指向对象的指针，意思就是说，拷贝出来的目标对象的指针和源对象的指针指向的内存空间是同一块空间！ 拷贝分浅拷贝和深拷贝。 深浅拷贝要了解深浅拷贝，需要先去回顾 JavaScript 数据类型。 JavaScript 的数据类型分为基本数据类型和引用数据类型。 基本数据类型是按值传递，其拷贝没有深浅拷贝的区别。b 是 a 的拷贝，在修改 b 时并不会改到 a。 引用数据类型是按引用传递，其拷贝才有深浅拷贝的区别。 深浅拷贝是针对对象而言的。 浅拷贝shallow copy 按位拷贝对象，它会创建一个新对象，这个对象有着源对象属性值的一份精确拷贝。 如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址(引用类型)，拷贝的就是内存地址。 因此如果其中一个对象改变了这个地址，就会影响到另一个对象。即默认拷贝构造函数只是对对象进行浅拷贝复制(逐个成员依次拷贝)，即只复制对象空间而不复制资源，只复制引用而不复制真正的值。 浅拷贝的意思就是只复制引用，而未复制真正的值。 赋值操作符 = 就是浅拷贝1234567891011121314151617var obj = &#123; a: 'hello', b: &#123; a: 'world', b: 21, &#125;, c: ['Bob', 'Tom', 'Jenny'], d: function () &#123; alert('hello world') &#125;&#125;var cloneObj = objcloneObj.a = 'world'console.log(cloneObj.a, obj.a) // world, world 简单的复制函数1234567891011121314151617181920212223242526272829303132333435363738394041var obj = &#123; a: 'hello', b: &#123; a: 'world', b: 21, &#125;, c: ['Bob', 'Tom', 'Jenny'], d: function () &#123; alert('hello world') &#125;&#125;function simpleClone (initalObj) &#123; var obj = &#123;&#125; for ( var i in initalObj) &#123; obj[i] = initalObj[i] &#125; return obj&#125;var cloneObj = simpleClone(obj)cloneObj.a = 'world'console.log(cloneObj.a, obj.a) // world, hellocloneObj.b.a = 'hello'console.log(cloneObj.b.a, obj.b.a) // hello, hellocloneObj.b = &#123;&#125;console.log(cloneObj.b.a, obj.b.a) // undefined, hellocloneObj.c[0] = 0console.log(cloneObj.c[0], obj.c[0]) // 0, 0cloneObj.c = [1, 2, 3]console.log(cloneObj.c[0], obj.c[0]) // 1. 0 obj[i] = initalObj[i] 这里对对象的第一层进行了深拷贝，而第二层开始的目标我们是直接利用 = 赋值操作符进行拷贝的，只是复制了一个引用，也就是浅拷贝。 直接修改克隆对象第一层属性的值，不会对原对象产生影响。但如果修改第二层属性，即第一层属性的值是个对象，并改变其值(该对象上某个属性)，就会对原对象产生影响。 对目标对象的第一层进行深拷贝，然后后面的是浅拷贝，可以称作“首层浅拷贝”。 赋值运算符 = 实现的是浅拷贝，只拷贝对象的引用值。 js 中数组和对象自带的拷贝方法都是“首层浅拷贝”。 concat1234567var array = [1, 2, 3]var cloneArray = array.concat() // [1, 2, 3]cloneArray[0] = 0console.log(cloneArray, array) // [0, 2, 3], [1, 2, 3] 看上去好像不是浅拷贝，其实 concat 也是对数组的第一层进行了深拷贝。 1234567var array = [&#123; x: 1 &#125;, 2, 3]var cloneArray = array.concat() // [&#123; x: 1&#125;, 2, 3]cloneArray[0].x = 0console.log(cloneArray[0].x, array[0].x) // 0, 0 sliceslice 也是对数组的第一层进行了深拷贝。 1234567var array = [&#123; x: 1 &#125;, 2, 3]var cloneArray = array.slice() // [&#123; x: 1&#125;, 2, 3]cloneArray[0].x = 0console.log(cloneArray[0].x, array[0].x) // 0, 0 forEachforEach 也是对数组的第一层进行了深拷贝。 1234567891011var array = [&#123; x: 1 &#125;, 2, 3]var cloneArray = []array.forEach((item, index) =&gt; &#123; cloneArray[index] = item&#125;) // [1, 2, 3]cloneArray[0].x = 0console.log(cloneArray[0].x, array[0].x) // 0, 0 mapmap 也是对数组的第一层进行了深拷贝。 123456789var array = [&#123; x: 1 &#125;, 2, 3]var cloneArray = array.map(item =&gt; &#123; return item&#125;) // [1, 2, 3]cloneArray[0].x = 0console.log(cloneArray[0].x, array[0].x) // 0, 0 扩展运算符扩展运算符 ... 也是对数组/对象的第一层进行了深拷贝。 1234567var array = [&#123; x: 1 &#125;, 2, 3]var cloneArray = [...array] // [1, 2, 3]cloneArray[0].x = 0console.log(cloneArray[0].x, array[0].x) // 0, 0 Object.assign()Object.assign() 也是对数组/对象的第一层进行了深拷贝。 1234567var array = [&#123; x: 1 &#125;, 2, 3]var cloneArray = Object.assign([], array) // [1, 2, 3]cloneArray[0].x = 0console.log(cloneArray[0].x, array[0].x) // 0, 0 深拷贝deep copy 一个引用对象一般来说由两个部分组成：一个具名的 Handle，也就是我们所说的声明（如变量）和一个内部（不具名）的对象，也就是具名 Handle 的内部对象。它在 Manged Heap（托管堆）中分配，一般由新增引用对象的 new 方法是进行创建。深拷贝是指源对象与拷贝对象互相独立，其中任何一个对象的改动都不会对另外一个对象造成影响。 源对象与拷贝对象互相独立。 深拷贝就是对目标的完全拷贝，不像浅拷贝那样只是复制了一层引用，就连值也都复制了。 只要进行了深拷贝，它们老死不相往来，谁也不会影响谁。 一般情况下，只需使用系统提供的浅拷贝构造函数即可，但是，如果对象的数据成员包括指向堆空间的指针，就不能使用这种拷贝方式，因为两个对象都拥有同一个资源，对象析构时，该资源将经历两次资源返还，此时必须自定义深拷贝构造函数，为创建的对象分配堆空间，否则会出现动态分配的指针变量悬空的情况。 深拷贝会拷贝所有的属性，并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。 实现深拷贝的方法： 利用 JSON.parse 和 JSON.stringify123456789var array = [&#123; x: 1, regExp: new RegExp('1'), func: function() &#123;&#125;, &#125;, 2, 3]var cloneArray = JSON.parse(JSON.stringify(array))cloneArray[0].x = 0console.log(cloneArray[0].x, array[0].x) // 0, 1console.log(cloneArray[0].regExp, cloneArray[0].func) // undefined, undefined 缺点：只能适用于一些简单的情况，能正确处理的对象只有 Number, String, Boolean, Array, 扁平对象，即那些能够被 json 直接表示的数据结构。RegExp 对象、Function 对象等没办法转成 JSON，所以不能被处理，会被忽略，导致丢失。 利用递归来实现每一层都重新创建对象并赋值1234567891011121314151617181920212223242526272829var array = [&#123; x: 1, regExp: new RegExp('1'), func: function() &#123;&#125;, &#125;, 2, 3]function deepClone(obj) &#123; if (/(Array|Object)]/gi.test(Object.prototype.toString.call(obj))) &#123; var cloneObj = obj instanceof Array ? [] : &#123;&#125; for (var key in obj) &#123; if (obj.hasOwnProperty(key)) &#123; var prop = obj[key] if (/(Array|Object)]/gi.test(Object.prototype.toString.call(prop))) &#123; cloneObj[key] = prop instanceof Array ? [] : &#123;&#125; cloneObj[key] = deepClone(prop) &#125; else &#123; cloneObj[key] = prop &#125; &#125; &#125; return cloneObj &#125; else &#123; return obj &#125;&#125;var cloneArray = deepClone(array)cloneArray[0].x = 0console.log(cloneArray[0].x, array[0].x) // 0, 1console.log(cloneArray[0].regExp, cloneArray[0].func) // /1/, ƒ () &#123;&#125;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript数据类型]]></title>
    <url>%2Fzh%2F2018%2F08%2F14%2FJavaScript%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[JavaScript 中七种数据类型(内置类型)，分为两大类型：基本类型和对象(object)可分为两大类，即原始类型和引用类型。 六种原始类型：null，undefined，boolean，number，string，symbol 一种引用类型：对象(object)。这里的 object 是广泛上的一切对像，即一切引用类型。 JavaScript 变量JavaScript 中变量、函数名、运算符以及其他一切东西都是区分大小写的。 变量是弱类型的。 变量名需要遵守两条简单的规则： 第一个字符必须是字母、下划线(_)或美元符号($) 余下的字符可以是下划线、美元符号或任何字母或数字字符 著名的变量命名规则： Camel 标记法，首字母是小写的，接下来的字母都以大写字符开头：var myTestValue = 0 Pascal 标记法，首字母是大写的，接下来的字母都以大写字符开头：var MyTestValue = 0 匈牙利类型标记法，在以 Pascal 标记法命名的变量前附加一个小写字母(或小写字母序列)，说明该变量的类型：var iMyTestValue = 0 JavaScript 数据类型 JavaScript 数据类型(内置类型) 原始类型(primitive type, 基本类型) null undefined boolean number NaN string symbol 引用类型，类(class)，对象 本地对象(native object) Object Array Boolean Number String Function Date RegExp Error EvalError RangeError ReferenceError SyntaxError TypeError URIError 内置对象(built-in object) Global 对象 Math 对象 宿主对象(host objec) BOM DOM Numberjs 的数字类型是浮点类型的，没有整型。并且浮点类型基于 IEEE 754 双精度标准(64位)实现，在使用中会遇到某些 Bug。 最大数、最小数、正负无穷js 中可表示的最大的数为 Number.MAX_VALUE，近似值为 1.7976931348623157e+308。 12345Number.MAX_VALUE // 1.7976931348623157e+308Number.MAX_VALUE + 1 // 1.7976931348623157e+308Number.MAX_VALUE === Number.MAX_VALUE + 1 // true js 中可表示的最大的数为 Number.MIN_VALUE，接近 0，但不是负数，近似值为 5e-324。 123Number.MIN_VALUE // 5e-324Number.MIN_VALUE === 1 - Number.MIN_VALUE // true 正无穷 Infinity，负无穷 -Infinity。溢出时返回。 12345Number.MAX_VALUE * (1 + Number.MIN_VALUE) === Number.MAX_VALUE // trueNumber.MAX_VALUE * 1.1 // InfinityNumber.MAX_VALUE * -1.1 // -Infinity 最大安全整数、最小安全整数js 最大安全整数是 Number.MAX_SAFE_INTEGER，最小安全整数是 Number.MIN_SAFE_INTEGER， 1234567Number.MAX_SAFE_INTEGER // 9007199254740991Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1 // trueNumber.MIN_SAFE_INTEGER // -9007199254740991Number.MIN_SAFE_INTEGER === 1 - Math.pow(2, 53) // true 2 的 53 次方js 安全整数的范围是 (Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER) 即 -2^53~2^53 (不包含边界) 。 安全整数，意思是说能够 one-by-one 表示的整数，也就是说在(-2^53, 2^53)范围内，双精度数表示和整数是一对一的，反过来说，在这个范围以内，所有的整数都有唯一的浮点数表示，这叫做安全整数。超过这个范围，会有两个或更多整数的双精度表示是相同的；反过来说，超过这个范围，有的整数是无法精确表示的，只能round到与它相近的浮点数(说到底就是科学计数法)表示，这种情况下叫做不安全整数。 12345678910111213Math.pow(2, 53) // 9007199254740992Math.pow(2, 53) === Math.pow(2, 53) + 1 // trueMath.pow(2, 53) + 1 // 9007199254740992Math.pow(2, 53) + 2 // 9007199254740994Math.pow(2, 53) + 3 // 9007199254740996Math.pow(2, 53) + 4 // 9007199254740996Math.pow(2,53)+ 5 // 9007199254740996 当运算数与运算结果都处于安全整数的范围内时，才能保证 js 运算结果正确。 请求接口中返回一个整数，例如订单号，是个不安全整数，就会导致前端处理异常！ 1201808221019001777 // 被处理成 201808221019001800 js 安全整数的范围为啥是 (Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER) 即 -2^53~2^53 (不包含边界) ？ js 里数字类型只有一种，Number 类型，是双精度浮点型，都是 64-bit (1bit 的符号位，11bits 的指数部分，以及 52bits 的小数部分) 的双精度浮点数(double)！ js 里的整型 int 是 双精度浮点型 double 的一个子集，而不是一个独立的数据类型。 由于浮点数不是精确的值，所以涉及小数的比较和运算要特别小心！引申问题0.1 + 0.2 为什么不等于 0.3。 IEEE 754 双精度浮点数。 参考1 参考3 参考2 0.1 + 0.2 为什么不等于 0.31230.1 + 0.2 != 0.3 // trueparseFloat((0.1 + 0.2).toFixed(10)) === 0.3 // true toFixed(num) 可把 Number 四舍五入为指定小数位数的数字。有效数字姑且看作最多有 10 位小数。num 是小数位数，规定是 0-20，有些实现可以支持更大的数值范围，例如 chrome 可以是 0-100。 NaNNaN 也属于 number 类型，并且 NaN 不等于自身。NaN 是除对象外，唯一一个不等于自身的值。 12345typeof NaN // 'number'!NaN // trueNaN != NaN // true 一个表达式中如果有减号 -、乘号 * 或 除号 / 等运算符时，js 引擎会在计算之前试图将运算符两边的变量转化为 number 类型，如果转化失败，表达式将返回 NaN。 直接使用 Number, parseInt 或 parseFloat 将一个非数字的值转化为数字时，表达式返回 NaN。 1234'abc' - 1 // NaNNumber('abc') // NaNparseInt('abc') // NaNparseFloat('abc') // NaN 如何判断 NaN？必须是 Number.isNaN()。 12345678910isNaN(NaN) // trueNumber.isNaN(NaN) // trueisNaN('abc') // trueisNaN('abc' - 1) // trueisNaN(true) // falseNumber.isNaN('abc') // falseNumber.isNaN('abc' - 1) // trueNumber.isNaN(true) // false 我们注意看 isNaN(&#39;abc&#39;) 返回 true，而 Number.isNaN(&#39;abc&#39;) 返回 false。显然 Number.isNaN 更符合我们的要求。 isNaN() 函数用于检查其参数是否是非数字值。如果参数值为 NaN 或字符串、对象、undefined 等非数字值，则返回 true, 否则返回 false。会先强制转化为数字形式。也就是说： 1isNaN(param) -&gt; isNaN(Number(param)) Number.isNaN() 和全局函数 isNaN() 相比，该方法不会强制将参数转换成数字，只有在参数是真正的数字类型，且值为 NaN 的时候才会返回 true。 Polyfill 123Number.isNaN = Number.isNaN || function (value) &#123; return typeof value === "number" &amp;&amp; isNaN(value)&#125; 在数字计算或转化中，true 就是 1，false 就是 0。 NaN 为啥不等于自身？NaN 即 Not a Number , 不是一个数字。我们可以看到 ‘abc’ - 1 的结果是 NaN，’abc’ + 1 的结果也是 NaN，显然 ‘abc’ - 1 不等于 ‘abc’ + 1。NaN 可以代表一切 Not a Number 的数。 比较NaN 不等于任何一个变量，包括它自己！ 1230 == false // true1 == true // true 在数字计算中，true 就是 1，false 就是 0。 Boolean12345true - 1 // -1Number(true) // 1parseInt(true) // NaNparseFloat(true) // NaN 在数字计算中，true 就是 1，false 就是 0。 parseInt 和 parseFloat 接受参数是 string 类型，非 string 类型的需要先转化为 string 类型。 1parseInt(true) -&gt; parseInt(String(true)) -&gt; parseInt('true') -&gt; NaN nullnull 可以等于 null 或者 undefined。 12null == null // truenull == undefined // true null 是变量值为 null，undefined 是变量本身 undefined。 null 和 undefined 都表示“值的空缺”，你可以认为 undefined 是表示系统级的、出乎意料的或类似错误的值的空缺，而 null 是表示程序级的、正常的或在意料之中的值的空缺。 undefined 是访问一个未初始化的变量时返回的值，而 null是访问一个尚未存在的对象时所返回的值。因此，可以把 undefined 看作是空的变量，而 null 看作是空的对象。 12345678// foo现在已经是知存在的，但是它没有类型或者是值：var foo = null;foo;// null// foo不存在，它从来没有被定义过或者是初始化过：foo;// "ReferenceError: foo is not defined" 123typeof null // 'object'null instanceof Object // false Typeoftypeof 对于基本类型，除了 null 都可以显示正确的类型！ 1234567891011typeof undefined // 'undefined'typeof bbbbbb // bbbbbb 没有声明，但是还会显示 undefinedtypeof true // 'boolean'typeof 1 // 'number'typeof NaN // 'number'typeof '1' // 'string'typeof Symbol() // 'symbol' typeof 对于对象，除了函数都会显示 object 123456typeof [] // 'object'typeof &#123;&#125; // 'object'typeof Array // 'function'typeof Object // 'function'typeof setTimeout // 'function' 对于 null 来说，虽然它是基本类型，但是会显示 object，这是一个存在很久了的 Bug。 1typeof null // 'object' PS：为什么会出现这种情况呢？因为在 js 的最初版本中，使用的是 32 位系统，为了性能考虑使用低位存储了变量的类型信息，000 开头代表是对象，然而 null 表示为全零，所以将它错误的判断为 object。虽然现在的内部类型判断代码已经改变了，但是对于这个 Bug 却是一直流传下来。 如何判断 null ？ 123null === null // truenull == undefined // true instanceofinstanceof 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 prototype。 1234567891011var a = &#123;&#125;var b = []var c = function () &#123;&#125;a instanceof Object // trueb instanceof Array // truec instanceof Function // truenull instanceof Object // false 试着实现一下 instanceof 1234567891011121314151617181920212223242526function _instanceof (left, right) &#123; // 获得类型的原型 let prototype = right.prototype // 获得对象的原型 left = left.__proto__ // 判断对象的类型是否等于类型的原型 while (true) &#123; if (left === null) return false if (prototype === left) return true left = left.__proto__ &#125;&#125;var a = &#123;&#125;var b = []var c = function () &#123;&#125;_instanceof(a, Object)_instanceof(b, Array)_instanceof(c, Function) Object.prototype.toString.call(value)想获得一个变量的正确类型，可以通过 Object.prototype.toString.call(value)，可以获得类似 [Object Type] 的字符串。 12345678910111213141516171819202122232425var a = &#123;&#125;var b = []var c = function () &#123;&#125;var d = new Date()function E () &#123;&#125;var e = new E()Object.prototype.toString.call(a) // [object Object]Object.prototype.toString.call(b) // [object Array]Object.prototype.toString.call(c) // [object Function]Object.prototype.toString.call(d) // [object Date]Object.prototype.toString.call(e) // [object Object]Object.prototype.toString.call(null) // [object Null]Object.prototype.toString.call(undefined) // [object Undefined]Object.prototype.toString.call(true) // [object Boolean]Object.prototype.toString.call(1) // [object Number]Object.prototype.toString.call(NaN) // [object Number]Object.prototype.toString.call('a') // [object String]Object.prototype.toString.call(Symbol()) // [object Symbol] Polyfill 123Number.isNaN = Number.isNaN || function (value) &#123; return typeof value === "number" &amp;&amp; isNaN(value)&#125; 变量的值变量可以存在两种类型的值，即原始值和引用值。 原始类型的值，就是原始值。 引用类型的值，就是引用值。 原始值，存储在栈(stack)中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。栈区包括了变量的标识符和变量的值。 引用值，存储在堆(heap)中的对象，也就是说，存储在变量处的值是一个指针(point)，指向存储对象的内存处。 原始类型原始值，存储在栈(stack)中的简单数据段，也就是说，它们的值直接存储在变量访问的位置。栈区包括了变量的标识符和变量的值。 按值传递(call by value)123456789var a, b // undefined, undefineda = 0 // 0b = a // 0a = '1' // '1'console.log(a, b, typeof a, typeof b) // '1' 0 string number 上面 a 的改变没有改变 b，说明原始类型是按值传递的。赋值时创建了一块新的内存空间。 按值传递是最常用的求值策略，传递的是值的拷贝，也就是说传递后就互不相关了。 12345678910var num = 0function foo (param) &#123; // b 是形参 param += 1 console.log(num, param) // 0, 1&#125;foo(num) // a 是实参 函数的形参是被调用时所传实参的副本。修改形参的值并不会影响实参。 不可变(immutable)性质基本类型，其值是不可修改的，也不能为其添加属性和方法。 12345678910111213var str = 'abc'str[0] // 'a'str[0] = 'd'console.log(str[0], str) // 'a', 'abc'str.age = 24console.log(str.age, str) // undefined, 'abcstr.method = function () &#123;&#125;console.log(str.method, str) // undefined, 'abc 引用类型引用值，存储在堆(heap)中的对象，也就是说，存储在变量处的值是一个指针(point)，指向存储对象的内存处。 引用类型的存储空间将从堆(heap)中分配。由于引用值的大小会改变，所以不能把它放在栈(stack)中，否则会降低变量查寻的速度。 相反，放在变量的栈(stack)空间中的值是该对象存储在堆(heap)中的地址。 地址的大小是固定的，所以把它存储在栈(stack)中对变量性能无任何负面影响。 对象的属性constructor，对创建对象的函数的引用(指针)，指回原构造函数。对于 object 对象，该指针指向原始的 Object() 函数。 __proto__，隐式原型，是每个对象都有的一个属性。一个对象的隐式原型指向构造该对象的构造函数的原型，这也保证了实例能够访问在构造函数原型中定义的属性和方法。 prototype，原型属性，是 Function 函数对象(除了内置函数对象)才具有的属性，是通过调用构造函数而创建的那个对象实例的原型对象，是一个指针，指向一个对象，这个对象的用途就是包含所有实例共享的属性和方法(我们把这个对象叫做原型对象)。在原型对象里有共有的方法，所有构造函数声明的实例都可以共享这个方法。 每个函数都有 prototype 属性，除了 Function.prototype.bind()，该属性指向原型。 每个对象都有 __proto__ 属性，指向了创建该对象的构造函数的原型。其实这个属性指向了 [[prototype]]，但是 [[prototype]] 是内部属性，我们并不能访问到，所以使用 _proto_ 来访问。 对象可以通过 __proto__ 来寻找不属于该对象的属性，__proto__ 将对象连接起来组成了原型链。 如果你想更进一步的了解原型，可以仔细阅读深度解析原型中的各个难点。 123456789101112131415161718192021222324252627282930313233var func = function () &#123;&#125;var obj = &#123;&#125;func.constructor // ƒ Function() &#123; [native code] &#125; Function 构造函数func.constructor === Function // trueobj.constructor // ƒ Object() &#123; [native code] &#125; Object 构造函数obj.constructor === Objectfunc.__proto__ // ƒ () &#123; [native code] &#125; Function 构造函数的原型obj.__proto__ // &#123; constructor: f Object(), ... &#125; Object 构造函数的原型func.prototype // &#123; constructor: func (), ... &#125;func.__proto__ === Function.prototype // trueobj.__proto__ === Object.prototype // truefunc.__proto__.__proto__ === obj.__proto__ // trueFunction.constructor // ƒ Function() &#123; [native code] &#125;Object.constructor // ƒ Function() &#123; [native code] &#125;Function.__proto__ // ƒ () &#123; [native code] &#125;Object.__proto__ // ƒ () &#123; [native code] &#125;Function.prototype // ƒ () &#123; [native code] &#125;Object.prototype // &#123; constructor: f Object(), ... &#125;Function.__proto__ === Function.prototype // trueFunction.prototype === Object.__proto__ // trueFunction.__proto__ === Object.__proto__ // trueFunction.__proto__.__proto__ === Object.__proto__.__proto__ // trueFunction.__proto__.__proto__ === Object.prototype // true 函数不是对象吗？为什么 func 和 obj 的 constructor 和 _proto_ 不一样？ func 是函数对象，是特殊的对象，func._proto_ 指向了构造该函数对象的构造函数的原型！构造该函数对象的构造函数是 func.constructor，即 Function，其原型是 Function.prototype！所以 func.__proto__ === func.constructor.prototype === Function.prototype 成立！ obj 是一般对象，obj._proto_ 指向了构造该函数对象的构造函数的原型！构造该函数对象的构造函数是 obj.constructor，即 Object，其原型是 Object.prototype！所以 obj.__proto__ === obj.constructor.prototype === Object.prototype 成立！ Object 是所有对象的爸爸，所有对象都可以通过 __proto__ 找到它 Function 是所有函数的爸爸，所有函数都可以通过 __proto__ 找到它 Function.prototype 和 Object.prototype 是两个特殊的对象，他们由引擎来创建 除了以上两个特殊对象，其他对象都是通过构造器 new 出来的 函数的 prototype 是一个对象，也就是原型 对象的 __proto__ 指向原型， __proto__ 将对象和原型连接起来组成了原型链 一脸懵逼！！！！！ 调用对象的 Object.getPrototypeOf() 方法读取 [[Prototype]] 属性的值，代替 __proto__。 12345var func = function () &#123;&#125;var obj = &#123;&#125;Object.getPrototypeOf(func) === func.__proto__ // trueObject.getPrototypeOf(obj) === obj.__proto__ // true 对象的方法hasOwnProperty(property) 判断指定属性是否为自有属性。123456789var obj = &#123; a: 1&#125;obj.hasOwnProperty('a') // true，a 是自有属性obj.hasOwnProperty('toString') // false，toString 不是自有属性，是原型属性'a' in obj // true'toString' in obj // true 123function hasPrototypeProperty (obj, property) &#123; return !obj.hasOwnProperty(property) &amp;&amp; property in obj&#125; isPrototypeOf(object) 判断该对象是否为另一个对象的原型。12345678910111213var obj = &#123; a: 1&#125;obj.isPrototypeOf(obj) // falseobj.__proto__.isPrototypeOf(obj) // trueObject.isPrototypeOf(obj) // falseObject.__proto__.isPrototypeOf(obj) // falseObject.prototype.isPrototypeOf(obj) // true 面向对象编程对象、类、实例 对象ECMA-262 把对象(object)定义为“属性的无序集合，每个属性存放一个原始值、对象或函数”。严格来说，这意味着对象是无特定顺序的值的数组。 对象是无特定顺序的值的数组，这就是为什么 for...in 不能保证顺序的原因吧。 尽管 ECMAScript 如此定义对象，但它更通用的定义是基于代码的名词(人、地点或事物)的表示。 对象由特性(attribute)构成，特性可以是原始值，也可以是引用值。如果特性存放的是函数，它将被看作对象的方法(method)，否则该特性被看作对象的属性(property)。 类每个对象都由类定义，可以把类看做对象的配方。 类不仅要定义对象的接口(interface)(开发者访问的属性和方法)，还要定义对象的内部工作(使属性和方法发挥作用的代码)。编译器和解释程序都根据类的说明构建对象。 实例程序使用类创建对象时，生成的对象叫作类的实例(instance)。 对类生成的对象的个数的唯一限制来自于运行代码的机器的物理内存。每个实例的行为相同，但实例处理一组独立的数据。 由类创建对象实例的过程叫做实例化(instantiation)。 四种基本能力 封装 - 把相关的信息(无论数据或方法)存储在对象中的能力 聚集 - 把一个对象存储在另一个对象内的能力 继承 - 由另一个类(或多个类)得来类的属性和方法的能力 多态 - 编写能以多种方法运行的函数或方法的能力 对象作用域作用域指的是变量的适用范围。 公用、私有和受保护作用域在传统的面向对象程序设计中，主要关注于公用和私有作用域。公用作用域中的对象属性可以从对象外部访问，即开发者创建对象的实例后，就可使用它的公用属性。而私有作用域中的属性只能在对象内部访问，即对于外部世界来说，这些属性并不存在。这意味着如果类定义了私有属性和方法，则它的子类也不能访问这些属性和方法。 受保护作用域也是用于定义私有的属性和方法，只是这些属性和方法还能被其子类访问。 ECMAScript 只有公用作用域对 ECMAScript 讨论上面这些作用域几乎毫无意义，因为 ECMAScript 中只存在一种作用域 - 公用作用域。ECMAScript 中的所有对象的所有属性和方法都是公用的。因此，定义自己的类和对象时，必须格外小心。记住，所有属性和方法默认都是公用的！ 由于缺少私有作用域，开发者确定了一个规约，说明哪些属性和方法应该被看做私有的。这种规约规定在属性前后加下划线： 1obj._color_ = 'blue' // 属性 color 被看作是私有的。注意，下划线并不改变属性是公用属性的事实，只是作为提示 静态作用域静态作用域定义的属性和方法任何时候都能从同一位置访问。 在 Java 中，类可具有属性和方法，无需实例化该类的对象，即可访问这些属性和方法，例如 java.net.URLEncoder 类，它的函数 encode() 就是静态方法。 ECMAScript 没有静态作用域严格来说，ECMAScript 并没有静态作用域。不过，它可以给构造函数提供属性和方法。 构造函数只是函数。函数是对象，对象可以有属性和方法。 1234567891011function sayHello() &#123; console.log('hello')&#125;sayHello.alternate = function () &#123; console.log('hi')&#125;sayHello() // 'hello'sayHello.alternate() // 'hi' 方法 alternate() 实际上是函数 sayHello 的方法。可以像调用常规函数一样调用 sayHello() 输出 “hello”，也可以调用 sayHello.alternate() 输出 “hi”。即使如此，alternate() 也是 sayHello() 公用作用域中的方法，而不是静态方法。 关键字 this，指向调用该方法的对象1234567var oCar = new Object()oCar.color = 'red'oCar.showColor = function () &#123; console.log(this.color, this) // this 指向调用该方法的对象&#125;oCar.showColor() // 'red' 为什么要使用 this ？在实例化对象时，总是不能确定开发者会使用什么样的变量名。使用 this，即可在任何多个地方重用同一个函数。 123456789101112131415function showColor () &#123; console.log(this.color, this) // this 指向调用该方法的对象&#125;var oCar = new Object()oCar.color = 'red'oCar.showColor = showColorvar oBike = new Object()oBike.color = 'blue'oBike.showColor = showColoroCar.showColor() // 'red'oBike.showColor() // 'blue' 注意，引用对象的属性时，必须使用 this 关键字123function showColor () &#123; console.log(color)&#125; 如果不用对象或 this 关键字引用变量，ECMAScript 就会把它看作局部变量或全局变量。然后该函数将查找名为 color 的局部或全局变量。 12345678910var color = 'red'function showColor () &#123; var color = 'blue' console.log(color) // 局部查找，发现 color&#125;showColor() // 'blue'console.log(color) // 'red' 12345678910var color = 'red'function showColor () &#123; color = 'blue' // 这里 color 被调用进行赋值运算，但是局部查找没有，在全局查找到了 console.log(color)&#125;showColor() // 'blue'console.log(color) // 'blue' 定义类或对象 工厂方式，原始的方式 构造函数方式 原型方式 混合的构造函数/原型方式 动态原型方法 混合工厂方式 工厂方式，原始的方式能创建并返回特定类型的对象的工厂函数(factory function)。 123456789101112131415161718function showColor () &#123; console.log(this.color);&#125;function createCar (sColor, iDoors, iMpg) &#123; var oTempCar = new object; oTempCar.color = sColor; oTempCar.doors = iDoors; oTempCar.mpg = iMpg; oTempCar.showColor = showColor; // 从功能上讲，这样解决了重复创建函数对象的问题；但是从语义上讲，该函数不太像是对象的方法 return oTempCar;&#125;var oCar1 = createCar("red", 4, 23);var oCar2 = createCar("blue", 3, 25);oCar1.showColor(); //输出 "red"oCar2.showColor(); //输出 "blue" 构造函数方式第一步选择类名，即构造函数的名字。根据惯例，这个名字的首字母大写，以使它与首字母通常是小写的变量名分开。 12345678910111213141516function showColor () &#123; console.log(this.color);&#125;function Car (sColor, iDoors, iMpg) &#123; this.color = sColor; this.doors = iDoors; this.mpg = iMpg; this.showColor = showColor; // 从功能上讲，这样解决了重复创建函数对象的问题；但是从语义上讲，该函数不太像是对象的方法&#125;var oCar1 = new Car("red", 4, 23);var oCar2 = new Car("blue", 3, 25);oCar1.showColor(); //输出 "red"oCar2.showColor(); //输出 "blue" 首先在构造函数内没有创建对象，而是使用 this 关键字。使用 new 运算符构造函数时，在执行第一行代码前先创建一个对象，只有用 this 才能访问该对象。然后可以直接赋予 this 属性，默认情况下是构造函数的返回值(不必明确使用 return 运算符)。 原型方式该方式利用了函数对象的 prototype 属性，可以把它看成创建新对象所依赖的原型。 这里，首先用空构造函数来设置类名。然后所有的属性和方法都被直接赋予 prototype 属性。 1234567891011121314function Car () &#123;&#125;Car.prototype.color = "blue";Car.prototype.doors = 4;Car.prototype.mpg = 25;Car.prototype.showColor = function () &#123; console.log(this.color);&#125;; // 从语义上讲，该函数确实是对象的方法var oCar1 = new Car();var oCar2 = new Car();oCar1.showColor(); //输出 "red"oCar2.showColor(); //输出 "blue" 首先定义构造函数(Car)，其中无任何代码。接下来的几行代码，通过给 Car 的 prototype 属性添加属性去定义 Car 对象的属性。调用 new Car() 时，原型的所有属性都被立即赋予要创建的对象，意味着所有 Car 实例存放的都是指向 showColor() 函数的指针。从语义上讲，所有属性看起来都属于一个对象，因此解决了前面两种方式存在的问题。 此外，使用这种方式，还能用 instanceof 运算符检查给定变量指向的对象的类型。 1oCar1 instanceof Car // true 但是，使用原型方式，不能通过给构造函数传递参数来初始化属性的值！ 因为 Car1 和 Car2 的 color 属性都等于 “blue”，doors 属性都等于 4，mpg 属性都等于 25。这意味着必须在对象创建后才能改变属性的默认值，这点很令人讨厌，但还没完。真正的问题出现在属性指向的是对象，而不是函数时。函数共享不会造成问题，但对象却很少被多个实例共享。 混合的构造函数/原型方式1234567891011121314151617function showColor () &#123; console.log(this.color);&#125;function Car (sColor, iDoors, iMpg) &#123; this.color = sColor; this.doors = iDoors; this.mpg = iMpg;&#125;Car.prototype.showColor = showColorvar oCar1 = new Car("red", 4, 23);var oCar2 = new Car("blue", 3, 25);oCar1.showColor(); //输出 "red"oCar2.showColor(); //输出 "blue" 所有的非函数属性都在构造函数中创建，意味着又能够用构造函数的参数赋予属性默认值了。因为只创建 showColor() 函数的一个实例，所以没有内存浪费。因为使用了原型方式，所以仍然能利用 instanceof 运算符来判断对象的类型。 这种方式是 ECMAScript 采用的主要方式，最常用！它具有其他方式的特性，却没有他们的副作用。但还是不够完美。 动态原型方法动态原型方法的基本想法与混合的构造函数/原型方式相同，即在构造函数内定义非函数属性，而函数属性则利用原型属性定义。唯一的区别是赋予对象方法的位置。 1234567891011121314function Car(sColor, iDoors, iMpg) &#123; this.color = sColor this.doors = iDoors this.mpg = iMpg this.drivers = new Array('Mike', 'John') if (typeof Car._initialized == 'undefined') &#123; Car.prototype.showColor = function () &#123; console.log(this.color) &#125; Car._initialized = true &#125;&#125; 直到检查 typeof Car._initialized 是否等于 &quot;undefined&quot; 之前，这个构造函数都未发生变化。这行代码是动态原型方法中最重要的部分。如果这个值未定义，构造函数将用原型方式继续定义对象的方法，然后把 Car._initialized 设置为 true。如果这个值定义了(它的值为 true 时，typeof 的值为 Boolean)，那么就不再创建该方法。简而言之，该方法使用标志(_initialized)来判断是否已给原型赋予了任何方法。该方法只创建并赋值一次，传统的 OOP 开发者会高兴地发现，这段代码看起来更像其他语言中的类定义了。 混合工厂方式1234567891011function Car () &#123; var oTempCar = new Object oTempCar.color = 'blue' oTempCar.doors = 4 oTempCar.mpg = 25 oTempCar.showColor = function() &#123; console.log(this.color) &#125; return oTempCar&#125; 与经典方式不同，这种方式使用 new 运算符，使它看起来像真正的构造函数。 由于在 Car() 构造函数内部调用了 new 运算符，所以将忽略第二个 new 运算符(位于构造函数之外)，在构造函数内部创建的对象被传递回变量 car。 这种方式在对象方法的内部管理方面与经典方式有着相同的问题。强烈建议：除非万不得已，还是避免使用这种方式。 修改对象通过使用 ECMAScript，不仅可以创建对象，还可以修改已有对象的行为。 prototype 属性不仅可以定义构造函数的属性和方法，还可以为本地对象添加属性和方法。 创建新方法把数字对象直接转换为十六进制字符串： 123456Number.prototype.toHexString = function () &#123; return this.toString(16)&#125;var iNum = 15console.log(iNum.toHexString()) // f 重命名已有方法可以给 Array 类添加两个方法 enqueue() 和 dequeue()，只让它们反复调用已有的 push() 和 shift() 方法即可： 1234567Array.prototype.enqueue = function (vItem) &#123; this.push(vItem)&#125;Array.prototype.dequeue = function () &#123; return this.shift()&#125; Function 的 toString() 方法通常输出的是函数的源代码。覆盖该方法，可以返回另一个字符串(在这个例子中，可以返回 “Function code hidden”)。不过，toString() 指向的原始函数怎么了呢？它将被无用存储单元回收程序回收，因为它被完全废弃了。没有能够恢复原始函数的方法，所以在覆盖原始方法前，比较安全的做法是存储它的指针，以便以后的使用。 123456789Function.prototype.originalToString = Function.prototype.toStringFunction.prototype.toString = function () &#123; if (this.originalToString().length &gt; 100) &#123; return 'Function too long to display.' &#125; else &#123; return this.originalToString() &#125;&#125; 极晚绑定(Very Late Binding)从技术上讲，根本不存在极晚绑定。本书采用该术语描述 ECMAScript 中的一种现象，即能够在对象实例化后再定义它的方法。例如： 1234567var o = new Object()Object.prototype.sayHi = function () &#123; console.log('hi')&#125;o.sayHi() 在大多数程序设计语言中，必须在实例化对象之前定义对象的方法。这里，方法 sayHi() 是在创建 Object 类的一个实例之后来添加进来的。在传统语言中不仅没听说过这种操作，也没听说过该方法还会自动赋予 Object 对象的实例并能立即使用（接下来的一行）。 注意：不建议使用极晚绑定方法，因为很难对其跟踪和记录。不过，还是应该了解这种可能。 ES6 之 classES6 提供了更接近传统语言的写法，引入了 Class（类）这个概念，作为对象的模板。通过 class 关键字，可以定义类。 基本上，ES6 的 class 可以看作只是一个语法糖，它的绝大部分功能，ES5 都可以做到，新的 class 写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。 1234567891011121314151617181920function Point(x, y) &#123; this.x = x this.y = y&#125;Point.prototype.toString = function () &#123; return '(' + this.x + ', ' + this.y + ')'&#125;//定义类class Point &#123; constructor (x, y) &#123; this.x = x this.y = y &#125; toString () &#123; return '(' + this.x + ', ' + this.y + ')' &#125;&#125; 上面代码定义了一个“类”，可以看到里面有一个 constructor 方法，这就是构造方法，而 this 关键字则代表实例对象。也就是说，ES5 的构造函数 Point，对应 ES6 的 Point 类的构造方法。 Point 类除了构造方法，还定义了一个 toString 方法。注意，定义“类”的方法的时候，前面不需要加上 function 这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。 ES6 的类，完全可以看作构造函数的另一种写法。 123456class Point &#123; // ...&#125;typeof Point // "function"Point === Point.prototype.constructor // true 上面代码表明，类的数据类型就是函数，类本身就指向构造函数。 使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。 构造函数的 prototype 属性，在 ES6 的“类”上面继续存在。事实上，类的所有方法都定义在类的 prototype 属性上面。 123456789101112131415161718192021class Point &#123; constructor () &#123; // ... &#125; toString () &#123; // ... &#125; valueOf () &#123; // ... &#125;&#125;// 等同于Point.prototype = &#123; constructor () &#123;&#125;, toString () &#123;&#125;, valueOf () &#123;&#125;,&#125; 在类的实例上面调用方法，其实就是调用原型上的方法。 1234class B &#123;&#125;let b = new B();b.constructor === B.prototype.constructor // true 上面代码中，b 是 B 类的实例，它的 constructor 方法就是 B 类原型的 constructor 方法。 由于类的方法都定义在 prototype 对象上面，所以类的新方法可以添加在 prototype 对象上面。Object.assign 方法可以很方便地一次向类添加多个方法。 12345678910class Point &#123; constructor()&#123; // ... &#125;&#125;Object.assign(Point.prototype, &#123; toString () &#123;&#125;, valueOf () &#123;&#125;,&#125;) prototype 对象的 constructor 属性，直接指向“类”的本身，这与 ES5 的行为是一致的。 1Point.prototype.constructor === Point // true 另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。 123456789101112class Point &#123; constructor (x, y) &#123; // ... &#125; toString () &#123; // ... &#125;&#125;Object.keys(Point.prototype) // []Object.getOwnPropertyNames(Point.prototype) // ["constructor", "toString"] 上面代码中，toString 方法是 Point 类内部定义的方法，它是不可枚举的。这一点与 ES5 的行为不一致。 12345678910var Point = function (x, y) &#123; // ...&#125;Point.prototype.toString = function () &#123; // ...&#125;Object.keys(Point.prototype) // ["toString"]Object.getOwnPropertyNames(Point.prototype) // ["constructor", "toString"] class 的简介大致就这些，想学习更多 class 的知识，敬请期待后面对 class 的深入探究。 迫不及待想学习，可以阅读 ES6 之 Class 的基本语法 类型转换转 Boolean在条件判断时，除了 undefined， null， false， NaN， &#39;&#39;， 0，-0，其他所有值都转为 true，包括所有对象，甚至是 []、{}。 1234567891011const arr = [undefined, null, false, NaN, '', 0, -0, [], &#123;&#125;]arr.forEach(item =&gt; &#123; if (item) &#123; console.log(true) &#125; else &#123; console.log(false) &#125; console.log(`$&#123;item&#125;转Boolean为$&#123;!!item&#125;`)&#125;) 转 Boolean，有 !! + 变量 或 Boolean(变量) 条件判断有：if，三目运算，for，while，do...while、switch 等。 对象转基本类型对象在转换基本类型时，有 toString，valueOf，Symbol.toPrimitive。默认调用 toString。三个方法都可以重写，而且越后面优先级越大。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253var obj = &#123;&#125;obj.toString() // '[object Object]'obj.valueOf() // &#123;&#125;1 + obj // '1[object Object]''a' + obj // 'a[object Object]'var obj = &#123; toString () &#123; return 'a' &#125;,&#125;1 + obj // ‘1a’'a' + obj // 'aa'var obj = &#123; valueOf () &#123; return 1 &#125;,&#125;1 + obj // 2'a' + obj // 'a1'var obj = &#123; toString () &#123; return 'a' &#125;, valueOf () &#123; return 1 &#125;,&#125;1 + obj // 2'a' + obj // 'a1'var obj = &#123; toString () &#123; return 'a' &#125;, valueOf () &#123; return 1 &#125;, [Symbol.toPrimitive] () &#123; return 2 &#125;,&#125;1 + obj // 3'a' + obj // 'a2' 转字符串，有 &#39;&#39; + 变量 或 String(变量) 转数字，有 + 变量 或 Number(变量) 四则运算符只有当加法运算时，其中一方是字符串类型，就会把另一个也转为字符串类型。并且加法运算会触发三种类型转换：将值转换为原始值，转换为数字，转换为字符串。 其他运算只要其中一方是数字，那么另一方就转为数字。 加法运算的结果不一定是数字。其他运算的结果一定是数字。 1234567891011121314151 + '1' // '11'2 * '2' // 4[1, 2] + [2, 1] // '1,22,1'// [1, 2].toString() -&gt; '1,2'// [2, 1].toString() -&gt; '2,1'// '1,2' + '2,1' = '1,22,1'1 + '' // '1'，可以实现数字转字符串！'1' - 0 // 1，可以实现字符串转数字！+ '1' // 1，可以实现字符串转数字！ 对于加号需要注意这个表达式 &#39;a&#39; + + &#39;b&#39;。在加法运算中，一般在变量前加 ‘+’，可以保证变量转化为数字。 123'a' + + 'b' // -&gt; "aNaN"// 因为 + 'b' -&gt; NaN// 你也许在一些代码中看到过 + '1' -&gt; 1 == 操作符 上图中的 toPrimitive 就是对象转基本类型。 在 == 比较中，需要将【布尔值/字符串/】转化为【数值】，需要将【对象】转化为【基本类型】。 1234567891011121314151617181920212223242526null == NaN // falseundefined == false // falsenull == false // falseNaN == false // falsenull == undefined // true'' == false // true0 == false // true-0 == false // trueconsole.log(NaN == NaN) // falseconsole.log(null == null) // trueconsole.log([] == false) // trueconsole.log([] == []) // falseconsole.log([] == ![]) // trueconsole.log(&#123;&#125; == false) // falseconsole.log(&#123;&#125; == &#123;&#125;) // falseconsole.log(&#123;&#125; == !&#123;&#125;) // false 为何 [] == ![] // -&gt; true ？ 12345678910111213[] == ![]// [] 是真值，![] -&gt; false，即[] == false// 根据第 9 条得出[] == ToNumber(false)//ToNumber(false) -&gt; 0，即[] == 0// 根据第 11 条得出ToPrimitive([]) == 0// [].toString() -&gt; ''，即'' == 0// 根据第 7 条得出0 == 0 // -&gt; true null 只能和 null 或 undefined 相等，其他都不相等！ 同样，undefined 只能和 undefined 或 null 相等，其他都不相等！ 123456789null == null // truenull == undefined // truenull == 0 // falsenull == '' // falsenull == false // false 由于 0 的类型是数值，null 的类型是 null。因此上面的前 11 步都得不到结果，要到第 12 步才能得到 false。 相等运算符 === 操作符首先类型相等，其次判断 == 操作符]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[webpack中alias别名配置]]></title>
    <url>%2Fzh%2F2018%2F08%2F13%2Fwebpack%E4%B8%ADalias%E5%88%AB%E5%90%8D%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[webpack 中 alias 别名配置 1234567resolve: &#123; alias: &#123; '@': path.resolve(__dirname, 'src'), '@a': path.resolve(__dirname, 'src', 'assets'), '@c': path.resolve(__dirname, 'src', 'components'), &#125;&#125; 在 js 中使用： 123456789101112// 原本这样写import formatTime from '../../src/utils/formatTime'import banner from '../../src/assets/img/banner.png'import swiper from '../../src/components/swiper'// 现在可以这样写import formatTime from '@/utils/formatTime'import banner from '@/src/assets/img/banner.png'import swiper from '@/src/components/swiper'import banner from '@a/img/banner.png'import swiper from '@c/swiper' 在 scss 中使用： 1234567/* 原本这样写 */@import '../../src/assets/css/mixin';/* 现在可以这样写 */@import '~@src/assets/css/mixin';@import '~@a/css/mixin'; 在 template 中使用： 1234567&lt;!-- 原本这样写 --&gt;&lt;img src="../../src/assets/img/logo.png"&gt;&lt;!-- 现在可以这样写 --&gt;&lt;img src="~@/src/assets/img/logo.png"&gt;&lt;img src="~@a/img/logo.png"&gt; 注意区别，@ 前需要多加个 ~]]></content>
      <categories>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端面试题]]></title>
    <url>%2Fzh%2F2018%2F08%2F09%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[前端面试题 浏览器与浏览器内核浏览器内核，作用是帮助浏览器来渲染网页的内容，将页面内容和排版代码转换为用户所见的视图。 浏览器内核分成两部分：渲染引擎 (Layout Engine 或者 Rendering Engine) 和 JS 引擎。 渲染引擎，负责取得网页的内容 (HTML、XML、图像等)、整理讯息 (CSS 等)，以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS 引擎，负责解析 JavaScript 语言、执行 JavaScript 语言，来实现网页的动态效果。 browser caniuse browserslist in package.json 123456789&#123; "browserslist": [ "&gt; 1%", "last 3 versions", "ie &gt;= 9", "ios &gt;= 8", "android &gt;= 4.4" ]&#125; in .browserslistrc 1234567# Browsers that we support&gt; 1%last 3 versionsie &gt;= 9ios &gt;= 8android &gt;= 4.4 PC端Internet Explorer (IE 互联网探索者)，内核是：Trident Safari (游猎)、Google Chrome (谷歌)，内核是：WebKit (极速) Mozilla FireFox (FF 火狐)，内核是：Gecko Opera (欧朋)，内核是：Presto 移动端移动端的浏览器内核主要说的是系统内置浏览器的内核。 移动设备浏览器上常用的内核有 WebKit，Blink，Trident，Gecko 等。 其中 iPhone 和 iPad 等苹果 iOS 平台主要是 WebKit，Android 4.4 之前的 Android 系统浏览器内核是 WebKit，Android 4.4 系统浏览器切换到了 Chromium，内核是 Webkit 的分支 Blink，Windows Phone 8 系统浏览器内核是 Trident。 document.compatMode当前浏览器采用的渲染方式 BackCompat：标准兼容模式关闭。浏览器客户区宽度是 document.body.clientWidth。 CSS1Compat：标准兼容模式开启。浏览器客户区宽度是 document.documentElement.clientWidth。 块元素、行内元素、行内块元素块元素 display: blockdiv、p、nav、aside、header、footer、section、article、ul、li、address 等元素。 行内元素 display: inline不换行，设置 width、height 都无效，宽高由内容决定，但可以设置 line-height 来控制高度。margin 上下无效但左右有效，padding 上下左右都有效。 a、b、i、span 等元素。 行内块元素 display: inline-block除了具有行内元素不换行的特性，其他都是块元素的特性。设置 width、height 都有效，margin 上下左右都有效。 img、input 等元素。 盒模型https://segmentfault.com/a/1190000005116275 https://segmentfault.com/a/1190000005155084 block boxcontent + padding + border + margin line box每一行称为一条 line Box，它又是由这一行的许多 inline box 组成，它的高度可以直接由 line-height 决定，line boxes 的高度垂直堆叠形成了 containing box 的高度，就是我们见到的 div 或是 p 标签之类的高度了。 box-sizingbox-sizing: content-box | border-box 影响的其实就是内边距和边框。content-box 向外发散，border-box 向内收敛。 content-box: 默认值。宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框(元素默认效果。 如果你设置一个元素的宽为 100px，那么这个元素的内容区会有 100px 宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。 border-box: 元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度(推荐)。 如果你将一个元素的 width 设为 100px, 那么这 100px 会包含其它的 border 和 padding，内容区的实际宽度会是 width 减去 border + padding 的计算值。 大多数情况下 border-box 使得我们更容易的去设定一个元素的宽高。链接。所以我们常常这样设置： 123*, *:before, *:after &#123; box-sizing: border-box;&#125; BFC(边距重叠解决方案)布局传统布局布局的传统解决方案，基于盒状模型，依赖 display + position + float 这种传统布局，对于那些特殊布局非常不方便，比如 水平垂直居中，就不容易实现。 flex 布局flex 是 Flexible Box 的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。 采用 flex 布局的元素，称为 flex 容器(flex container)，简称”容器”。它的所有子元素自动成为容器成员，称为 flex 项目(flex item)，简称”项目”。 容器的属性 display: flex; flex-direction flex-wrap align-items justify-content flex-direction: row | row-reverse | column | column-reverse row(默认值)：主轴为水平方向，起点在左端 row-reverse：主轴为水平方向，起点在右端 column：主轴为垂直方向，起点在上沿 column-reverse：主轴为垂直方向，起点在下沿 其实就两种，row 横，column 纵 reverse 代表反转方向，排列顺序 flex-wrap: nowrap | wrap | wrap-reverse nowrap(默认)：不换行 wrap：换行，第一行在上方 wrap-reverse：换行，第一行在下方 align-items: flex-start | flex-end | center | baseline | stretch垂直对齐方式 flex-start：交叉轴的起点对齐。居上 flex-end：交叉轴的终点对齐。居下 center：交叉轴的中点对齐。居中 baseline: 项目的第一行文字的基线对齐 stretch(默认值)：如果项目未设置高度或设为 auto，将占满整个容器的高度 justify-content: flex-start | flex-end | center | space-between | space-around水平对齐方式 flex-start(默认值)：左对齐 flex-end：右对齐 center：居中 space-between：两端对齐，项目之间的间隔都相等 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍 实现【水平垂直居中】 display: flex; + align-items: center; + justify-content: center; position + top/left + margin position + top/left + transform positionstatic、fixed、relative、absolute、sticky 设置 position 的值为非 static，会提升元素的垂直地位 (z-index)。 设置 position 的值为 absolute、fixed，元素脱离文档流。 如果仅仅定义 position，不定义 top/margin/transform 等尾翼值，元素仍然停留在本身正常位置。 position: relative相对位置，相对元素本身正常位置。 fixed 与 absolute 的区别fixed 浮动定位是相对于浏览器视窗的。 absolute 绝对定位是相对于父级中设置 position 为 relative 或者 absolute 最近的父级元素。如果父级没有会向上查找，知道 html 根节点。 stickysticky 英文字面意思是粘，粘贴，所以可以把它称之为粘性定位。 position: sticky; 基于用户的滚动位置来定位。 粘性定位的元素是依赖于用户的滚动，在 position: relative 与 position: fixed 之间切换。 它的行为就像 position: relative; 而当页面滚动超出目标区域时，它的表现就像 position: fixed;，它会固定在目标位置。 元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。 这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。 1234.sticky &#123; position: sticky; top: 20px;&#125; 兼容性低 ios &gt;= 10.3 transformtransform 对普通元素的 N 多渲染影响 transform 提升元素的垂直地位 (z-index)当遭遇元素设置 margin 负值重叠的时候，如果没有 static 以外的 position 属性值的话，后面的元素是会覆盖前面的元素的。 但是，元素应用了 transform 属性之后，就会变得跟应用了 position: relative 一样，原本应该被覆盖的元素会雄起，变成覆盖其他元素。 transform 相当于给元素加了 position: relative。 transform 限制 position: fixed 的跟随效果设置 transform 的元素，其内部元素的 position: fixed 会失效，降级变成 position: absolute。 transform 相当于给元素加了 position: relative。 内部元素 position: fixed 变成了 position: absolute。 12345&lt;div style="transform: scale(1)"&gt; &lt;div style="position: fixed"&gt; fixed 失效 &lt;/div&gt;&lt;/div&gt; Chrome / FireFox 有这种 bug。 利用 这个 bug 可以使 fixed 元素相对于父级定位。 transform 改变 overflow 对 absolute 元素的限制absolute 绝对定位元素，如果含有 overflow 为非 visible 的父级元素，同时，该父级元素以及到该绝对定位元素之间任何嵌套元素都没有 position 为非 static 属性或 transform 属性的声明，则 overflow 对该 absolute 元素不起作用。 transform 相当于给元素加了 position: relative。 123456789101112131415&lt;div style="width: 100px;height: 100px;overflow: hidden;background: red"&gt; &lt;div style="width: 200px;height: 200px;background: blue"&gt;被修剪，溢出部分不显示&lt;/div&gt;&lt;/div&gt;&lt;div style="width: 100px;height: 100px;overflow: hidden;background: red"&gt; &lt;div style="width: 200px;height: 200px;background: blue;position: absolute"&gt;不会被修剪，溢出部分显示&lt;/div&gt;&lt;/div&gt;&lt;div style="width: 100px;height: 100px;overflow: hidden;background: red;position: relative"&gt; &lt;div style="width: 200px;height: 200px;background: blue;position: absolute"&gt;被修剪，溢出部分不显示&lt;/div&gt;&lt;/div&gt;&lt;div style="width: 100px;height: 100px;overflow: hidden;background: red;transform: scale(1)"&gt; &lt;div style="width: 200px;height: 200px;background: blue;position: absolute"&gt;被修剪，溢出部分不显示&lt;/div&gt;&lt;/div&gt; transform 限制 absolute 的 100% 宽度大小设置 absolute 元素宽度 100%, 则都会参照第一个 非 static 值的 position 或 不具有 transform 的祖先元素计算，没有就 window。 transform 相当于给元素加了 position: relative。 1234567891011&lt;div style="width: 100px;height: 100px;background: red"&gt; &lt;div style="width: 100%;height: 200px;background: blue"&gt;溢出部分显示&lt;/div&gt;&lt;/div&gt;&lt;div style="width: 100px;height: 100px;background: red;position: relative"&gt; &lt;div style="width: 100%;height: 200px;background: blue;position: absolute"&gt;被压缩在父级元素中显示&lt;/div&gt;&lt;/div&gt;&lt;div style="width: 100px;height: 100px;overflow: hidden;background: red;transform: scale(1)"&gt; &lt;div style="width: 100%;height: 200px;background: blue;position: absolute"&gt;被压缩在父级元素中显示&lt;/div&gt;&lt;/div&gt; float 浮动浮动出现的意义其实只是用来让文字环绕图片而已，仅此而已。 用浮动实现页面布局本不是浮动该干的事情。 浮动的本质定义为“包裹与破坏”。 CSS float浮动 一 CSS float浮动 二 包裹性浮动就是个带有方位的 display: inline-block 属性。 破坏性浮动破坏了正常的 line box 模型，就没有了 inline box 该有的高度，实际占据的高度为 0。 清除浮动造成的影响所谓清除浮动，其实应该是 float: none。 而我们关注的其实是清除浮动造成的影响。 父级 div 设置 zoom 值，并定义伪元素 ::after 父级 div 定义 height，并定义 overflow: hidden/auto 父级 div 定义 height，并也设置浮动 最后一个浮动元素结尾处加 或 ，设置 clear: both 1234567891011.clear-float &#123; zoom: 1;&#125;.clear-float::after &#123; display: block; height: 0; clear: both; content: ''; visibility: hidden;&#125; 但自从用了 display: flex，再也没写过 float 页面导入样式的几种方式行内样式 内嵌样式 p{} 导入样式 @import ‘style.css’; 链接样式 iframe iframe 会阻塞主页面的 onload 事件 iframe 和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载 iframe 页面样式调试麻烦，出现多个滚动条 搜索引擎的检索程序无法解读 iframe，不利于 SEO 动态创建和动态销毁 iframe例如在处理 App 或微信的 webview 单页面应用时，页面 title 不刷新的问题 iframe 与父页面的(跨域)通信parent.html 1234&lt;body&gt; &lt;div&gt;parent&lt;/div&gt; &lt;iframe id="child" name="child" src="child.html"&gt;&lt;/iframe&gt;&lt;/body&gt; child.html 123&lt;body&gt; &lt;div&gt;child&lt;/div&gt;&lt;/body&gt; 父页面访问子页面123456789var child = document.querySelector('#child') // child.htmlvar childWindow = child.contentWindow // child.html 的 window 对象var childDocument = child.contentDocument // child.html 的 document 对象var child2 = window.frames['child'] // child.htmlchild === child2 // true 子页面访问父页面123window.parent // 获取上一级容器的 window 对象window.top // 获取最顶级容器的 window 对象，即是你打开页面的文档window.self // 返回自身 window 的引用。可以理解 window === window.self (脑残) 判断当前页面是否为子页面12345if (window.parent === window) &#123; console.log('当前页面不是子页面')&#125; else &#123; console.log('当前页面是子页面')&#125; postMessage(message, targetOrigin) 方法与 监听 message 事件子页面： 123456789101112131415161718192021// 监听 message 事件window.addEventListener('message', (event) =&gt; &#123; console.log(event) if (event.type === 'message') &#123; // &amp;&amp; event.origin === '指定源' const json = JSON.parse(event.data) if (+json.code === 1001) &#123; console.log(json.data.word) window.parent.postMessage(JSON.stringify(&#123; code: 1001, data: &#123; word: '我是你儿子' &#125;, message: '成功' &#125;), '*') &#125; &#125;&#125;, false) 父页面： 12345678910111213141516171819202122// 监听 message 事件window.addEventListener('message', (event) =&gt; &#123; console.log(event) if (event.type === 'message') &#123; // &amp;&amp; event.origin === '指定源' const json = JSON.parse(event.data) if (+json.code === 1001) &#123; console.log(json.data.word) &#125; &#125;&#125;, false)// 给子页面发送消息document.querySelector('#child').contentWindow.postMessage(JSON.stringify(&#123; code: 1001, data: &#123; word: '我是你爸爸' &#125;, message: '成功'&#125;), '*') 伪类与伪元素伪类状态伪类 :active :focus :hover :link :visited :disabled :checked 其他… 结构性伪类 :lang :first-child :last-child :nth-child(n) :only-child :empty :not(selector) 其他… 伪元素伪元素的由两个冒号::开头，然后是伪元素的名称 使用两个冒号::是为了区别伪类和伪元素(CSS2 中并没有区别)。当然，考虑到兼容性，CSS2中已存的伪元素仍然可以使用一个冒号:的语法，但是 CSS3 中新增的伪元素必须使用两个冒号:: 一个选择器只能使用一个伪元素，并且伪元素必须处于选择器语句的最后 伪元素的本质是在不增加dom结构的基础上添加的一个元素，在用法上跟真正的dom无本质区别。普通元素能实现的效果，伪元素都可以。有些用伪元素效果更好，代码更精简 ::first-letter // 向文本的第一个字母添加特殊样式 ::first-line // 向文本的首行添加特殊样式 ::before // 在元素之前添加内容 ::after // 在元素之后添加内容 12345678910111213141516/* 可以设置 p 中文本的第一字母的样式 */p::first-letter &#123; color: blue;&#125;/* 可以设置 p 中文本的第一行的样式 */p::first-line &#123; color: red;&#125;/* 可以在 p 之前添加内容 */p::before &#123; content: 'before';&#125;/* 可以在 p 之后添加内容 */p::after &#123; content: 'after';&#125; css 权重从 0 开始，一个行内样式 +1000，一个 id +100，一个属性选择器/class 或者伪类 +10，一个元素名或者标签名或者伪元素 +1，* 是 0 important &gt; 内嵌样式 &gt; ID &gt; 类 &gt; 标签 | 伪类 | 属性选择 &gt; 伪对象 &gt; 继承 &gt; 通配符 important的权重为 1,0,0,0 ID的权重为 0,1,0,0 类的权重为 0,0,1,0 标签的权重为 0,0,0,1 伪类的权重为 0,0,1,0 属性的权重为 0,0,1,0 伪对象的权重为 0,0,0,1 通配符的权重为0,0,0,0 css 优先级!important &gt; id &gt; 属性选择器/class/伪类 &gt; tag/伪元素 &gt; * 出现重复样式，后面写的样式大于前面写的样式 以权重决定样式规则： 相同的权重：以后面出现的选择器为最后规则 不同的权重，权重值高则生效 display: none 和 visibility: hidden 的区别display: none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。 visibility: hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。 &lt;!DOCTYPE&gt; 告知浏览器的解析器用什么文档标准解析这个文档。&lt;!DOCTYPE&gt; 不存在或格式不正确会导致文档以兼容模式呈现。 在标准模式中，页面的排版和 JS 运作模式都是以该浏览器支持的最高标准运行。 在兼容模式中，页面以宽松的向后兼容的方式显示，模拟老式浏览器的行为以防止站点无法工作。 HTML5 为什么只需要写 HTML5 不基于 SGML，因此不需要对 DTD (Document Type Definition) 进行引用，但是需要 DOCTYPE 来规范浏览器的行为(让浏览器按照它们应该的方式来运行)。 换言之，HTML4.01 及以下是基于 SGML，所以需要对 DTD 进行引用，这样才能告知浏览器文档所使用的文档类型。 SGML 是 Standard Generalized Markup language 标准通用标记语言。一种很强大但很复杂的标记语言，HTML、XML 就是从中衍生出来的。 DTD 是 Document Type Definition 文档类型定义，是一套为了进行程序间的数据交换而建立的关于标记符的语法规则。 有哪些惊奇的 HTML5 特性async 属性 语义化，比如 article、footer、header、nav、section 表单控件，比如 calendar、date、time、email、url、search video/audio 更加友好 drag/drop 拖放 拖放(drag 和 drop)设置可拖 draggable=”true” 属性 监听拖事件 ondragstart=”drag” 1&lt;img id="img" draggable="true" ondragstart="drag"&gt; 1234drag (e) &#123; const data = e.target.id // 设置需要拖的数据 e.dataTransfer.setData('Text', data) // 将数据设置到拖对象中，指定数据类型&#125; 设置可放 allowDrop=”allowDrop” 属性 监听放事件 ondrop=”drop” 1&lt;div ondragover="allowDrop" ondrop="drop"&gt;&lt;/div&gt; 123456789allowDrop (e) &#123; e.preventDefault() // 阻止浏览器对数据的默认处理(drop 事件的默认行为是以链接形式打开)&#125;drop (e) &#123; e.preventDefault() // 阻止浏览器对数据的默认处理(drop 事件的默认行为是以链接形式打开) const data = e.dataTransfer.getData('Text') // 获取放过来的值 e.target.appendChild(document.getElementById(data)) // 处理&#125; canvas1&lt;canvas width="200" height="100"&gt;&lt;/canvas&gt; canvas 元素本身是没有绘图能力的。所有的绘制工作必须在 JavaScript 内部完成 1234567const canvas = document.querySelect('canvas')const cxt = canvas.getContext('2d')cxt.fillStyle = '#f00'cxt.fillRect(0, 0, 150, 75)const img = new Image()img.src = 'https://cmspic-10004025.image.myqcloud.com/4273a6c5-7b92-40e2-a0d0-841741f87b6e'cxt.drawImage(img, 0, 0) svg地理定位 Geolocation依赖浏览器的定位。如果是谷歌浏览器，是依赖 googleapis。目前需要 VPN 代理。 123456789101112131415if ('geolocation' in navigator) &#123; // 地理位置服务可用 navigator.geolocation.getCurrentPosition(res =&gt; &#123; console.log(res, 'success') &#125;, error =&gt; &#123; console.log(error, 'error') &#125;, &#123; enableHighAccuracy: true, // 是否使用其最高精度 timeout: 10000, // 超时 maximumAge: 0, // 缓存时间 &#125;)&#125; else &#123; // 地理位置服务不可用 console.log('地理位置服务不可用')&#125; 如果项目中需要定位，可以引入高德地图、腾讯地图、百度地图等。 Web 存储HTML5 提供了两种在客户端存储数据的新方法 localStorage - 没有时间限制的数据存储。本地离线存储，可长期存储数据，浏览器关闭后数据不丢失 sessionStorage - 针对一个 session 的数据存储，在浏览器关闭后自动删除 之前，这些都是由 cookie 完成的。但是 cookie 不适合大量数据的存储，因为它们由每个对服务器的请求来传递，这使得 cookie 速度很慢而且效率也不高。 在 HTML5 中，数据不是由每个服务器请求传递的，而是只有在请求时使用数据。它使在不影响网站性能的情况下存储大量数据成为可能。 对于不同的网站，数据存储于不同的区域，并且一个网站只能访问其自身的数据。 localStorage 和 sessionStorage 虽然也有存储大小的限制，但比 cookie 大得多，可以达到5M或更大。 cookie 数据大小不能超过4k。设置的 cookie 过期时间之前一直有效，即使窗口或浏览器关闭。 1234567891011121314151617181920console.log(localStorage) // 是一个类对象for (let key in localStorage) &#123; console.log(key, localStorage[key])&#125;// 这样重新赋值是无效的localStorage = &#123; ...localStorage, x: 1, y: 2,&#125;// localStorage 只允许添加某属性，而且值会被转成字符串形式，localStorage['x'] = 1localStorage.y = 2localStorage.setItem('z', 3)localStorage.setItem('garbage', true) 用处： 利用 localStorage 来记录当前页面浏览位置。 利用 localStorage 来记录音视控件播放的方式：单曲循环/列表循环/顺序播放/随机播放 Application Cache应用程序缓存 离线浏览 - 用户可在应用离线时使用它们 速度 - 已缓存资源加载得更快 减少服务器负载 - 浏览器将只从服务器下载更新过或更改过的资源 Web Workers当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行 worker.js 1234let i = 0setTimeout(() =&gt; &#123; postMessage(++i)&#125;, 1000) 123456if (typeof(Worker) === 'function') &#123; const w = new Worker('worker.js') w.onmessage = (e) =&gt; &#123; console.log(e.data) &#125;&#125; HTML 5 服务器发送事件postMessage onopen onmessage onerror js 基本数据类型五种基本：Undefined、Null、Boolean、Number、StringNaN 是 Number 类型 一种特殊：ObjectObject 包含三大引用类型： Object: {} Array: [] Function: () =&gt; {} 其实还有数据封装类对象：Boolean、Number、String Math、Date、RegExp、Error 等 类数组：NodeList、Arguments null 与 undefined 与 NaN12345678910111213141516171819202122232425262728// nullnull === null // true!null // trueNumber(null) // 0typeof null // 'object'，作为对象原型链的终点// undefinedundefined === undefined // true!undefined // trueNumber(undefined) // NaNtypeof undefined // 'undefined'// NaNNaN == NaN // false!NaN // trueNumber(NaN) // NaNtypeof NaN // 'number'isNaN(NaN) // true this 关键词其实就是作用域问题 ES6 后很少就关心了 偶尔涉及的时候，使用 that 管理一下 1const that = this apply 与 call调用一个对象的一个方法，用另一个对象替换当前对象 将一个函数的对象上下文从初始的上下文改变为由 this 指定的新对象 apply只接受两个参数，新 this 对象和一个参数数组 argArray Function.apply(this, [1, 2, 3]) this 对象应用 Function 对象的方法 call接受多个参数，第一个参数与 apply 一样，都是新 this 对象，后面则是一串参数列表 Function.call(this, 1, 2, 3) Function 对象调用 this 对象的方法 基本使用1234567891011121314function add (a,b) &#123; return a + b&#125;function sub (a, b) &#123; return a - b&#125;var a1 = add.apply(sub, [4, 2]) // sub 应用 add 的方法var a2 = sub.call(add, 4, 2) // sub 应用 add 的方法console.log(a1); // 6console.log(a2); // 2 实现继承123456789101112131415161718192021function Animal (name) &#123; this.name = name this.showName = function () &#123; console.log(this.name) &#125;&#125;function Cat (name) &#123; Animal.apply(this, [name])&#125;function Dog (name) &#123; Animal.call(this, name)&#125;var cat = new Cat('喵喵') // cat 通过 apply 继承了 Animal 的 name 属性和 showName 方法cat.showName() // 喵喵var dog = new Dog('汪汪') // dog 通过 call 继承了 Animal 的 name 属性和 showName 方法dog.showName() // 汪汪 apply 和 call 的一些巧妙apply 可以将一些接受参数列表转化为接受参数数组的形式 1234567891011// Math.max(param1, param2...)var arr = [1, 2, 3, 6, 5, 4] // 比较大小Math.max(1, 2, 3, 6, 5, 4) // 6function max (argArray) &#123; return Math.max.apply(null, argArray)&#125;max(arr) // 6 123456789// push(param1, param2...)var arr = [1]arr1.push(2, 3)Array.prototype.push.apply(arr, [2, 3])console.log(arr) // [1, 2, 3] 123456789101112131415var arr = [1]arr.concat(2, 3) // [1, 2, 3]arr.concat([2, 3]) // [1, 2, 3]arr.concat([[2, 3]]) // [1, [2, 3]]Array.prototype.concat(arr, 2, 3) // [1, 2, 3]Array.prototype.concat(arr, [2, 3]) // [1, 2, 3]Array.prototype.concat(arr, [[2, 3]]) // [1, [2, 3]]Array.prototype.concat.apply(arr, [[2, 3]]) // [1, 2, 3]// 看最后一个，[1] 应用 Array.prototype.concat 方法，[[2, 3]] 是参数列表，所以等价于：Array.prototype.concat([1], [2, 3]) navigatornavigator.userAgent HTTP 状态码100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息200 OK 正常返回信息201 Created 请求成功并且服务器创建了新的资源202 Accepted 服务器已接受请求，但尚未处理301 Moved Permanently 请求的网页已永久移动到新位置。302 Found 临时性重定向。303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。304 Not Modified 自从上次请求后，请求的网页未修改过。400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。401 Unauthorized 请求未授权。403 Forbidden 禁止访问。404 Not Found 找不到如何与 URI 相匹配的资源。500 Internal Server Error 最常见的服务器端错误。503 Service Unavailable 服务器端暂时无法处理请求(可能是过载或维护)。 哪些性能优化的方法？减少http请求次数：CSS Sprites, htnl、JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能 当需要设置的样式很多时设置className而不是直接操作style 少用全局变量、缓存DOM节点查找的结果，减少IO读取操作 避免使用CSS Expression(css表达式)又称Dynamic properties(动态属性) 图片预加载 将样式表放在顶部，将脚本放在底部 内存泄漏内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0(没有其他对象引用过该对象)，或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。 闭包、控制台日志、循环(在两个对象彼此引用且彼此保留时，就会产生一个循环) 线程与进程一个程序至少有一个进程，一个进程至少有一个线程。 线程的划分尺度小于进程，使得多线程程序的并发性高。 进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。 每个独立的线程有一个程序运行的入口、顺序执行序列和程序的出口。但是线程不能够独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制。 从逻辑角度来看，多线程的意义在于一个应用程序中，有多个执行部分可以同时执行。但操作系统并没有将多个线程看做多个独立的应用，来实现进程的调度和管理以及资源分配。 数组去重对象的浅拷贝和深拷贝；浅复制和深复制js 操作获取和设置 cookieajax 有那些优缺点优点： 通过异步模式，提升了用户体验. 优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用. Ajax在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。 Ajax可以实现动态不刷新(局部刷新) 缺点： 安全问题 AJAX暴露了与服务器交互的细节。 对搜索引擎的支持比较弱。 不容易调试。 如何解决跨域问题？jsonp、iframe、window.name、window.postMessage、服务器上设置代理页面 JavaScript 原型，原型链原型也是普通的对象，是对象一个自带隐式的 proto 属性。 原型也有可能有自己的原型。如果一个原型的原型为非 null 的话，我们就称之为原型链。 原型链是由一些用来继承和共享属性的对象组成的(有限的)对象链。 Array Array.proto Array.proto.proto Array.proto.proto.proto —–&gt; null GET 和 POST 的区别GET：一般用于信息获取，使用 URL 传递参数，对所发送信息的数量也有限制，一般在2000个字符 POST：一般用于修改服务器上的资源，对所发送的信息没有限制。 GET 方式需要使用 Request.QueryString 来取得变量的值，而 POST 方式通过 Request.Form 来获取变量的值，也就是说 GET 是通过地址栏来传值，而 POST 是通过提交表单来传值。 然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件(更新服务器上的文件或数据库) 向服务器发送大量数据(POST 没有数据量限制) 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 同源策略协议，域名，端口相同，同源策略是一种安全协议。 闭包函数可以访问函数外的变量。 如何在函数外使用函数内的变量呢，闭包。 闭包，指的是词法表示包括不被计算的变量的函数，也就是说，函数可以使用函数之外定义的变量。 闭包是可访问上一层函数作用域里变量的函数，即便上一层函数已经关闭。 闭包是子函数可以使用父函数的局部变量和参数。 一个拥有许多变量和绑定了这些变量的环境的表达式(通常是一个函数)，因而这些变量也是该表达式的一部分。 闭包就是一个函数引用另一个函数的变量，因为变量被引用着所以不会被回收，因此可以用来封装一个私有变量。这是优点也是缺点，不必要的闭包只会增加内存消耗。 闭包的特点： 作为一个函数变量的一个引用，当函数返回时，其处于激活状态。 一个闭包就是当一个函数返回时，一个没有释放资源的栈区。 javascript 里面的继承怎么实现，如何避免原型链上面的对象共享用构造函数和原型链的混合模式去实现继承，避免对象共享可以参考经典的 extend() 函数，很多前端框架都有封装的，就是用一个空函数当做中间变量。 ajax 过程 创建 XHR - XMLHttpRequest 对象，也就是创建一个异步调用对象 创建一个新的 HTTP 请求，并指定该 HTTP 请求的方法、URL及验证信息 设置响应 HTTP 请求状态变化的函数 发送 HTTP 请求 获取异步调用返回的数据. 使用 JavaScript 和 DOM 实现局部刷新 游览器输入 URL 到页面加载显示完成，这个过程中都发生了什么？(1)查找浏览器缓存-是否有缓存(2)无缓存，做 DNS 解析、查找该域名对应的 IP 地址、重定向(301/302)、发出第二个 GET 请求(3)进行 HTTP 协议会话(4)客户端发送报头(请求报头)(5)服务器回馈报头(响应报头)(6)HTML 文档开始下载(7)文档树建立，根据标记请求所需指定 MIME 类型的文件(8)页面显示 URL 和 URI 有什么不同?ES6扩展运算符(spread)是三个点(…) 替代函数的 apply 方法 复制数组(浅拷贝) 合并数组(浅拷贝) 与解构赋值结合 将字符串转为真正的数组 任何 Iterator 接口的对象 (Set 和 Map) 和 类似数组的对象 (arrayLike，nodeList)，都可以用扩展运算符转为真正的数组 扩展运算符(…) 调用的是遍历器接口(Symbol.iterator)，如果一个对象没有部署这个接口，就无法转换。 123456789const arr1 = [ &#123; key: 'value' &#125;]const arr2 = [...a1] // arr2 对 arr1 的浅拷贝，克隆// 改变 arr1 中的值，会 Array.from()Array.from 方法用于将两类对象转为真正的数组：类似数组的对象(arrayLike，nodeList)和可遍历(iterable)的对象(包括 ES6 新增的数据结构 Set 和 Map)。 所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过 Array.from 方法转为数组，而此时扩展运算符 (…) 就无法转换。 12Array.from(&#123; length: 3 &#125;)// [ undefined, undefined, undefined ] fill()find() 和 findIndex()entries()，keys()和values()entries()，keys()和values()vuehttps://www.jianshu.com/p/b1dd80f4d542 计算属性 (computed) 与方法 (methods)计算属性是基于它们的依赖进行缓存的。计算属性只有在它的相关依赖发生改变时才会重新求值。这就意味着只要相关依赖没有发生改变，多次访问计算属性会立即返回之前的计算结果，而不必再次执行函数。 相比之下，每当触发重新渲染时，调用方法将总会再次执行函数。 计算属性 (computed) 与侦听属性 (watch)当需要在数据变化时执行异步或开销较大的操作时，侦听属性 (watch) 最有用。 使用 watch 选项允许我们执行异步操作 (访问一个 API)，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。 用 key 管理可复用的元素Vue 为你提供了一种方式来表达 “这两个元素是完全独立的，不要复用它们”。只需添加一个具有唯一值的 key 属性即可。 在使用 v-for 时，key 是必须的！ https://cn.vuejs.org/v2/guide/list.html#key v-for 的 in 和 of v-for=”todo in todos” v-for=”todo of todos” v-for=”n in 10” v-if 和 v-show 区别v-if 是“真正”的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。 v-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。 相比之下，v-show 就简单得多——不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 进行切换。 一般来说，v-if 有更高的切换开销，而 v-show 有更高的初始渲染开销。因此，如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，则使用 v-if 较好。 为什么避免 v-if 和 v-for 一起使用当 v-if 与 v-for 一起使用时，v-for 具有比 v-if 更高的优先级，这意味着 v-if 将分别重复运行于每个 v-for 循环中。[当你想为仅有的一些项渲染节点时，这种优先级的机制会十分有用] 组件通信 父组件与子组件传值 父组件通过标签上面定义属性传值 [v-on:property] 子组件通过 props 选项接受数据 子组件向父组件传递数据 父组件通过标签上面定义事件 [v-on:function] 子组件通过 $emit 触发事件，可以传递值 组件上使用 v-model 利用 vuex vue 如何实现按需加载异步组件 123&#123; component: async () =&gt; await import('./wxarticles/wxarticle/index.vue')&#125; 或者 webpack 的 require.ensure vue 的生命周期创建前/后，载入前/后，更新前/后，销毁前/销毁后 beforeCreate 在实例初始化之后，数据观测 (data observer) 和 event/watcher 事件配置之前被调用。 created 在实例创建完成后被立即调用。在这一步，实例已完成以下的配置：数据观测 (data observer)，属性和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el 属性目前不可见。 beforeMount 在挂载开始之前被调用：相关的 render 函数首次被调用。 该钩子在服务器端渲染期间不被调用。 mounted el 被新创建的 vm.$el 替换，并挂载到实例上去之后调用该钩子。如果 root 实例挂载了一个文档内元素，当 mounted 被调用时 vm.$el 也在文档内。 注意 mounted 不会承诺所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以用 vm.$nextTick 替换掉 mounted。 123456mounted: function () &#123; this.$nextTick(function () &#123; // Code that will run only after the // entire view has been rendered &#125;)&#125; 该钩子在服务器端渲染期间不被调用。 beforeUpdate 数据更新时调用，发生在虚拟 DOM 打补丁之前。这里适合在更新之前访问现有的 DOM，比如手动移除已添加的事件监听器。 该钩子在服务器端渲染期间不被调用，因为只有初次渲染会在服务端进行。 updated 由于数据更改导致的虚拟 DOM 重新渲染和打补丁，在这之后会调用该钩子。 当这个钩子被调用时，组件 DOM 已经更新，所以你现在可以执行依赖于 DOM 的操作。然而在大多数情况下，你应该避免在此期间更改状态。如果要相应状态改变，通常最好使用计算属性或 watcher 取而代之。 注意 updated 不会承诺所有的子组件也都一起被重绘。如果你希望等到整个视图都重绘完毕，可以用 vm.$nextTick 替换掉 updated 123456updated: function () &#123; this.$nextTick(function () &#123; // Code that will run only after the // entire view has been rendered &#125;)&#125; 该钩子在服务器端渲染期间不被调用。 beforeDestroy 实例销毁之前调用。在这一步，实例仍然完全可用。 该钩子在服务器端渲染期间不被调用。 destroyed Vue 实例销毁后调用。调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。 该钩子在服务器端渲染期间不被调用。 节点、树以及虚拟 DOMVNode，Virtual Node 虚拟节点 组件树中的所有 VNodes 必须是唯一的 Vue 通过建立一个虚拟 DOM 对真实 DOM 发生的变化保持追踪 什么是 MVVMModel-View-ViewModel，MVC 的改进版。 Model 层代表数据模型，在 Model 中定义数据修改和操作的业务逻辑。 View 代表 UI 组件，它负责将数据模型转化成 UI 展现出来。 ViewModel 是一个同步 View 和 Model 的对象。 Model 和 View 之间并没有直接的联系，而是通过 ViewModel 进行交互，Model 和 ViewModel 之间的交互是双向的，因此 View 数据的变化会同步到 Model 中，而 Model 数据的变化也会立即反应到 View 上。 ViewModel 通过双向数据绑定把 View 层和 Model 层连接了起来，而 View 和 Model 之间的同步工作完全是自动的，无需人为干涉，因此开发者只需关注业务逻辑，不需要手动操作 DOM，不需要关注数据状态的同步问题，复杂的数据状态维护完全由 MVVM 来统一管理。 低耦合。视图(View)可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的 View 上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。 可重用性。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 View 重用这段视图逻辑。 独立开发。开发人员可以专注于业务逻辑和数据的开发(ViewModel)，设计人员可以专注于页面设计 可测试。界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。 MVVM 和 MVC 区别Model View Controller Model(模型)表示应用程序核心(比如数据库记录列表)。View(视图)显示数据(数据库记录)。Controller(控制器)处理输入(写入数据库记录)。 区别并不大。主要就是 MVC 中 Controller 演变成 MMVVM 中的 ViewModel。 MVC 中改变 View 需要大量的 DOM 操作，这使页面渲染性能降低，加载速度变慢，影响用户体验。 MVVM 是数据驱动，通过数据来显示视图层而不是节点操作。数据操作比较多的场景，更加便捷。 vue 的优点 低耦合。视图(View)可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的 View 上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变。 可重用性。你可以把一些视图逻辑放在一个 ViewModel 里面，让很多 View 重用这段视图逻辑。 独立开发。开发人员可以专注于业务逻辑和数据的开发(ViewModel)，设计人员可以专注于页面设计 可测试。界面素来是比较难于测试的，而现在测试可以针对 ViewModel 来写。 vue-router路由之间跳转声明式(标签跳转) 编程式( js跳转) navigation-guards 导航守卫全局守卫、路由独享的守卫、组件内的守卫 vuex小程序wepy mpvue 请勿在 scroll-view 中使用 textarea、map、canvas、video 组件。在 中滚动时， 的 placeholder 和内容会固定不动，好像 fixed 了 wx.showShareMenu 与 wx.updateShareMenu 的区别 去除点击态效果 微信版本 6.3.30, focus 属性设置无效；placeholder 在聚焦时出现重影问题；字体是系统字体，所以无法设置 font-family；在 input 聚焦期间，避免使用 css 动画 hidden 属性的作用，其实是 *[hidden]{display:none}，存在被覆盖从而失效的可能 前端 wx.login 换取 code (后端通过 code 换取 session_key)，前端 shareTicket 解析 encryptedData、iv，后端拿 session_key、encryptedData、iv 解析群信息如 openGId 存在失败的可能。执行顺序很关键！得先解析 wx.login 换取 code，再用 shareTicket 解析 encryptedData、iv 开发版二维码可以在微信开发者工具中生成，可带参数；体验版二维码可以在微信公众平台中[开发管理-&gt;开发版本-&gt;修改页面路径带参数] 并发请求限制 1234567每次切换后，同时请求三条接口(并发)，会导致手机卡顿，所有改成请求一条接口后，再请求其他接口。当前tab下请求发出，打一个loading=true，只要当前tab下请求不结束，不再触发同一请求。tab有5个item。点击每个item，需要请求对应的数据。当用户点击第1个item，请求第1类数据时，因为接口异步，无法及时返回；而用户迅速点击第2个item，会去请求第2类数据；类似操作，用户在5个item之间来回切换，网速慢，会导致有很多接口在同时请求(请求发出但迟迟不返回视为请求中)，超出了小程序的限制，导致页面操作卡顿！所以需要对请求加以限制(节流)。当用户点击第1个item请求第1类接口，然后来回切换，切换回第1个item时，如果第1类接口不结束那就不应该再次发起。 123456789101112131415let apiLoading1 = falseconst requestApi1 = async () =&gt; &#123; if (apiLoading1) return apiLoading1 = true await request(api1) apiLoading1 = false&#125;clickItem1 () &#123; // 点击事件 requestApi()&#125; cover-view 覆盖在原生组件之上的文本视图，可覆盖的原生组件包括 map、video、canvas、camera、live-player、live-pusher cover-view 内只能嵌套 cover-view、cover-image、button。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>前端面试题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mac软件推荐]]></title>
    <url>%2Fzh%2F2018%2F08%2F08%2FMac%E8%BD%AF%E4%BB%B6%E6%8E%A8%E8%8D%90%2F</url>
    <content type="text"><![CDATA[推荐一些常用的 Mac 软件 破解版https://www.waitsun.com/?s={query} AlfredAxure百度网盘已存 CharlesDr.Cleaner手动清理打开 Finder 界面，”shift + command + G” /Library/Caches~/Library/Caches~/Library/Application Support/MobileSync/Backup/ OmniGraffle百度网盘已存 PDFExp百度网盘已存 Photoshop百度网盘已存 Sketch百度网盘已存]]></content>
      <categories>
        <category>mac</category>
      </categories>
      <tags>
        <tag>software</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用保险保障自己的一生？]]></title>
    <url>%2Fzh%2F2018%2F06%2F10%2F%E5%A6%82%E4%BD%95%E7%94%A8%E4%BF%9D%E9%99%A9%E4%BF%9D%E9%9A%9C%E8%87%AA%E5%B7%B1%E7%9A%84%E4%B8%80%E7%94%9F%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[如何用保险保障自己的一生？ 毕业后的这几年，保险这两个字逐渐进入我的视野。 保险，Insurance，本意是稳妥可靠保障；后延伸成一种保障机制，是用来规划人生财务的一种工具，是市场经济条件下风险管理的基本手段，是金融体系和社会保障体系的重要的支柱。 保险是一种保障机制，用来规避风险的。 保险种类社会保险和商业保险 社会保险是一种为丧失劳动能力、暂时失去劳动岗位或因健康原因造成损失的人口提供收入或补偿的一种社会和经济制度。 社会保险的主要项目包括养老保险、医疗保险、失业保险、工伤保险、生育保险，即所谓“五险一金”中的“五险”。 社会保险是一种缴费性的社会保障，资金主要是用人单位和劳动者本人共同缴纳，政府财政给予补贴并承担最终的责任。但是劳动者只有履行了法定的缴费义务，并在符合法定条件的情况下，才能享受相应的社会保险待遇。 社保是以城镇职工为保障对象的社会保险制度体系。 社会医疗保险包括城镇职工医疗保险，城镇居民医疗保险，新型农村合作医疗。 城乡居民基本医疗保险，是将城保和农保整合的新型保险制度，2016年提出，但目前还没有完全实现。 城镇职工基本医疗保险就是“五险”中的医疗保险。 参保人是城镇职工。 城镇居民基本医疗保险采取以政府为主导，以居民个人(家庭)缴费为主，政府适度补助为辅的筹资方式，按照缴费标准和待遇水平相一致的原则。 参保人是非从业的市民，具有城镇户口的人民。 新型农村合作医疗保险指由政府组织、引导、支持，农民自愿参加，个人、集体和政府多方筹资，以大病统筹为主的农民医疗互助共济制度。其采取个人缴费、集体扶持和政府资助的方式筹集资金。 参保人是农民，具有农村户口的人民。 商业保险是指通过订立保险合同运营，以营利为目的的保险形式，由专门的保险企业经营。商业保险关系是由当事人自愿缔结的合同关系，投保人根据合同约定，向保险公司支付保险费，保险公司根据合同约定的可能发生的事故因其发生所造成的财产损失承担赔偿保险金责任，或者当被保险人死亡、伤残、疾病或达到约定的年龄、期限时承担给付保险金责任。 商业保险公司提供。 强制保险机动车交通事故责任强制保险(交强险) 非强制保险 财产保险 家庭财产保险 房屋保险 人身保险 意外伤害保险 健康保险 医疗保险 普通医疗保险 门(急)诊医疗保险 住院医疗保险 手术医疗保险 综合医疗保险 疾病保险 单项疾病保险 重大疾病保险 人寿保险 定期人寿 终身人寿 生存保险 生死两全 养老保险 非强制但必备的商业保险房屋保险平安-家庭财产险 意外伤害保险孩子王-中国人寿-成人综合意外险 承保年龄18-50岁。保障期限1年。二级+公立医院。 意外身故伤残。意外医疗，门(急)诊、住院。 家庭成员人人必备！ 综合医疗保险孩子王-平安-e生保 平安-e生保 首投28天到60岁，续保可到99岁。保障期限1年。二级+公立医院。 不限社保目录，自费药/进口药全可报。 不限疾病种类，门(急)诊、住院、手术均覆盖。 一般医疗保险金 恶性肿瘤保险金 有条件的话，家庭成员人人必备！因为是每次只保一年，所以没有先后之后。 重大疾病保险开心保-百年康惠保重大疾病保险 28天到55岁。100种重疾，30种轻症(轻症比较贵，不需要买，尤其是买了综合医疗保险后)。 家庭主心骨必备！ 三高都是拒保的，所以早买早好，而且越早买保费越低。 其他支付宝花钱与收钱，都可以领取保障金。 免费医疗金、门诊报销金。 门诊报销金：门诊保障可累计1000元，每次可报200元。门诊保障累计至1000元后，可继续累计大病保障(25种重大疾病)。 京东金融签到送保障金]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>保险</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript字符编码]]></title>
    <url>%2Fzh%2F2018%2F05%2F04%2FJavaScript%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%2F</url>
    <content type="text"><![CDATA[最近在做 vue-music，接口返回的日韩文字是实体编号的形式，所以需要将其解析成可阅读的日韩文字。 字符编码字符编码(Character encoding)也称字集码，是把字符集中的字符编码为指定集合中某一对象(例如：比特模式、自然数序列、8位组或者电脉冲)，以便文本在计算机中存储和通过通信网络的传递。 因为计算机只能处理数字，所以如果要处理文本，就必须先把文本转换为数字。 最早的计算机在设计时采用 8 个比特(bit)作为一个字节(byte)。所以，一个字节能表示的最大的整数就是 255(二进制 11111111 = 十进制 255)，如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是 65535，4 个字节可以表示的最大整数是 4294967295。 比特比特(BIT，binary system)，计算机专业术语，是信息量单位。同时也是二进制数字中的位，信息量的度量单位，为信息量的最小单位。 8 bit (位) = 1 B (字节) 计算机中的 CPU 位数指的是 CPU 一次能处理的最大位数。例如 32 位计算机的 CPU 一次最多能处理 32 位数据。 二进制数系统中，每个 0 或 1 就是一个位(bit)。 二进制：00000000 (0) ~ 11111111 (255) parseInt(string, radix) 返回一个十进制的整数。string 指需被解析的字符串，其实字符串会先被转化为数字(Number(string))；radix 指需解析的数字的基数(进制)，值介于 2 ~ 36 之间，非必填。 如果 radix 不填，默认为十进制。 如果 radix 不填，但是 string 是以 ‘0’ 开头，则有可能是八进制有可能是十进制；string 是以 ‘0x’ 开头，则是十六进制。 123456789101112131415161718192021222324252627282930parseInt('00000000', 2) // -&gt; parseInt(0, 2)parseInt(0, 2) // 0parseInt('00000011', 2) // -&gt; parseInt(11, 2)parseInt(11, 2) // 3parseInt('11111111', 2) // -&gt; parseInt(11111111, 2)parseInt(11111111, 2) // 255parseInt('00000011', 8) // -&gt; parseInt(11, 8)parseInt(11, 8) // 9parseInt('00000011', 16) // -&gt; parseInt(11, 16)parseInt(11, 16) // 17// 十进制parseInt('00000011') // -&gt; parseInt(11)parseInt(11) // 11// 八进制parseInt(00000000) // 0parseInt(00000007) // 7parseInt(00000010) // 8parseInt(00000011) // 9parseInt(00000017) // 15parseInt(00000020) // 16// 十六进制parseInt('0x000011') // -&gt; parseInt(0x000011)parseInt(0x000011) // 17 字节字节(Byte)，指一小组相邻的二进制数码。 ASCII 码：一个英文字母(不分大小写)占一个字节的空间，一个中文占两个字节的空间。一个二进制数字序列，在计算机中作为一个数字单元，一般为 8 位二进制数，换算为十进制。最小值 0，最大值 255。如一个 ASCII 码就是一个字节。 utf-8：一个英文字符(含英文标点)等于一个字节，一个中文(含繁体和中文标点)等于三个字节。 Unicode：一个英文(含英文标点)等于两个字节，一个中文(含繁体和中文标点)等于两个字节。 字通常分为若干个字节，每个字所包含的位数称为字长。 字符集如需正确地显示 HTML 页面，浏览器必须知道使用何种字符集。 ASCII 码万维网早期使用的字符集是 ASCII 码。ASCII 码支持 0-9 的数字，大写和小写英文字母表，以及一些特殊字符。 HTML 和 XHTML 用标准的 7 比特 ASCII 码在网络上传输数据。 7 比特 ASCII 码可提供 128 个不同的字符值。&amp;#00; ~ &amp;#127; 通常会额外使用一个扩充的比特，以便于以 1 个字节的方式存储，1 个字节等于 8 比特。 &amp;#32; ~ &amp;#126; 是可显示的 ASCII 码。 &amp;#00; ~ &amp;#31; 和 &amp;#127; 是设备控制 ASCII 码，不可在 HTML 文档中显示。 ISO 字符集ISO 字符集是国际标准组织 (ISO) 针对不同的字母表 / 语言定义的标准字符集。 ISO 字符集 描述 使用范围 ISO-8859-1 Latin alphabet part 1 北美、西欧、拉丁美洲、加勒比海、加拿大、非洲 ISO-8859-2 Latin alphabet part 2 东欧 … … … ISO-2022-JP Latin/Japanese part 1 日本语 ISO-2022-KR Latin/Korean part 1 韩语 ISO 8859-1HTML 4.01 支持 ISO 8859-1 字符集。 ISO-8859-1 的较低部分(从 1 到 127 之间的代码)是最初的 7 比特 ASCII 码。 ISO-8859-1 的较高部分(从 160 到 255 之间的代码)全都有实体名称。 这些符号中的大多数都可以在不进行实体引用的情况下使用，但是实体名称或实体编号为那些不容易通过键盘键入的符号提供了表达的方法。 注释：实体名称对大小写敏感。 Unicode 标准由于上面列出的字符集都有容量限制，而且不兼容多语言环境，Unicode 联盟开发了 Unicode 标准。 Unicode 标准涵盖了世界上的所有字符、标点和符号。 不论是何种平台、程序或语言，Unicode 都能够进行文本数据的处理、存储和交换。 Unicode 可以被不同的字符集兼容。最常用的编码方式是 utf-8 和 utf-16。 utf-8： utf-8 中的字符可以是 1-4 个字节长。utf-8 可以表示 Unicode 标准中的任意字符。utf-8 向后兼容 ASCII 码。utf-8 是网页和电子邮件的首选编码。 1&lt;meta charset="utf-8"&gt; utf-16： 16 比特的 Unicode 转换格式是一种 Unicode 可变字符编码，能够对全部 Unicode 指令表进行编码。utf-16 主要被用于操作系统和环境中，比如微软的 Windows 2000/XP/2003/Vista/CE 以及 Java 和 .NET 字节代码环境。 提示：最前面的 256 个 Unicode 字符集字符对应于 256 个 ISO-8859-1 字符。 提示：所有 HTML 4 处理器均已支持 utf-8，而所有 XHTML 和 XML 处理器支持 utf-8 和 utf-16。 HTML 4.01 符号实体本字符实体参考手册包括了数学符号、希腊字符、各种箭头记号、科技符号以及形状。 注释：实体名称对大小写敏感。 实体名称与实体编号实体名称不一定有，但实体编码一定有! 结果 实体名称 实体编号 &amp; &amp;amp; &amp;#38; ♥ &amp;hearts; &amp;#9829; 지 - &amp;#51648; 𠮷 - &amp;#134071; 123456789101112131415161718192021&lt;!DOCTYPE HTML&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt; &lt;i&gt;♥&lt;/i&gt; &lt;i&gt;&amp;hearts;&lt;/i&gt; &lt;i&gt;&amp;#9829;&lt;/i&gt; &lt;/p&gt; &lt;p&gt; &lt;i&gt;지&lt;/i&gt; &lt;i&gt;&amp;#51648;&lt;/i&gt; &lt;/p&gt; &lt;p&gt; &lt;i&gt;𠮷&lt;/i&gt; &lt;i&gt;&amp;#134071;&lt;/i&gt; &lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 显示结果 实体编码的显示一般在 HTML 代码里写实体编码，会被直接识别成结果显示在网页上。 如果需要在网页上显示出实体编码，只需要将 &amp; 写成 &amp;#38;。例如想显示 &amp;#134071; 即写成 &amp;#38;#134071;。另外还有一种形式，利用伪元素 :before 或 :after 的 css content 属性。 12&lt;i&gt;&amp;#38;#134071;&lt;/i&gt;&lt;i class="showCode"&gt;&lt;/i&gt; 123.showCode:before &#123; content: '&amp;#134071;';&#125; 显示结果与实体编码的互相转化&amp;#00; ~ &amp;#31; 和 &amp;#127; 无效，因为它们不会在 HTML 文档中显示。 显示结果转实体编码12345678910111213function encodeChar (input) &#123; const div = document.createElement('div') div.innerText = input const output = div.innerHTML return output&#125;encodeChar('&amp;') // '&amp;amp;'encodeChar('♥') // '♥'，失效encodeChar('지') // '지'，失效encodeChar('𠮷') // '𠮷'，失效encodeChar('&amp;♥지𠮷') // '&amp;amp;♥지𠮷'，失效encodeChar('지나;정일훈') // '지나;정일훈'，失效 我们发现，这种只对 ASCII 码有效(&amp;#32; ~ &amp;#126;)，但返回的是 ASCII 码的实体名称形式，而且只能在客户端使用(依赖 window.document)。 推荐采取下面方式，借助 for...of 和 codePointAt。 1234567891011121314function encodeChar (input) &#123; let output = '' for (let key of input) &#123; output += `&amp;#$&#123;key.codePointAt(0)&#125;;` &#125; return output&#125;encodeChar('&amp;') // '&amp;#38;'encodeChar('♥') // '&amp;#9829;'encodeChar('지') // '&amp;#51648;'encodeChar('𠮷') // '&amp;#134071;'encodeChar('&amp;♥지𠮷') // '&amp;#38;&amp;#9829;&amp;#51648;&amp;#134071;'encodeChar('지나;정일훈') // '&amp;#51648;&amp;#45208;&amp;#59;&amp;#51221;&amp;#51068;&amp;#54984;' 实体编码转显示结果遇到特殊字符如日韩文字的时候，后端返回给前端的数据通常会是实体编码的形式，因为是异步获取并非是直接写在 HTML 代码中，所以无法被浏览器解析，从而需要前端进行转义。 1234567891011121314function decodeChar (input) &#123; const div = document.createElement('div') div.innerHTML = input const output = div.innerText return output&#125;decodeChar('&amp;#38;') // '&amp;'decodeChar('&amp;#9829;') // '♥'decodeChar('&amp;#51648;') // '지'decodeChar('&amp;#134071;') // '𠮷'decodeChar('&amp;#38;&amp;#9829;&amp;#51648;&amp;#134071;') // '&amp;♥지𠮷'decodeChar('&amp;#51648;&amp;#45208;&amp;#59;&amp;#51221;&amp;#51068;&amp;#54984;') // '지나;정일훈'decodeChar('&amp;#51648;&amp;#45208;;&amp;#51221;&amp;#51068;&amp;#54984;') // '지나;정일훈' 这种方式只能在客户端使用(依赖 window.document)。 推荐采取下面方式，借助 正则表达式 和 String.fromCodePoint。 123456789101112131415function decodeChar (input) &#123; const output = input.replace(/&amp;#&#123;1&#125;[0-9]&#123;1,&#125;;&#123;1&#125;/ig, (v) =&gt; &#123; const code = v.replace(/&amp;#(.*);/, '$1') return String.fromCodePoint(code) &#125;) return output&#125;decodeChar('&amp;#38;') // '&amp;'decodeChar('&amp;#9829;') // '♥'decodeChar('&amp;#51648;') // '지'decodeChar('&amp;#134071;') // '𠮷'decodeChar('&amp;#38;&amp;#9829;&amp;#51648;&amp;#134071;') // '&amp;♥지𠮷'decodeChar('&amp;#51648;&amp;#45208;&amp;#59;&amp;#51221;&amp;#51068;&amp;#54984;') // '지나;정일훈'decodeChar('&amp;#51648;&amp;#45208;;&amp;#51221;&amp;#51068;&amp;#54984;') // '지나;정일훈' ES6+ 中字符串的扩展JavaScript 内部，字符以 utf-16 的格式储存，每个字符固定为 2 个字节。对于那些需要 4 个字节储存的字符(Unicode 码点大于 0xffff，即 65535 的字符)，JavaScript 不能正确处理，JavaScript 会认为它们是两个字符，字符串长度会误判为 2，charCodeAt 方法只能分别返回前两个字节和后两个字节的值。 지 这个字的码点是 51648(十进制)，ES6 之前的字符串方法处理是没有问题。 𠮷 这个字的码点是 134071(十进制)，ES6 之前的字符串方法处理就会有问题。 123456789101112131415161718192021222324252627'지'.length // 1'지'.charAt(0) // '지''지'.charCodeAt(0) // 51648，码点，十进制'지'.charCodeAt(0).toString(16) // 'c9c0'+('0x' + '지'.charCodeAt(0).toString(16)) // '0xc9c0' -&gt; 0xc9c0 码点，十六进制 -&gt; 51648// ES 6'지'.codePointAt(0) // 51648，码点，十进制'지'.codePointAt(0).toString(16) // 'c9c0'+('0x' + '지'.codePointAt(0).toString(16)) // '0xc9c0' -&gt; 0xc9c0 码点，十六进制 -&gt; 5164851648 === 0xc9c0 // trueparseInt(0xc9c0) // 51648'지' === '\uc9c0' // true// ES 6'지' === '\u&#123;c9c0&#125;' // trueString.fromCharCode(51648) // '지'String.fromCharCode(0xc9c0) // '지'// ES 6String.fromCodePoint(51648) // '지'String.fromCodePoint(0xc9c0) // '지' 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647'𠮷'.length // 2。字符串长度误被判为 2'𠮷'.charAt(0) // '�'，失效'𠮷'.charAt(1) // '�'，失效'𠮷'.charCodeAt(0) // 55362，码点，十进制，失效'𠮷'.charCodeAt(0).toString(16) // 'd842'，失效+('0x' + '𠮷'.charCodeAt(0).toString(16)) // '0xd842' -&gt; 0xd842 码点，十六进制 -&gt; 55362，失效'𠮷'.charCodeAt(1) // 57271，码点，十进制，失效'𠮷'.charCodeAt(1).toString(16) // 'dfb7'，失效+('0x' + '𠮷'.charCodeAt(1).toString(16)) // '0xdfb7' -&gt; 0xdfb7 码点，十六进制 -&gt; 57271，失效// ES 6'𠮷'.codePointAt(0) // 134071，码点，十进制'𠮷'.codePointAt(0).toString(16) // '20bb7'+('0x' + '𠮷'.codePointAt(0).toString(16)) // '0x20bb7' -&gt; 0x20bb7 码点，十六进制 -&gt; 134071'𠮷'.codePointAt(1) // 57271，码点，十进制'𠮷'.codePointAt(1).toString(16) // 'dfb7'+('0x' + '𠮷'.codePointAt(1).toString(16)) // '0xdfb7' -&gt; 0xdfb7 码点，十六进制 -&gt;57271// codePointAt 方法在第一个字符(即 “𠮷” 的前两个字节)上，正确地识别了 “𠮷”，返回了它的十进制码点 134071(即十六进制的 0x20bb7)。在第二个字符(即 “𠮷” 的后两个字节)上，codePointAt 方法的结果与 charCodeAt 方法相同。// 对于类似字符串 '𠮷a'，字符 'a' 在字符串 '𠮷a' 的正确位置序号应该是 1，但是必须向 codePointAt 方法传入 2。解决这个问题的一个办法是使用 `for...of` 循环，因为它会正确识别 32 位的 utf-16 字符。let i = 0for (let key of '𠮷a') &#123; i ++ console.log(key, i)&#125;// '𠮷', 0// 'a', 1134071 === 0x20bb7 // trueparseInt(0x20bb7) // 134071'𠮷' === '\u20bb7' // false，失效// ES 6'𠮷' === '\u&#123;20bb7&#125;' // trueString.fromCharCode(134071) // 'ஷ'，失效String.fromCharCode(0x20bb7) // 'ஷ'，失效// ES 6String.fromCodePoint(134071) // '𠮷'String.fromCodePoint(0x20bb7) // '𠮷' 字体图标的使用iconfont IE9+，Chrome，Safari，Firefox 和 Opera 12345678910111213141516171819@font-face &#123; font-family: 'iconfont'; src: url('../font/iconfont.eot'); // IE9+ src: url('../font/iconfont.eot?t=1491903330819#iefix') format('embedded-opentype'), // IE6 - IE8 url('../font/iconfont.woff?t=1491903330819') format('woff'), // Modern Browsers url('../font/iconfont.ttf?t=1491903330819') format('truetype'), // Safari, IOS, Android url('../font/iconfont.svg?t=1491903330819#iconfont') format('svg'); // IOS font-stretch: normal; font-style: normal; font-weight: normal;&#125;.iconfont &#123; font-family: 'iconfont';&#125;.icon-pause:before &#123; content: '\e66a';&#125; unicode-range 定义字体支持的 unicode 字符范围。默认是 “U+0-10FFFF”。 Emoji 表情符号的使用Emoji 简介 2010年，Unicode 开始为 Emoji 分配码点。也就是说，现在的 Emoji 符号就是一个文字，它会被渲染为图形。 Full Emoji List node-emoji 12345678910111213141516// 码点 U+1F600 (十六进制)// 对应 0x1F600String.fromCodePoint(0x1F600) // 😀parseInt(0x1F600) // 码点 128512 (十进制)// HTML 实体编码 &amp;#128512;function decodeChar (input) &#123; const output = input.replace(/&amp;#&#123;1&#125;[0-9]&#123;1,&#125;;&#123;1&#125;/ig, (v) =&gt; &#123; const code = v.replace(/&amp;#(.*);/, '$1') return String.fromCodePoint(code) &#125;) return output&#125;decodeChar('&amp;#128512;') // 😀]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[音乐搜索(基于vue)]]></title>
    <url>%2Fzh%2F2018%2F05%2F02%2F%E9%9F%B3%E4%B9%90%E6%90%9C%E7%B4%A2(%E5%9F%BA%E4%BA%8Evue)%2F</url>
    <content type="text"><![CDATA[一个基于 vue 的音乐搜索网页。预览vue-music。 风格复制qq-music。 代码参考sioxas-music。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[机场初体验]]></title>
    <url>%2Fzh%2F2018%2F04%2F30%2F%E6%9C%BA%E5%9C%BA%E5%88%9D%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[周六去了南京禄口机场。浪？不存在的。 长这么大，我没怎么出过江苏省。过年回老家会途径安徽，然后就是之前去浙江旅游过几次。省内其他城市也去的很少，无非镇江、无锡、常州等。 高铁都很少坐的我，飞机更是没当面见过。偶尔听到空中轰鸣，旁边哥们指着天空，大喊一句，“看，飞机！”此处@大学室友觊凯，我们会好奇地抬头仰望。 外公他今年79岁了，去年来南京的时候，我带着玩了两天，他去哪儿都免费，倒是我，陪着玩却花了不少门票钱。 他很早就想去新疆玩。并不是像很多西行青年一样，所谓的穷游体会人生，他去的主要原因还是那里有亲戚。 五一劳动节终于下定决心去。提前一个星期打电话给我，让我在网上订票。 第一次订飞机票，最简单方式，打开【支付宝】APP。这跟广告无关。推荐大家使用【孩子王】APP。嗯，这是条硬广。 点击首页快捷入口【更多】，找到【第三方服务】中的【火车票机票】。选择出发点与目的地，选择出发日期。由于家境一般，我只会选择筛选【经济舱】，这里不想解释。。。然后就是看起飞时间与价格。然后看航班类型。 关于航班类型，这里多说几句。分【直达】【经停】【中转】。直达意思很简单，从出发地直接飞到目的地，一般路程短时间少。经停是，经过某个地方停下来，然后再飞到目的地，一般是路程较远，而且出发地客源较少，飞机从出发地带第一批人，然后飞到经停地，再带第二批人，通常会让第一批人下飞机休息一会儿，并打扫飞机上卫生，当然如果遇到晚点，会让第一批人留在飞机上，并让第二批人迅速上飞机。而中转的意思是，从出发地坐第一架飞机坐到中转地，然后所有人都下飞机，到中转地的人直接走了，到目的地的人在中转地机场等第二架飞机飞到目的地。【经停】和【中转】的区别就是前者一架飞机，后者多架飞机，显然后者时间长。如果你不赶时间，而且想在中转地玩一玩，中转是个好选择，机票便宜，而且能多去一个城市。 因为外公年纪大，而且对航线这些不太懂，怕他转机麻烦，我选了经停。一般航线都是固定的，例如我选的南京去克拉玛依的深航ZH9591，都是早上6点55分起飞。 机票总价一般包含机票钱、基建燃油钱和保险钱。前两个是必交，后一个是选交。关于保险，航空意外险还是很有必要的。关于延误险，个人觉得，如果不赶时间，没必要选。 由于是第一次去机场，很多东西不懂，加上行李很多，要办托运，另外住的地方离禄口机场比较远，虽然有地铁，但是最早也要6点，所以为了保险起见，决定提前两小时打车过去。为了避免半夜叫不到车的尴尬，虽然我跟爸妈说半夜叫车也容易，但是还是于前一天晚上预约了滴滴。 大约5点到达机场。快下车的时候，司机问我是 T1 还是 T2。当时就懵逼了，啥意思？也怪自己英语丢回了英国，不懂 T 是啥意思。 一般机场包含多个航站楼 Terminals 。南京禄口机场有两个航站楼，即所谓的 T1 和 T2。原 T1 是货运，但目前 T1 已经“暂停休整”，所以 T2 正负责国内、国际出发。据了解，以后 T1 航站楼将主要承担国内航班的到发，T2 航站楼将承担国际及部分国内航班的到发。 关于航班动态信息，可登录南京禄口国际机场查看，也可关注微信公众号【南京禄口国际机场】。比如我们输入【ZH9591】可查询，可以得知在 T2，也可以得知对应的值机柜台。 到达 T2 后，在门口航班信息公告屏上也可查询到对应航班所在的值机柜台。然后找寻值机柜台所在地，然后找一台可用的自动取票机，凭身份证或护照或网值电子二维码领取登机牌。关于护照，这里只允许中国，包含港澳台地区。外国人必须在人工值机柜台领取登机牌。关于电子二维码，需要关注微信公众号【南京禄口国际机场】，然后在微信值机功能中领取电子二维码，而且必须提前60分钟办理，一般适用于无托运行李的旅客。凭电子二维码可以直接在国内安检通道进行安检，当然国外的是不行的。 另外老人岁数比较大，自动取票机也是不支持的，必须走人工值机柜台，需要询问健康。我外公岁数大，所以就需要等工作人员上班。还要注意自己是什么舱，例如经济舱，就要在经济舱指定的值机柜台处理。 期间，有一家外国人，在我旁边试了半天的自动取票。看女人头戴纱巾，可能是印度等地。然后男人用英语指着自动取票机，问我怎么取票。我其实没听懂他说啥，但手势大致明白了。禄口机场有个不好的地方，自动取票机长得不一样，他面前这台机器我一下子没找到外国人用护照取票的地方。看屏幕提示半天，发现机器顶部有个长的横向卡槽，需要将护照的条形码在上面从左到右滑动。于是，讲了一句蹩脚的英语：“This! Here, slide it from left to right!”我指了指他的护照，然后指了那个横向卡槽，做了一个从左到右的动作。显然他看懂了我的动作，捣鼓了一句，然后尝试了起来。试了四五次，没成功，很尴尬，我也不知道怎么弄。然后他放弃了，指了指屏幕上的二维码，问我 “How to get it?”。我当时根本不知道这个二维码是啥。上面关于电子二维码的知识，是我事后诸葛亮上网查的。当时我只知道那东西叫 “qr code”。我很想来一句，“Can you speak Chinese?”。我还是决定灰溜溜地走开。后来我办理托运的时候，看到他们在值机班长那边办理。现在我懂了，外国人都只能在人工柜台那边办理。所以这些东西，是不是能更人性化一点，让国人以及外国人一下子就清楚咋回事？ 工作人员上班后，大概5点半，立马审核取票。然后办托运。关于行李，在家整理的时候，就要分两部分。随身携带的行李，一个五公斤以内的小包，一般是手提包或背包，放贵重物品如钱、手机、证件以及常用的物品如充电宝。托运行李，限重量不限数量，最多为40公斤。排队托运是个麻烦而且耗时的流程，所以如果有行李托运，一定要提前两小时左右去机场，而且去了立马排队。 托运办完后，就可以过安检了。一般是提前45分钟进行登机，所以安检尽量在45分钟前完成，除非有什么事情要处理。 走到对应安检区域，分国内和国外。安检过后，走到对应的登机口，等待安排登机。登机口可能随时发生变化，需要随时注意广播。 安检时，送行人员就不允许进入了。我给外公指清楚安检区域内大的指示牌提示的登机口，让他沿着那个方向走，找对应登机口，然后让他不懂的就问工作人员。 据外公说，到达登机口后，是安排小公交前往对应飞机的。 后面的事情我也不太清楚了，上诉有些是自己体验，有些是后来上网查询，总之也算对坐飞机的流程有了初步了解。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>趣事</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每一个人都有灵魂，每一段文字都有思想]]></title>
    <url>%2Fzh%2F2018%2F01%2F08%2F%E6%AF%8F%E4%B8%80%E4%B8%AA%E4%BA%BA%E9%83%BD%E6%9C%89%E7%81%B5%E9%AD%82%EF%BC%8C%E6%AF%8F%E4%B8%80%E6%AE%B5%E6%96%87%E5%AD%97%E9%83%BD%E6%9C%89%E6%80%9D%E6%83%B3%2F</url>
    <content type="text"><![CDATA[“几年前，她抛弃了我，嫁给了一个开帕萨特的土鳖，我暗暗下定决心，将来一定要把现在受到的屈辱还给她。几年后，当我开着奔驰出现在她面前的时候，她一脸的惊讶，还招呼我去她家坐坐。” 方炎笑着说道。 蒋钦的心神完全被方炎的故事吸引，大眼睛一眨不眨地看着他。 这是一个屌丝被女神抛弃，然后奋发图强终于成功的励志故事？ “现在后悔了吧？早干什么去了？当然，我也果断地拒绝了她，因为我还得去公司接我老板下班呢～”方炎接着讲道。 “啊哈哈哈……” 蒋钦大笑，软软的身体前仰后合。 “太好玩了。这个人怎么这么贱啊！” 方炎说道：“这个段子很好笑，对不对？但是，你有没有想过，只要在这个段子里面改动一个字，就是一个很温馨浪漫的爱情故事。” 蒋钦瞪大了眼睛，说道：“还可以这样？” “你改着试试。”方炎笑了起来。“看看能不能找到那个需要改动的字。” 蒋钦习惯性的把笔杆咬在嘴里，小脸认真的思索起来。 “改变一个字就成了温馨浪漫的爱情故事？”小丫头的嘴里念念有词。“要改动哪一个字呢？” 方炎笑呵呵地看着她，等待着她的答案。 蒋钦显然不是一个多么有耐心的人，三五分钟后就放弃了。 她把沾着口水的铅笔丢在桌子上，烦躁地说道：“烦死了烦死了，人家想不出来。要改哪个字？” 方炎笑呵呵地看着她，说道：“每一个人都有灵魂，每一段文字都有思想，这些字是活的，它们是一个整体，你要从这个整体上去寻找一颗痣。这颗痣很微小，但是也很显眼。如果你能够静下心来，就一定可以找到。” “我已经很静心了啊。”小丫头撒娇的说道。她赤裸的小脚从桌子底下去踢方炎的小腿，说道：“方老师，你快告诉我嘛。我真的很好奇。” “如果把‘老板’改成‘老婆’，只是换一个字，换一个身份，故事的意思是不是就全然不一样了？” “啊？”小丫头惊叫出声。她都没想过改动会如此的简单。 可是，改动之后，故事的灵魂立即就发生了颠覆性的变化。 “几年前，她抛弃了我，嫁给了一个开帕萨特的土鳖，我暗暗下定决心，将来一定要把现在受到的屈辱还给她。几年后，当我开着奔驰出现在她面前的时候，她一脸的惊讶，还招呼我去她家坐坐。现在后悔了吧？早干什么去了？当然，我也果断地拒绝了她，因为我还得去公司接我老婆下班呢～” 前面一个故事，男主角是屌丝，却仍然没有逆袭成功。而改动过一个字后，男主角不仅仅在社会上证明了自己的能力，还对自己的老婆忠贞不渝。那个“前女友”失去了一个对感情认真负责的潜力黑马。 “你认真的想一想。”方炎说道。 蒋钦点头答应，趴在桌子上沉默不语。 “每一段文字都有一个命门，如果你能够找到它的命门，就再也没有什么问题能够难倒你了。” “生活也是。”蒋钦咯咯地笑。 原文]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>人性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript模块的演变]]></title>
    <url>%2Fzh%2F2018%2F01%2F08%2FJavaScript%E6%A8%A1%E5%9D%97%E7%9A%84%E6%BC%94%E5%8F%98%2F</url>
    <content type="text"><![CDATA[ES6 带来的原生 JavaScript 模块体系，相信你已经用起来了，如果还没有，那你还有时间看文章？看什么看，你还不赶紧去用用。 转载：原生 JavaScript 模块的现在与未来 JavaScript 一开始并没有内建模块化支持，也几乎没有模块化这种概念。当时没那么大的需求，搞个模块化显得大材小用啊。随着互联网的发展，尤其是 2006 年 ajax 技术的出现和之后 Web 2.0 的兴起，越来越多的业务逻辑向前端转移，前端开发的复杂程度和代码量逐渐提升。这时，由于缺乏模块化概念，JavaScript 的一些问题便凸显出来：代码难以复用、容易出现全局变量污染和命名冲突、依赖管理难以维护等等。一开始，开发者们使用诸如暴露全局对象、自执行函数等方法来规避这些问题，但仍无法从根本上解决问题。 CommonJS2009 年，基于将 JavaScript 应用于服务端的尝试，ServerJS 诞生了。之后 ServerJS 更名为 CommonJS，并逐步发展为一个完整的模块规范。简称 CMD(Common Module Definition) CommonJS官网CommonJS阮一峰 CommonJS 为模块的使用定义了一套 API。比如，它定义了全局函数 require，通过传入模块标识来引入其他模块，如果被引入的模块又依赖了其他模块，那么会依次加载这些模块；通过 module.exports 向外部暴露 API，以便其他的模块引入。 由于 CommonJS 是使用同步方式加载模块的，即只有加载完成才能进行接下来的操作，因此当应用于浏览器端时会受到网速的限制。 123456789101112131415const $ = require('jquery')// 定义私有方法function log (...arg) &#123; console.log(...arg)&#125;// 定义公有方法function sayHello () &#123; const el = $('body') log('zhouyu, hello', el)&#125;// 暴露公有方法module.exports = &#123; sayHello&#125; AMD之后，在 CommonJS 组织的讨论中，AMD(Asynchronous Module Definition)应运而生。和 CommonJS 不同的是，它使用异步方式加载模块，因此更适合被浏览器端采用。AMD 用全局函数 define 来定义模块，它需要三个参数：模块名称、模块的依赖数组、所有依赖都可用之后执行的回调函数(该函数按照依赖声明的顺序，接收依赖作为参数)。 AMDAMD中文 12345678910111213define(['jquery'], function ($) &#123; // 定义私有方法 function log (...arg) &#123; console.log(...arg) &#125; // 定义公有方法 function sayHello () &#123; const el = $('body') log('zhouyu, hello', el) &#125; // 暴露公有方法 return sayHello&#125;) UMD如果需要同时支持 CommonJS 和 AMD 两种格式，那么可以使用 UMD(Universal Module Definition)。事实上，UMD 通过一系列 if/else 判断来确定当前环境支持的模块体系，因此多数情况下 UMD 格式的模块会占用更大的体积。 123456789101112131415161718192021222324(function (root, factory) &#123; if (typeof define === 'function' &amp;&amp; define.amd) &#123; // AMD define(['jquery'], factory) &#125; else if (typeof exports === 'object') &#123; // Nodejs 或 CommonJS module.exports = factory(require('jquery')) &#125; else &#123; // 浏览器全局变量(root 即 window) root.returnExports = factory(root.jQuery) &#125;&#125;(this, function ($) &#123; // 定义私有方法 function log (...arg) &#123; console.log(...arg) &#125; // 定义公有方法 function sayHello () &#123; const el = $('body') log('zhouyu, hello', el) &#125; // 暴露公有方法 return sayHello&#125;)); ES6 Modules无论是 CommonJS，AMD 还是 UMD，它们都不是标准的 JavaScript 模块解决方案。换句话说，它们都没有被写进 ECMA 的规范中。直到 2015 年 6 月，TC39 委员会终于将 Modules 写进 ECMAScript 2015 中，标志着原生模块新时代的到来。至此，JavaScript 文件有了两种形式：脚本(自 JavaScript 诞生起我们就在使用的)和模块(即 ECMAScript 2015 Modules)。下面就让我们来一起探索 ECMAScript 2015 Modules(以下简称 ES6 Modules) ES6 ModulesES6阮一峰 12345678910111213import $ from('jquery')// 定义私有方法function log (...arg) &#123; console.log(...arg)&#125;// 定义公有方法function sayHello () &#123; const el = $('body') log('zhouyu, hello', el)&#125;export default sayHello ES6 Modules 现状时至今日，几大主流浏览器都在积极推进支持原生 ES6 Modules 的工作，部分浏览器的技术预览版也已经初步完成了这一使命。可以通过 caniuse 查看目前浏览器的支持情况。 使用 Babel 和 webpack由于绝大多数浏览器都不支持 ES6 Modules，所以目前如果想使用它的语法，需要借助 Babel 和 webpack，即通过 Babel 将代码编译为 ES5 的语法，然后使用 webpack 打包成目标格式。 直接使用 ES6 Modules有些游览器已经支持 ES6 Modules，我们利用 &lt;script type=&quot;module&quot;&gt;(默认是 defer)来使用。 其他探索 动态加载方案 import() 1234const load = async (url) =&gt; &#123; const module = await import(url) console.log(module, window[tempGlobal])&#125; 12345678910111213141516171819202122function load (url) &#123; return new Promise((resolve, reject) =&gt; &#123; const script = document.createElement('script') const tempGlobal = '__tempModuleLoadingVariable' + Math.random().toString(32).substring(2) script.type = 'module' script.textContent = `import * as m from "$&#123;url&#125;"; window.$&#123;tempGlobal&#125; = m;` script.onload = () =&gt; &#123; resolve(window[tempGlobal]) delete window[tempGlobal] script.remove() &#125; script.onerror = () =&gt; &#123; reject(new Error('Failed to load module script with URL ' + url)) delete window[tempGlobal] script.remove() &#125; document.documentElement.appendChild(script) &#125;)&#125; 基于 ES6 Modules 的 module-pusher 尝试 查看原文]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[好人有好报？]]></title>
    <url>%2Fzh%2F2017%2F12%2F24%2F%E5%A5%BD%E4%BA%BA%E6%9C%89%E5%A5%BD%E6%8A%A5%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[好人有好报，这句话现在似乎变成了鸡汤。 今天是平安夜，本该是成双成对，你侬我侬着，显然我不是。 上午一踏进地铁站，听着地铁工作者特地点播的节日喜庆歌曲，心里却一直荡起，“lonely lonely christmas”，问我的心情，大概是哭笑不得。不过今天是出去旅游观光的，我得表现得 happy 点。 走马观花地看完大报应寺。 大报应寺，是继洛阳白马寺之后中国的第二座寺庙，也是中国南方建立的第一座佛寺。 大报恩寺内琉璃宝塔高达78.2米，通体用琉璃烧制，塔内外置长明灯一百四十六盏，自建成至衰毁一直是中国最高的建筑，也是世界建筑史上的奇迹，位列中世纪世界七大奇迹，被当时西方人视为代表中国的标志性建筑，有“中国之大古董，永乐之大窑器”之誉，被称为“天下第一塔”。 寺内阿育王塔中的佛顶骨舍利是世界现存唯一一枚佛祖(释迦摩尼)真身顶骨舍利，不过现在供奉于南京牛首山的佛顶宫中。 寺内三藏塔中供奉着玄奘法师(唐僧)的顶骨舍利。 南朝四百八十寺，多少楼台烟雨中。如今看风景，已全然没有少时那副怡然自得的欣赏，也不会看到一处就随口吟上一句相应的古诗。 大报应寺，报应报应，因果循环。 《吕祖说三世因果经》主要说的是：一是人的命是自己造就的；二是怎样为自己造一个好命；三是行善积德与行凶作恶干坏事的因果循环报应规律。因果报应指事物的起因和结果，种什么因，结什么果，宗教认为种什么因，结什么果报。 《涅槃经》讲：业有三报，一现报，现作善恶之报，现受苦乐之报；二生报，或前生作业今生报，或今生作业来生报；三速报，眼前作业，目下受报。 俗话说：善有善报，恶有恶报，不是不报，时候未到，时候一到，一切全报。 所以，常听周围说：好人有好报。 上面只是胡扯一通，瞎写一气，狗屁不是，不看也罢，看了无妨。 然而说说接下来的遭遇，报应真的一个接着一个，但我也没干什么坏事啊。 找了一家中华门城头下的羊肉馆，点一份羊杂汤，热乎吃完也罢。站着刚把钱付了，站我对面的是店家一老龄员工，手上端着估计有过百度的一大锅羊肉汤。大概是锅底被高温烫的脱掉了，哗啦啦，滚烫的羊肉汤顿时倾盆而下。恰巧泼到我脚下，我顿时炸毛，可由于这两年体态丰腴了些，敏捷性明显下降，还是慢了，左脚脚背被泼到了。顿时一股灼烧感从脚背传到头皮，疼得我牙痒痒。也不顾着形象了，当场脱了鞋袜。暗自感叹，还好鞋子好，防水，只是左脚一小片烫的发红。 事情发生到着，我先不往下说，各位先代入想想，假如是你遇到这种事情，你会怎么处理？ 去医院和赔钱呗。但我们往往看到是一方抵赖，一方讹钱。我这花钱吃饭，却无端遭了这罪，脚被烫着，凭什么？另外我的鞋子虽然不算贵，也才几百块，经此一泼，虽然发挥些艰苦奋斗的精神，刷一刷还是照穿无误，但凭什么？当然事实是，老板说带我去医院，我说不用了，我也没有提要钱，甚至我都没让老板把我的单免了。脚被烫了一下而已，鞋子脏了而已，能忍则忍了，乡下人老实，不觉得这是多大事。但另一方面，也许是内心软弱吧，也许要被人以鲁迅先生的话训斥为“哀其不幸，怒其不争”。我们经常看到类似新闻，例如有，某一女子(不是歧视女性)的名牌包包被弄脏要求巨额赔偿，甚至说被人厌烦的碰瓷。我这里并不是说，我们遇到这事情，我们不该要求赔偿，如果确实有损失，那么要求赔偿是必然的。甚至是一些严重的事情，第一反应是报警去医院。不要为了钱而要钱，不要越过做人的底线。假如对方不是故意的，你也能够接受，不妨退一步海阔天空，人家也不容易，一大锅汤损失不少钱，不至于捡起来重煮吧。。。 大概看到这里，你会说，好人有好报的。你是在积德行善，将来你会娶个好老婆。 你可知，这只是开始。 我坐在城墙下的路边休息，阳光刺眼，我就闭眼假寐，顺便缓缓脚上的疼痛。突然一堆水溅了过来，不过这次是冷水，泼了我一腿。大哥，冰火两重天不是这么玩的啊，你怎么知道我脚需要降温，但是你浇鞋子就行了，浇我一腿干嘛。我看着晒水车扬长而去，看着那一行“城市清洁”字苦笑，我大概是城市垃圾。 我是不敢坐着了，赶紧站起来，朝着阳光，抖抖自己的裤子，自然风干吧。没过几分钟，哗啦啦，屁股一激灵，低头一看，我呢子大衣上挂着一颗颗水珠，投影着我胖乎乎的脸，我看着他们，他们看着我，仿佛听见一句和声，“傻逼”。不打招呼就来一场雷阵雨，我不想看啊。洒水大哥，你也挺幸苦的啊，政府规定要洒两遍还是咋地，我就站这休息，我犯法了吗，你不能提醒我一下？我是来大报应了吗？ 不深入阐述了，也不说些什么升华的话语，鸡汤虽好喝，但是你们不爱喝啊。 我还活着，活着就好！ 愿你喜乐安好！]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>人性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我在公司的第二次分享]]></title>
    <url>%2Fzh%2F2017%2F09%2F22%2F%E6%88%91%E5%9C%A8%E5%85%AC%E5%8F%B8%E7%9A%84%E7%AC%AC%E4%BA%8C%E6%AC%A1%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[我在公司的第二次分享。分享前端一些基础知识；分享 node + express 做接口封装；分享 vue + typeScript 的实践。 浏览器兼容性1234567[ "&gt; 1%", "last 3 versions", "ie &gt;= 9", "ios &gt;= 8", "android &gt;= 4.4"] 防抖和节流防抖和节流 防抖 debouncelodash.debounce 1234567891011121314151617181920212223242526272829303132333435const debounce = function(func, wait, immediate) &#123; // immediate 默认为 false var timeout, args, context, timestamp, result; var later = function () &#123; // 当 wait 指定的时间间隔期间多次调用 debounce 返回的函数，则会不断更新 timestamp 的值，导致 last &lt; wait &amp;&amp; last &gt;= 0 一直为 true，从而不断启动新的计时器延时执行 func var last = +new Date() - timestamp; if (last &lt; wait &amp;&amp; last &gt;= 0) &#123; timeout = setTimeout(later, wait - last); &#125; else &#123; timeout = null; if (!immediate) &#123; result = func.apply(context, args); if (!timeout) context = args = null; &#125; &#125; &#125;; return function() &#123; context = this; args = arguments; timestamp = +new Date(); // 第一次调用该方法时，且immediate为true，则调用func函数 var callNow = immediate &amp;&amp; !timeout; // 在wait指定的时间间隔内首次调用该方法，则启动计时器定时调用func函数 if (!timeout) timeout = setTimeout(later, wait); if (callNow) &#123; result = func.apply(context, args); context = args = null; &#125; return result; &#125;;&#125; 节流 throttleH5网页基础]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我在公司的第一次分享]]></title>
    <url>%2Fzh%2F2017%2F08%2F08%2F%E6%88%91%E5%9C%A8%E5%85%AC%E5%8F%B8%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AC%A1%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[我在公司的第一次分享。分享两次事故。 7月4日，因为项目中有一个记录用户报名推荐人的需求（类似分享赚），这个需要从 cookie 中获取。由于工作人员对相关技术问题知之甚少，链接配置有问题会导致推荐人获取错误。为了定位这个问题，我私下和后端商议，多写入一个 location.href 的信息，但是双方都没有考虑到数据库的最大写入值。由于在测试及预发验证不到位，这个隐患问题没有被发现。下午4点左右发版上线。我于6点下班。很快在6点半到7点半之间陆续暴露出问题。急忙赶回家，7点50分左右，因为很清楚是什么地方改动，而且属于小改动，我对此进行修复。 总结：客观原因是，前端写入值超过后端数据库规定最大写入值，但后端未做拦截；主观原因是，我私下和后端商议，未考虑周全，未做风险评估，未上报测试。 8月8日，项目新需求准备发版，因框架升级可以修复之前的问题，所以借此次需求我对项目进行升级。在升级过程中，从本地到开发到测试到预发环境，依次都展现出框架升级后的各类问题，针对各类问题，我在各类环境进行修复。主要是框架升级后，和其他库或者代码有所冲突。本次升级还有个比较麻烦的事是在各类环境装包 npm install 或者 yarn install 都失败，因此我将本地包压缩上传到开发环境，再进行解压。很快，开发环境调通。再发布到测试环境，测试环境经过测试人员验证，也没有问题。再发布到预发布环境，依然正常。最后于下午3点半左右发版上线，因为框架升级，由运维解压包然后我重启服务器。注意，我隐约觉得有问题，发之前我也和测试透露出可能有问题（我心里知道会出现和预发布环境一样的包问题），但觉得预发布环境调通了，线上即使出现问题，应该很快就可以解决，过于自信，过于大胆，我让运维在两台服务器上同时进行解压，然后我同时进行了重启。下一秒后，整个项目挂了。我第一反应是，立马暂停服务器，从而线上报 502。然后我去看线上环境的包，发现线上包和预发布环境包不一样，我立马让运维重新进行解压，并且我尝试进行手动发布包。于此同时，陆续有人反应项目挂了，说明此时确实是高峰期。我和运维不断发布／上传／压缩／解压／重启，但是依然不成功，时间已经过去半个小时，这时候多方人员要求我先进行回滚。我说没法回滚，主要原因是太麻烦了，而且回滚了也不一定成功。因为整个项目进行了升级，很多包发生变化，新的包覆盖旧的包没有完全生效，此时若回滚，需要将旧的包重新上传对【旧-新杂交包】进行覆盖，我没有把握可以成功。在4点和5点之间我们还在定位问题，我一边让运维将线上的包全部删除后再重新安装，一边在准备回滚（将上个版本的打包尝试替换）。线上安装的很慢，而我这里回滚进展的也很慢。而时间已经到了下午5点，事故已经发生一个半小时，上级领导决定让运维将线上切到预发布，这样可以让项目暂时可用，毕竟预发布是正常的，可以堵住问题的继续喷发。这样我就暂停了回滚，继续和运维在线上服务器进行尝试安装包，期待是因为包的问题导致项目异常。下午6点左右，两台装了一个半小时包的服务器终于装完了。。。我立马进行重启，终于正常了。。。 总结：客观原因是，由于网络或其他原因，各环境装包困难，由本地装的包发到线上后，可能存在兼容问题，或者在解压覆盖过程中，出现偏差，具体是什么原因，真的不知道，反正包不对；主观原因是，我对框架进行升级，有一些包发生变化，这样可能带来隐患，未做考虑周全，未风险评估，未上报测试，虽然知道可能会出现问题但是没有做好事故发生的应对方案。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>工作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2Fzh%2F2016%2F01%2F01%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartStart your blog. Create a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment 找对象月薪1万+，不打老婆，房产证上写你名，工资卡上交，拿去随便刷，买买买！家里没皇位继承不用生儿子，你若难产我保大！饭我做，碗我刷，衣服我洗，孩子我带。我负责赚钱养家，你负责貌美如花！我是认真的！你找吧，你能找到比我对你更好的，我给你跪下！]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
</search>
